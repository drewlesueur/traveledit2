<!doctype html>
<!--
fix issue with knowing position changes
undo and redo need to make the document "dirty"
like when you paste and have a highlight range
also with the undo

don't allow rerun on a reloaded session terminal


button to increase or decrease number
allow graphs and visualizations

issue with streaming chatgpt after refresh

we need a one tap copy (long tap copy block)
one tap indent, long tap indent block

left slice  repurposed for copy?!
-->
<html>
<head>
<script>
var proxyPath = ""
// PROXYPATH GOES HERE

var isGitBash = false
// ISGITBASH GOES HERE

</script>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, max-scale=1">
<meta name="apple-mobile-web-app-title" content="Editor">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="theme-color" content="black">
<!--
<meta name="apple-mobile-web-app-status-bar-style" content="black">
-->

<meta charset='utf-8'>

<script>
document.write(`
<!-- For now not loading in third party diff library. -->
<!--<script src="`+proxyPath+`/tepublic/diff.js"></scr`+`ipt>-->
<script src="`+proxyPath+`/tepublic/md52.js"></scr`+`ipt>
<!--<script src="`+proxyPath+`/tepublic/thumbscript4.js?v=`+Date.now()+`"></scr`+`ipt>-->
`)
</script>
<script src="https://unpkg.com/sval@0.4.8/dist/sval.min.js"></script>
<style>
* {
    margin: 0; padding: 0;
    box-sizing: border-box;
}
.dark {
    background-color: black;
    color: white;
}
.light {
    background-color: lightyellow;
    -- background-color: white;
    color: black;
}
.text { border: none; color: cyan;
}


.fullWidth {
    width: 100%;
}


.toolbar {
    display: flex;
    flex-flow: row nowrap;
    overflow: scroll;
    -webkit-overflow-scrolling: touch;
}
.hidden {
   display: none;
}

body.dark .toolbar div {
    /* see renderDarkMode */
    border-left: 1px solid #cb9;
    border-top: 1px solid #cb9;
    color: #cb9;
    --border-left: 1px solid rgba(255, 255, 200);
    --border-top: 1px solid rgba(255, 255, 200);
    --color: rgba(255, 255, 200);
    --border: 1px solid rgba(255, 255, 200);
    border-right: none;
    border-bottom: none;
    --border: none;
    --text-decoration: underline;
    --opacity: 0.7;
}
body.dark .toolbar div.selected {
    background-color: gray;
    color: black;
    --border: 1px solid black;
}
body.light .toolbar div {
    color: black;
    --border: 1px solid black;
    border-left: 1px solid black;
    border-top: 1px solid black;
    border-right: none;
    border-bottom: none;
}
body.light .toolbar div.selected {
    background-color: black;
    color: rgba(255, 255, 200);
    --border: 1px solid rgba(255, 255, 200);
}

.toolbar .icon {
    border: none !important;
    padding: 0 5px 0 5px;
    font-size: 14px;
    height: 30px;
    vertical-height: middle;
    flex: 1 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}
.toolbar .fileButton {
    padding: 0 5px 0 5px;
    height: 26px;
    margin: 0px;
    flex: 1 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    --border: none !important;
}
.toolbar div {
    --border-radius: 17px;
    font-size: 12px;
}
.toolbar .square {
    padding: 0px;
    width: 40px;
    height: 34px;
    margin: 0px;
    flex: 1 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}
.toolbar .longButton {
    padding: 0px;
    width: 80px;
    -- width: 60px;
    height: 34px;
    margin: 0px;
    flex: 1 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}
.toolbar .middleButton {
    padding: 0px;
    width: 60px;
    height: 34px;
    margin: 0px;
    flex: 1 0 auto;
    display: flex;
    align-items: center;
    justify-content: center;
    text-align: center;
}



/* 
 For iPad
 */
@media only screen
  and (min-width: 700px)
  and (orientation: portrait) {
  
    .toolbar .fileButton {
        min-width: 60px;
        height: 46px;
    }
    .toolbar .icon,
    .toolbar .square,
    .toolbar .longButton,
    .toolbar .middleButton {
        width: 120px;
        height: 54px;
    }
}



.toolbar .slotButton {
    overflow: hidden;
}

#fileRow div {
    font-size: 10px !important;
}

input[type="text"] {
    font-size: 16px;
    --border: 1px solid cyan;
    border: none;
}

#searchText {
    border: none;
}
#searchText::placeholder {
    --color: red;
    font-size: 10px;
}
#theText::placeholder {
    font-size: 12px;
}
</style> 
</head>
<body class=dark>
<div id=topPadding style="height: 0px;"></div>
<div style="
    display: flex;
    flex-flow: row nowrap;
">
    <pre id=statusEl class=hidden style="overflow:scroll; font-size: 10px;">
    </pre>
    <div id=logEl class=hidden style="height: 450px; width:240px;
    overflow:scroll;
    -webkit-overflow-scrolling: touch;
    font-size:10px;"
    ></div>
</div>
<!-- status bar -->
<div id=s style="font-size: 12px;
display: none;
position: absolute;
top: 10px; right:0;
z-index: 999;
color: magenta;
opacity: 0.5;
"></div>

<form onsubmit="">
    <textarea class=fullWidth type=text id=voiceCommandText
        style="display: none;
        font: 10px Courier;
        height: 24px;
        outline: none;
        background-color: saddlebrown;
        "
        onfocus="focusVoiceCommandText()"
        oninput="inputVoiceCommandText()"
        onblur="blurVoiceCommandText()"
    ></textarea>
    <input class=dark type=submit style="opacity: 0.01; position: absolute; left: -999px;" value="here">
</form>

<form onsubmit="runEditorCommand(event)">
    <input class=fullWidth type=text id=editorCommandText
        style="display: none;
        font: 16px Courier;
        height: 24px;
        outline: none;
        background-color: #777;
        "
        onfocus="focusEditorCommandText()"
        oninput="inputEditorCommandText()"
        onblur="blurEditorCommandText()"
    >

    <input class=dark type=submit style="opacity: 0.01; position: absolute; left: -999px;" value="here">
</form>
<form onsubmit="findDownForm(event)">
    <input id=searchTextBefore class=fullWidth type=text
    style="
    font: 8px Courier;
    height:1px; overflow: hidden;
    display: block;"
    onfocus=handleSearchFocusBefore()
    xonblur=handleBlur()
    >

    <input class=fullWidth type=text id=searchText
        style="display: none;
        font: 16px Courier;
        height: 24px;
        outline: none;
        "
        onfocus="focusSearchText()"
        oninput="inputSearchText()"
        onblur="blurSearchText()"
        onchange="saveSearchHistory()"
    >

    <input id=searchTextAfter class=fullWidth type=text
    style="
    font: 8px Courier;
    height:1px; overflow: hidden;
    display: block;
    "
    onfocus=handleSearchFocusAfter()
    xonblur=handleBlur()
    >

    <input class=dark type=submit style="opacity: 0.01; position: absolute; left: -999px;" value="here">
</form>

<form onsubmit="newLine(event, true)">

<input type=text id=theTextBefore class=fullWidth
style="
font: 8px Courier;
/* display: none; see what it looks like without */
height:1px; overflow: hidden;
display: block;"
onfocus=handleFocusBefore()
onblur=handleBlur()
>
<input id=theText class=fullWidth type=text
style="
font: 16px Times;
padding: 0;
color: brown;
height: 24px;
outline: none;
display: block;
"
onfocus=handleFocusIn()
onblur=handleBlur()
oninput=saveLine()
onkeydown=handleKeydown(event)
autocomplete="off"
>
<input type=text id=theTextAfter class=fullWidth
style="
font: 8px Courier;
/* display: none; see what it looks like without */
height:1px; overflow: hidden;
display: block;
"
onfocus=handleFocusAfter()
onblur=handleBlur()
>
<input class=dark type=submit style="opacity: 0.01; position: absolute; left: -999px;" value="here">
</form>
<!--
Note that the css width needs to be 1/3 of
the with attribute, and same for height.
See canvasHeightFull
The width and height here are placeholders
They get changed later on.
-->
<div id=canvasWrapper style="position: relative;">
    <canvas id=c width=99 height=99
    style="width: 375px; height:10px;
    display: block;"
    ontouchstart=onStart(event)
    ></canvas>
    <div id="iframeContainer" style="position:absolute; top:0; left:0;">
        <div id="iframeCursor" style="z-index:100; position:absolute; top:0; left:0; border-radius: 5px; border: 1px solid black; width: 10px; height: 10px; background-color: white;">
        </div>
    </div>
</div>
<div class="toolbar xhidden" id=fileRow onclick=selectFileRow(event)>
</div>
<div class="toolbar hidden" id=fileToolbar1 style="--display: none">
    <!--
    <div class=longButton onclick="openEditorCommandText()" >status</div>
    <div class=square onclick=undo()>undo</div>
    <div class=square onclick=redo()>redo</div>
    <div class=square onclick=reloadFile(fx)>reload</div>
    <div class=square onclick=goUpDirectory()>‚¨ÜÔ∏è</div>
    <div class=square id="gptButton2" onclick=runChatGPT('gpt-3.5-turbo')>chatGPT3.5</div>
    <div id=saveButton class=square onclick=saveWrapper()>save</div>
    <div class=square onclick="runScript()" id=statusBar>run script</div>
    -->
    
    <div class=middleButton onclick=reloadFile(fx)>reload</div>
    <div class=middleButton onclick=goUpDirectory()>‚¨ÜÔ∏è</div>
    <div class=middleButton id="gptButton" onclick="runChatGPT('gpt-5.1')">gpt-5.1</div>
    <div class=middleButton onclick="runChatGPT('gpt-5.1', {extra: onlyCode})">gpt-5.1 code</div>
    <div id=saveButton class=middleButton onclick=saveWrapper()>save</div>
    <div class=middleButton onclick="runScript()" id=statusBar>run script</div>
    <div class=middleButton onclick="runChatGPT('gpt-4.1')">4.1</div>
    <div class=middleButton onclick="runChatGPT('gpt-4.1', {extra: onlyCode})">4.1 code</div>
    <div class=middleButton onclick=runChatGPT('o3')>o3</div>
    <div class=middleButton onclick="runChatGPT('o3', {extra: onlyCode})">o3 code</div>
    <div class=middleButton onclick=runChatGPT('gpt-4.1-mini')>4.1 mini</div>
    <div class=middleButton onclick="runChatGPT('gpt-4.1-mini', {extra: onlyCode})">4.1 mini code</div>
    <div class=square onclick="window.open(location.origin+location.pathname+'/saveload?browser=1&fullpath=' + encodeURIComponent(fx.fullPath))">open browser</div>
    <div class=middleButton onclick=openAtCursor()>open</div>
    <div class=middleButton onclick="runScript()">action2</div>
    <div class=middleButton onclick="runScript()">action3</div>
    <div class=middleButton onclick="runChatGPT('o4-mini')">o4-mini</div>
    <div class=middleButton onclick="runChatGPT('o4-mini', {extra: onlyCode})">o4-mini code</div>
</div>
<div class="toolbar hidden" id=terminalToolbar1 style="--display: none">
    <div class=middleButton onclick='sendTerminal("\x03"); event.preventDefault()'>^C</div>
    <!-- don't really need tab because touching the screen gets you tab-->
    <!--
        <div class=middleButton onclick='sendTerminal("\t"); event.preventDefault() '>tab</div>
    -->
    <div class=middleButton onclick='clearLog(); event.preventDefault()'>clear</div>
    <div class=middleButton onclick='sendTerminal("\x1b[A"); event.preventDefault()'>up</div>
    <!-- ctrl c, clear, up, enter -->
    <div class=middleButton onclick='sendTerminal("git add -p"); event.preventDefault()'>-p</div>
    <div class=middleButton onclick='rerunTerminal()'>rerun</div>
    <div class=middleButton onclick='saveWrapper()'>run</div>
    <div class=middleButton id=slot1Button onclick='sendTerminal(slot1Input.value); event.preventDefault()'>slot 1</div>
    <div class=middleButton id=slot2Button onclick='sendTerminal(slot2Input.value); event.preventDefault()'>slot 2</div>
    <div class=middleButton id=slot3Button onclick='sendTerminal(slot3Input.value); event.preventDefault()'>slot 3</div>
    <div class=middleButton onclick='sendTerminal("\x1b"); event.preventDefault()'>esc</div>
    <div class=middleButton onclick='ctrlDown = true; event.preventDefault()'>ctrl</div>
    <div class=middleButton onclick='sendTerminal("\x1b[B"); event.preventDefault()'>down</div>
    <div class=middleButton onclick='sendTerminal("\x1b[D"); event.preventDefault()'>left</div>
    <div class=middleButton onclick='sendTerminal("\x1b[C"); event.preventDefault()'>right</div>
</div>

<div class="toolbar hidden" id=iframeToolbar1 style="--display: none">
    <div class=square onclick="fx.iframe.contentWindow.location.reload()">refresh iframe</div>
</div>

<!-- workspace toolbar was here -->

<div class="toolbar hidden" id=shellToolbar1 style="--display: none">
    <div class=middleButton onclick=openAtCursor()>open</div>
    <div class=middleButton onclick='clearLog(); event.preventDefault()'>clear</div>
    <div class=middleButton onclick='runShellCommand("git diff")'>diff</div>
    <div class=middleButton onclick='runShellCommand("git diff --cached")'>diff --cached</div>
    <div class=middleButton onclick='readySameCommitAsBefore()'>commit -m</div>
    <div class=middleButton onclick='saveWrapper()'>run</div>
    <div class=middleButton onclick='runShellCommand("git status")'>status</div>
    <div class=middleButton onclick='runShellCommand("git push origin HEAD")'>push origin H</div>
    <div class=middleButton onclick='runShellCommand("TZ=America/Phoenix git log --date=local -p -3")'>log -p</div>
    <div class=middleButton onclick='runShellCommand("TZ=America/Phoenix git log --date=local -10")'>log</div>


    <!-- this one tries to make light backgroud, but doesn't work with mac sed.
    <div class=middleButton onclick='runShellCommand("git add -u :/")'>add -u :/</div>
    <div class=middleButton onclick='runShellCommand("git branch")'>branch</div>
    <div class=middleButton onclick='runShellCommand("git status")'>status</div>
    <div class=middleButton onclick='runShellCommand("rm coverage.out coverage.html; if go test -cover -coverprofile coverage.out ./...; then go tool cover -func=coverage.out; go tool cover -o=coverage.html -html=coverage.out; fi")'>gotest</div>
    <div class=middleButton onclick='runShellCommand("rm coverage.out coverage.html; if go test -cover -coverprofile coverage.out ./...; then go tool cover -func=coverage.out; go tool cover -o=coverage.html -html=coverage.out; sed -i &apos;s/black;/white;/g&apos; coverage.html; fi")'>gotest</div>
    <div class=middleButton onclick='insertText(["git commit -m &apos;&apos;"], 0, 15)'>commit -m</div>
    <div class=middleButton onclick='insertText(["git checkout "], 0, -1)'>checkout</div>
    <div class=middleButton onclick='insertText(["git checkout -b "], 0, -1)'>checkout -b</div>
    -->


</div>
<div class="toolbar hidden" id=shellToolbar2 style="--display: none">
    <!--
    <div class=square onclick='runShellCommand("git log -10")'>log -10</div>
    <div class=square onclick='runShellCommand("git log -p -3")'>log -p -3</div>
    <div class=square onclick='runShellCommand("cd ..")'>cd ..</div>
    <div class=square onclick='runShellCommand("git stash")'>stash</div>
    <div class=square onclick='runShellCommand("git stash pop")'> stash pop</div>
    <div class=square onclick='runShellCommand("git pull origin master")'>pull origin m</div>
    -->
</div>
<!--<div class="toolbar xhidden" id=fileRow ontouchstart=selectFileRow(event)>-->
<!--Select file row was here-->
<div class=toolbar>
</div>
<div class=toolbar>
    <!--
        <div id=clearSearchButton class=square onclick=clearSearch()>clear search</div>
        <div class=square onclick=editSearch()>edit search</div>
    -->
    <div class=square onclick="osCopyText()" id=statusBar2>os copy</div>
    <div class=square onclick="osPasteText()" id=statusBar3>os paste</div>
    <div class=square onclick=addCmdTab()>cmd</div>
    <div class=square onclick=addTerminalTab()>xterm</div>
    <div class=square onclick=closeFile()>close</div>
    <!--
    <div class=square onclick=comment()>//</div>
    <div class=square onclick=seeFiles()>files</div>
    -->
</div>
<div class=toolbar>
    <!-- done on touchTopTopLeft and touchTopTopRight  -->
    <!--
        <div class=square onclick=redo()>redo</div>
        <div class=square onclick=undo()>undo</div>
    -->
</div>

<div class=toolbar>
    <div class=longButton onclick="selectFont('Menlo')">Menlo</div>
    <div class=longButton onclick="selectFont('GoogleSansCode')">Google</div>
    <div class=longButton onclick="selectFont('XanhMono')">Xanh</div>
    <div class=longButton onclick="selectFont('BradfordMono')">BradfordMono</div>
    <div class=longButton onclick="selectFont('RightSerifMono')">Right Serif Mono</div>
    <div class=longButton onclick="selectFont('RightSerifMonoFine')">Right Serif Mono Fine</div>
    <div class=longButton onclick="selectFont('RightSerifMonoDark')">Right Serif Mono Dark</div>
    <div class=longButton onclick="selectFont('Libertinus')">Libertinus</div>
    <div class=longButton onclick="selectFont('Fixedsys')">Fixedsys</div>
    <div class=longButton onclick="selectFont('KelmscottMono')">Kelmscott Mono</div>
    <div class=longButton onclick="selectFont('RedditMono')">Reddit Mono</div>
    <div class=longButton onclick="selectFont('InputMono')">Input Mono</div>
    <div class=longButton onclick="selectFont('SFMono')">SF Mono</div>
    <div class=longButton onclick="selectFont('CommitMono')">Commit Mono</div>
    <div class=longButton onclick="selectFont('cousine')">cousine</div>
    <div class=longButton onclick="selectFont('robotomono')">robotomono</div>
    <div class=longButton onclick="selectFont('fragmentmono')">fragmentmono</div>
    <div class=longButton onclick="selectFont('ibmplexmono')">ibmplexmono</div>
    <div class=longButton onclick="selectFont('GeistMono')">Geist Mono</div>
    <div class=longButton onclick="selectFont('chivomonolight')">chivomonolight</div>
    <div class=longButton onclick="selectFont('notosansmono')">notosansmono</div>
    <div class=longButton onclick="selectFont('firacode')">firacode</div>
    <div class=longButton onclick="selectFont('firamono')">firamono</div>
    <div class=longButton onclick="selectFont('sourcecodepro')">sourcecodepro</div>
    <div class=longButton onclick="selectFont('redhatmono')">redhatmono</div>
    <div class=longButton onclick="selectFont('ptmono')">ptmono</div>
    <div class=longButton onclick="selectFont('anonymouspro')">anonymouspro</div>
    <div class=longButton onclick="selectFont('victormono')">victormono</div>
    <div class=longButton onclick="selectFont('AtkinsonMono')">Atkinson Mono</div>
    <div class=longButton onclick="selectFont('ZedMono')">Zed Mono</div>
    
    
    
    <div class=longButton onclick="selectFont('Martha')">Martha</div>
    <div class=longButton onclick="selectFont('BerkeleyMono')">Berkeley Mono</div>
    <div class=longButton onclick="selectFont('chivomono')">chivomono</div>
    <div class=longButton onclick="selectFont('azeretmono')">azeretmono</div>
    <div class=longButton onclick="selectFont('martianmono')">martianmono</div>
    <div class=longButton onclick="selectFont('spacemono')">spacemono</div>
    <div class=longButton onclick="selectFont('jetbrainsmono')">jetbrainsmono</div>
    <div class=longButton onclick="selectFont('JetBrainsMono')">JetBrainsMono</div>
    <div class=longButton onclick="selectFont('Neon')">Neon</div>
    <div class=longButton onclick="selectFont('splinesansmono')">splinesansmono</div>
    <div class=longButton onclick="selectFont('NanumGothicCoding')">Nanum GC</div>
    
    
    
    <div class=longButton onclick="selectFont('Argon')">Argon</div>
    <div class=longButton onclick="selectFont('Krypton')">Krypton</div>
    <div class=longButton onclick="selectFont('Radon')">Radon</div>
    <div class=longButton onclick="selectFont('Xenon')">Xenon</div>
    <div class=longButton onclick="selectFont('Courier')">Courier</div>
    <div class=longButton onclick="selectFont('Dossier')">Dossier</div>
    <div class=longButton onclick="selectFont('InputMonoX')">Input Mono X</div>
    <div class=longButton onclick="selectFont('VictorMono')">Victor Mono</div>
    <div class=longButton onclick="selectFont('SaxMono')">Sax Mono</div>
    <div class=longButton onclick="selectFont('VictorMonoMedium')">Victor Mono M</div>
    <div class=longButton onclick="selectFont('VictorMonoSemiBold')">Victor Semi Bold</div>
    <div class=longButton onclick="selectFont('SourceCodePro')">Source Code Pro</div>
    <div class=longButton onclick="selectFont('InputMonoLucida')">Input Mono L</div>
    <div class=longButton onclick="selectFont('IosevkaLucida')">Iosevka L</div>
    <div class=longButton onclick="selectFont('IosevkaLucidaMedium')">Iosevka L Medium</div>
    <div class=longButton onclick="selectFont('IosevkaLucidaSemiBold')">Iosevka L SemiBold</div>
    <div class=longButton onclick="selectFont('IosevkaLucidaThin')">Iosevka L Thin</div>
    <div class=longButton onclick="selectFont('CourierThin')">Courier Thin</div>
    <div class=longButton onclick="selectFont('SFMonoThin')">SF Thin</div>
    <div class=longButton onclick="selectFont('IosevkaThin')">Iosevka Thin</div>
    <div class=longButton onclick="selectFont('Iosevka')">Iosevka</div>
    <div class=longButton onclick="selectFont('IosevkaSlab')">Iosevka S</div>
    <div class=longButton onclick="selectFont('XanhMono')">Xanh</div>
    <div class=longButton onclick="selectFont('Inconsolata')">Inconsolata</div>
    <div class=longButton onclick="selectFont('InconsolataThin')">Inconsolata Thin</div>
    <div class=longButton onclick="selectFont('Courier New')">Courier New</div>
    <div class=longButton onclick="selectFont('GillSans')">Gill Sans</div>
    <div class=longButton onclick="selectFont('AmericanTypewriter')">American T</div>


    <div class=longButton onclick="selectFont('b612mono')">b612mono</div>
    <div class=longButton onclick="selectFont('courierprime')">courierprime</div>
    <div class=longButton onclick="selectFont('sono')">sono</div>
    <div class=longButton onclick="selectFont('sometypemono')">sometypemono</div>
    <div class=longButton onclick="selectFont('cutivemono')">cutivemono</div>
    <div class=longButton onclick="selectFont('dmmono')">dmmono</div>
    <div class=longButton onclick="selectFont('inconsolata')">inconsolata</div>
    <div class=longButton onclick="selectFont('mplus1code')">mplus1code</div>
    <div class=longButton onclick="selectFont('nanumgothiccoding')">nanumgothiccoding</div>
    <div class=longButton onclick="selectFont('overpassmono')">overpassmono</div>
    <div class=longButton onclick="selectFont('oxygenmono')">oxygenmono</div>
    <div class=longButton onclick="selectFont('sharetechmono')">sharetechmono</div>
    <div class=longButton onclick="selectFont('ubuntumono')">ubuntumono</div>
    <div class=longButton onclick="selectFont('wellfleet')">wellfleet</div>
    <div class=longButton onclick="selectFont('IosevkaExtended')">IkaE (slow)</div>
    <div class=longButton onclick="selectFont('ZedMono')">Zed Mono</div>
</div>


<div class=toolbar>
    <div class=square onclick="cleanUpFiles()">Clean Up</div>
    <!--
        <div class=square onmousedown="setCurrentFile(lastFile)" ontouchstart="setCurrentFile(lastFile); event.preventDefault(); event.stopPropagation()">alt tab</div>
        <div class=square onclick="googleIt()">Google it</div>
        <div class=square onclick="scriptLinesWithOneLineScript(&quot;x.replace(/->/g, '‚Üí')&quot;)">‚Üí</div>
    -->
    <div class=square onclick="showLog()">show log</div>
    <div class=square onclick="linkToRemote()">Share code</div>
    <!--
        <div class=square onclick="duplicateFile(fx, -1)">dupl file</div>
    -->
    <div class=square onclick="compareSets()">compare sets</div>
    <div class=square onclick=openEditorCommandText()>editor cmd</div>
    <div class=square onclick=doRefresh()>refresh</div>
    <!--
        <div class=square onclick="deleteBelow();">del below</div>
    -->
</div>
<!-- Stuff after here is after the fold -->
<div class=toolbar>
    <div class=square onclick="copyBuffer = [location.href]; osCopyText()">copy url</div>
    <div class=square onclick="copyString(fx.fullPath + ':' + (fx.cursorLineIndex + 1))">copy path</div>
    <div class=square onclick="showDiff()">show diff</div>
    <div class=square onclick="setHighlightMatches()">set highlight</div>
    <div id=darkModeButton class=square onclick="toggleDarkMode()">light</div>
    <div class=square onclick=openAtCursor()>open</div>
    <div class=square onclick=scriptLines()>script lines</div>
</div>
<div class=toolbar>
    <div class=square onclick=toggleDebugView()>debug view</div>
    <div class=square onclick=doEval()>eval</div>
    <div class=square onclick="reloadAll()">reload all</div>
    <div class=square onclick="comment('--')">--</div>
    <div class=square onclick="clearTrailingWhitespace()">&times; tr whitespace</div>
    <div id=toggleTabStopButton class=square onclick="toggleTabStop()">tabs</div>
</div>
<div class="toolbar" id=workspaceToolbar onclick=selectWorkspaceToolbar(event) style="">
</div>
<div class=toolbar>
    <div class=square onclick=doFormat()>format</div>
    <div class=square onclick="toggleSeeTabs()">see tabs</div>
    <div class=square onclick="diffFiles()">diff files</div>
    <div id=darkModeButton class=square onclick="toggleCompactRender()">compact</div>
    <div class=square onclick="moveFileLeft()">move left</div>
    <div class=square onclick="moveFileRight()">move right</div>
    <div class=square onclick="stopServer()">stop server</div>
</div>
<div class=toolbar>
    <div class=square onclick="moveFileAllTheWayLeft()">move home</div>
    <div class=square onclick="downloadFile()">Download</div>
    <div class=square onclick="saveWorkspace()">save workspace</div>
    <div class=square onclick="location.href = proxyPath + '/login'">login</div>
    <div class=square onclick=urlAtCursor()>visit</div>
    <div class=square onclick="doRefresh()">refresh</div>
</div>
<div class=toolbar>
    <div class=square onclick="window.open(location.origin+location.pathname+'/saveload?browser=1&fullpath=' + encodeURIComponent(fx.fullPath))">open browser</div>
    <div class=square onclick="navigator.clipboard.writeText(location.origin+location.pathname+'/saveload?browser=1&fullpath=' + encodeURIComponent(fx.fullPath))">copy browser</div>
    <div class=square onclick="addIframe(location.origin+location.pathname+'/saveload?browser=1&fullpath=' + encodeURIComponent(fx.fullPath))">iframe browser</div>
    <div class=square onclick="doSizing(); render()">do sizing</div>
    <div class=square onclick=gotoDefinition()>goto def</div>
</div>
<div class=toolbar>
    <div class=square onclick="copyOneTimeLink()">one-time link</div>
    <div class=square onclick=record()>üé§</div>
    <div class=square onclick=startVoiceCommandsV2()>voice üó£Ô∏è</div>
    <div class=square onclick=recordVideo()>üé• video</div>
    <div class=square onclick=openEditorCommandText()>editor cmd</div>
    <div class=square onclick="window.open('https://github.com/drewlesueur/traveledit/archive/refs/heads/master.zip')">doenload repo</div>
</div>
<div class=toolbar>
    <!--<div class=square onclick=addSpace()>space</div>
    <div class=square onclick=backspace()>backspace</div>
    <div class=square onclick="theText.focus()">insert</div>
    <div class=square onclick="newLine(null, false)">new line</div>

    <div class=square onclick=comment()>//</div>
    <div id=findUpButton class=square onclick=findUp()>find up</div>
    <div id=findDownButton class=square onclick=findDown()>find down</div>
    <div class=square onclick=clearLog()>clear log</div>
    <div class=square onclick=reloadFile(fx)>reload</div>

    -->
</div>
<div class=toolbar>
    <select onclick="selectFont('')">
    </select>
</div>
<div class=toolbar>
    <div class=longButton onclick="fontScale = 0.4; updateFontScale()">0.4</div>
    <div class=longButton onclick="fontScale = 0.5; updateFontScale()">0.5</div>
    <div class=longButton onclick="fontScale = 0.6; updateFontScale()">0.6</div>
    <div class=longButton onclick="fontScale = 0.7; updateFontScale()">0.7</div>
    <div class=longButton onclick="fontScale = 0.8; updateFontScale()">0.8</div>
    <div class=longButton onclick="fontScale = 0.9; updateFontScale()">0.9</div>
    <div class=longButton onclick="fontScale = 0.95; updateFontScale()">0.95</div>
    <div class=longButton onclick="fontScale = 1.0; updateFontScale()">1.0</div>
    <div class=longButton onclick="fontScale = 1.1; updateFontScale()">1.1</div>
    <div class=longButton onclick="fontScale = 1.15; updateFontScale()">1.15</div>
    <div class=longButton onclick="fontScale = 1.2; updateFontScale()">1.2</div>
    <div class=longButton onclick="fontScale = 1.3; updateFontScale()">1.3</div>
    <div class=longButton onclick="fontScale = 1.4; updateFontScale()">1.4</div>
    <div class=longButton onclick="fontScale = 1.5; updateFontScale()">1.5</div>
    <div class=longButton onclick="fontScale = 1.6; updateFontScale()">1.6</div>
    <div class=longButton onclick="fontScale = 1.7; updateFontScale()">1.7</div>
    <div class=longButton onclick="fontScale = 2; updateFontScale()">2</div>
    <div class=longButton onclick="fontScale = 3; updateFontScale()">3</div>
    <div class=longButton onclick="fontScale = 4; updateFontScale()">4</div>
    <div class=longButton onclick="fontScale = 5; updateFontScale()">5</div>
</div>
<label for=allowPollingCheckbox>
    <input onchange="allowPolling = allowPollingCheckbox.checked" type=checkbox name=allowPollingCheckbox id=allowPollingCheckbox checked />
    allow polling
</label>
<label for=useUnicodeCheckbox>
    <input onchange="useUnicode = useUnicodeCheckbox.checked" type=checkbox name=useUnicodeCheckbox id=useUnicodeCheckbox checked />
    use unicode
</label>
<label for=agressiveRenderCheckbox>
    <input onchange="agressiveRender = agressiveRenderCheckbox.checked" type=checkbox name=agressiveRenderCheckbox id=agressiveRenderCheckbox />
    agressive render
</label>
<label for=saveDiffsCheckbox>
    <input onchange="saveDiffs = saveDiffsCheckbox.checked" type=checkbox name=saveDiffsCheckbox id=saveDiffsCheckbox checked />
    save diffs
</label>
<label for=showFilesFlatFirstCheckbox>
    <input onchange="showFilesFlatFirst = showFilesFlatFirstCheckbox.checked" type=checkbox name=showFilesFlatFirstCheckbox id=showFilesFlatFirstCheckbox checked />
    flat file list
</label>
<label for=bluetoothKeyboardCheckbox>
    <input onchange="bluetoothKeyboard = bluetoothKeyboardCheckbox.checked" type=checkbox name=bluetoothKeyboardCheckbox id=bluetoothKeyboardCheckbox />
    bluetooth keyboard
</label>
<label for=floatingKeyboardCheckbox>
    <input onchange="floatingKeyboard = floatingKeyboardCheckbox.checked" type=checkbox name=floatingKeyboardCheckbox id=floatingKeyboardCheckbox />
    floating keyboard
</label>
<label for=fauxMonoCheckbox>
    <input onchange="fauxMono = fauxMonoCheckbox.checked" type=checkbox name=fauxMonoCheckbox id=fauxMonoCheckbox />
    faux mono
</label>
<label for=frakturCheckbox>
    <input onchange="fraktur = frakturCheckbox.checked" type=checkbox name=frakturCheckbox id=frakturCheckbox />
    fraktur
</label>
<label for=syntaxHighlightCheckbox>
    <input onchange="syntaxHighlight = syntaxHighlightCheckbox.checked" type=checkbox name=syntaxHighlightCheckbox id=syntaxHighlightCheckbox />
    syntax highlight
</label>
<label for=caseSensitiveSearchCheckbox>
    <input onchange="caseSensitiveSearch = caseSensitiveSearchCheckbox.checked" type=checkbox name=caseSensitiveSearchCheckbox id=caseSensitiveSearchCheckbox />
    case sensitive search
</label>
<label for=showGoErrorsCheckbox>
    <input onchange="showGoErrors = showGoErrorsCheckbox.checked" type=checkbox name=showGoErrorsCheckbox id=showGoErrorsCheckbox />
    show Go errors
</label>
<br>
<label for=serverViewCheckbox>
    <input onchange="serverViewFeature = serverViewCheckbox.checked" type=checkbox name=serverViewCheckbox id=serverViewCheckbox />
    Screen Share
</label>
<br>
<label for=lockXCheckbox>
    <input onchange="lockX = lockXCheckbox.checked" type=checkbox name=lockXCheckbox id=lockXCheckbox />
    Lock X
</label>
<br>
<label for=reorderFilesCheckbox>
    <input onchange="reorderFiles = reorderFilesCheckbox.checked" type=checkbox name=reorderFilesCheckbox id=reorderFilesCheckbox />
    Auto-Reorder Files
</label>
<!--
<iframe width="100%" height=400 src="/te/screenshare"></iframe>
-->

<!-- These textareas are for if you are not on https and can't use osCopu and osPaste functions -->
<textarea class=dark id=pasteEl
style="width:100%; height:100px;"
onfocus="this.setSelectionRange(0, this.value.length)"
oninput=importPaste()
>when you add text here it will be copied</textarea>

<textarea class=dark id=copyEl
contenteditable
onfocus="this.setSelectionRange(0, this.value.length)"
style="width:100%; height:100px;"
    placeholder="when you copy something, it will show up here"
></textarea>
<input class=slotButton placeholder="slot 1" id=slot1Input onchange='localStorage.setItem("slot1", this.value); slot1Button.innerText = this.value;'/>
<input class=slotButton placeholder="slot 2" id=slot2Input onchange='localStorage.setItem("slot2", this.value); slot2Button.innerText = this.value;' />
<input class=slotButton placeholder="slot 3" id=slot3Input onchange='localStorage.setItem("slot3", this.value); slot3Button.innerText = this.value;' />
<form onsubmit=uploadFile(event)>
    Upload files:<br>
    <input id=filesToUpload type=file multiple>
    <input type=Submit value=Upload>
</form>
<a href=/>
<script>
document.write(`
<a href="`+proxyPath+`/tepublic/imageedit.html">Image Edit</a>
<a href="`+proxyPath+`/tepublic2/">Public 2</a>
<a href="`+proxyPath+`/screenshare">screenshare</a>
`)
</script>
<div id=urlEl></div>
<div id=bottomPadding style="height: 100px;"></div>
<div id=colorGetterEl style="width: 100px; height: 100px;"></div>
</div>

</div> <!-- end wrapper -->
<script>
// it's important that this go in it's own script tag
window.onerror = function(message, url, lineNumber, columnNumber, error) {
    if (confirm((lineNumber - 1) + ": " + message)) {
        location.href = proxyPath + "?indexFile=./public/index2.html"
    }
}
</script>
<script>
urlEl.innerText = location.href
slot1Input.value = localStorage.getItem("slot1")
slot1Button.innerText = localStorage.getItem("slot1") || "slot 1"
slot2Input.value = localStorage.getItem("slot2")
slot2Button.innerText = localStorage.getItem("slot2") || "slot 2"
slot3Input.value = localStorage.getItem("slot3")
slot3Button.innerText = localStorage.getItem("slot3") || "slot 3"
var t = c.getContext("2d")
// if ('filter' in t) {
//   alert("filter")
//   t.filter = "blur(3px)";
// } else {
//   alert("shadow")
//   t.shadowColor = "white";
//   t.shadowBlur = 15;
//   t.shadowOffsetX = 0;
//   t.shadowOffsetY = 0;
// }

var preventRender = true
// var saveDiffs = false
var saveDiffs = true
var totalViewBytesSent = 0
var totalViewRequests = 0
var saveEveryMS = 3000
var lastWord = ""
var lastCleared = ""
var fontScale = 1.2
var useUnicode = true
// var useUnicode = false
var emojiWidth = 2
// var emojiWidth = 1
var compactRender = false
var agressiveRender = false

var toolbars = document.querySelectorAll(".fullWidth")
for (var i=0; i<toolbars.length; i++) {
    var toolbar = toolbars[i]
    toolbar.style.width = innerWidth + "px"
}
var highlightText = "" // deprecated
var highlightMatchesSingleRegExp
var highlightMatches = []
var pathDecorators = []

var wordAtCursor = ""
var wordAtCursorRegexp = null

function calcMarginLeft(lineLength) {
    var ret = Math.ceil(Math.log(lineLength + 1)/Math.log(10)) + 1
    return ret
}

var onlyCode = '\nOnly give me code, no explanation, no markdown wrapper. Just the code.'

// other fonts.
// Berkeley Mono, Cascadia, Consolas, Operator, Mona Lisa, Commit Mono, Cartograph, Martha from Coppers Brasses
// https://klim.co.nz/retail-fonts/founders-grotesk-mono/
// https://www.colophon-foundry.org/typefaces/basis-grotesque-mono
// https://abcdinamo.com/typefaces/monument-grotesk
// sohne mono
var fonts = {
    "BradfordMono": {
        fontHeightPre: 38,
        fontWidthPre: 17.5,
        fontSize: 30,
        fontName: "BradfordMono",
        // fontOffsetYPre: 3,
        url: proxyPath + "/tepublic/BradfordMono/BradfordMonoLLTrialWeb-Regular.woff2"
    },
    "RightSerifMono": {
        fontHeightPre: 38,
        fontWidthPre: 17.5,
        fontSize: 30,
        fontName: "RightSerifMono",
        // fontOffsetYPre: 3,
        url: proxyPath + "/tepublic/RightSerifMono/PPRightSerifMono-Regular.otf"
    },
    "RightSerifMonoFine": {
        fontHeightPre: 38,
        fontWidthPre: 17.5,
        fontSize: 30,
        fontName: "RightSerifMonoFine",
        // fontOffsetYPre: 3,
        url: proxyPath + "/tepublic/RightSerifMono/PPRightSerifMono-Fine.otf"
    },
    "RightSerifMonoDark": {
        fontHeightPre: 38,
        fontWidthPre: 17.5,
        fontSize: 30,
        fontName: "RightSerifMonoDark",
        // fontOffsetYPre: 3,
        url: proxyPath + "/tepublic/RightSerifMono/PPRightSerifMono-Dark.otf"
    },
    "BerkeleyMono": {
        fontHeightPre: 38,
        fontWidthPre: 17.5,
        fontSize: 30,
        fontName: "BerkeleyMono",
        // fontOffsetYPre: 3,
        url: proxyPath + "/tepublic/BerkeleyMonoTrial-Regular.otf"
    },
    "ZedMono": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "ZedMono",
        // fontOffsetYPre: 3,
        url: proxyPath + "/tepublic/zed-mono-regular.ttf"
    },
    "CommitMono": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "CommitMono",
        // fontOffsetYPre: 3,
        url: proxyPath + "/tepublic/CommitMono-400-Regular.otf"
    },
    // "Martha": {
    //     fontHeightPre: 38,
    //     fontWidthPre: 18,
    //     fontSize: 30,
    //     fontName: "Martha",
    //     fontOffsetYPre: 3,
    //     url: proxyPath + "/tepublic/martha.otf"
    // },
    "IosevkaExtended": {
        // this font is crazy slow!
        // but my other ones aren't?
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "IosevkaExtended",
        // url: "https://iosevka-webfonts.github.io/iosevka-term/woff2/iosevka-term-extended.woff2"
        // url: "https://iosevka-webfonts.github.io/iosevka/WOFF2/Iosevka-Extended.woff2"
        // url: "https://iosevka-webfonts.github.io/iosevka/TTF/Iosevka-Extended.ttf"
        // url: "https://iosevka-webfonts.github.io/iosevka-fixed/ttf/iosevka-fixed-extended.ttf"
        url: "https://iosevka-webfonts.github.io/iosevka-fixed/woff2/iosevka-fixed-extended.woff2"
    },
    // "IosevkaExtended": {
    //     // this font is crazy slow!
    //     // but my other ones aren't?
    //     // even downloading raw ttf is slow!
    //     fontHeightPre: 38,
    //     fontWidthPre: 18,
    //     fontSize: 30,
    //     fontName: "IosevkaExtended",
    //     // descriptors: {stretch: "expanded"},
    //     // url: "https://iosevka-webfonts.github.io/iosevka/woff2/iosevka-extended.woff2"
    //     // url: "https://iosevka-webfonts.github.io/iosevka/ttf/iosevka-extended.ttf"
    //     url: proxyPath + "/tepublic/iosevka/iosevka-extended.ttf"
    // },
    "Neon": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontOffsetYPre: 3,
        fontSize: 30,
        fontName: "Neon",
        // url: proxyPath + "/tepublic/monaspace/monaspace-v1.000/fonts/webfonts/MonaspaceNeon-Regular.woff"
        // url: proxyPath + "/tepublic/monaspace/monaspace-v1.000/fonts/otf/MonaspaceNeon-Regular.otf"
        url: "https://github.com/githubnext/monaspace/raw/refs/heads/main/fonts/webfonts/MonaspaceNeon-Regular.woff2"
    },
    "Argon": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontOffsetYPre: 3,
        fontSize: 30,
        fontName: "Argon",
        // url: proxyPath + "/tepublic/monaspace/monaspace-v1.000/fonts/webfonts/MonaspaceArgon-Regular.woff"
        url: proxyPath + "/tepublic/monaspace/monaspace-v1.000/fonts/otf/MonaspaceArgon-Regular.otf"
    },
    "Krypton": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontOffsetYPre: 3,
        fontSize: 30,
        fontName: "Krypton",
        // url: proxyPath + "/tepublic/monaspace/monaspace-v1.000/fonts/webfonts/MonaspaceKrypton-Regular.woff"
        url: proxyPath + "/tepublic/monaspace/monaspace-v1.000/fonts/otf/MonaspaceKrypton-Regular.otf"
    },
    "Radon": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontOffsetYPre: 3,
        fontSize: 30,
        fontName: "Radon",
        // url: proxyPath + "/tepublic/monaspace/monaspace-v1.000/fonts/webfonts/MonaspaceRadon-Regular.woff"
        url: proxyPath + "/tepublic/monaspace/monaspace-v1.000/fonts/otf/MonaspaceRadon-Regular.otf"
    },
    "Xenon": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontOffsetYPre: 3,
        fontSize: 30,
        fontName: "Xenon",
        // url: proxyPath + "/tepublic/monaspace/monaspace-v1.000/fonts/webfonts/MonaspaceXenon-Regular.woff"
        url: proxyPath + "/tepublic/monaspace/monaspace-v1.000/fonts/otf/MonaspaceXenon-Regular.otf"
    },
    // "Monospace": {
    //     fontHeightPre: 38,
    //     fontWidthPre: 18,
    //     fontSize: 30,
    //     fontName: "monospace",
    // },
    // "Droid Sans Mono": {
    //     fontHeightPre: 38,
    //     fontWidthPre: 18,
    //     fontSize: 30,
    //     fontName: "Droid Sans Mono",
    // },
    // "InputMono": {
    //     // fontHeightPre: 38,
    //     fontHeightPre: 40,
    //     fontWidthPre: 18.5,
    //     fontSize: 30,
    //     fontName: "InputMono",
    //     url: proxyPath + "/tepublic/input_mono/input_mono.ttf"
    // },
    "SaxMono": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "SaxMono",
        url: proxyPath + "/tepublic/sax_mono/saxmono.ttf"
    },
    "Dossier": {
        fontHeightPre: 38,
        fontWidthPre: 22,
        fontSize: 30,
        fontName: "Dossier",
        url: "https://tosche.net/assets/fonts/Dossier-Regular.woff2"
    },
    "JetBrainsMono": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "JetBrainsMono",
        url: "https://fonts.gstatic.com/s/jetbrainsmono/v13/tDbY2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKxTOlOVk6WThg.woff2"
    },
    "GoogleSansCode": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "GoogleSansCode",
        url: "https://fonts.gstatic.com/s/googlesanscode/v11/pxiSyogzv91QhV44Z_GQBHsGf5PuckJMXr41HfVaiXFhgjF58LS-h3BytSU.woff2"
    },
    "Libertinus": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "Libertinus",
        url: "https://fonts.gstatic.com/s/libertinusmono/v1/_gPg1RnxrjY_TDm97ApTqwneJJFjpxt2QxCG_g.woff2"
    },
    "KelmscottMono": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "KelmscottMono",
        url: proxyPath + "/tepublic/KelmscottMono.otf"
    },
    "Fixedsys": {
        fontHeightPre: 32,
        fontWidthPre: 15,
        fontSize: 30,
        fontName: "Fixedsys",
        url: proxyPath + "/tepublic/FSEX302.ttf"
    },
    "InputMono": {
        fontHeightPre: 38,
        fontWidthPre: 18.5,
        fontSize: 30,
        fontName: "InputMono",
        url: proxyPath + "/tepublic/input_mono/input_mono.ttf"
    },
    "InputMonoX": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "InputMonoX",
        url: proxyPath + "/tepublic/input_mono/input_mono.ttf"
    },
    // "IosevkaExtended": {
    //     fontHeightPre: 38,
    //     fontWidthPre: 18,
    //     fontSize: 30,
    //     fontName: "IosevkaExtended",
    //     url: proxyPath + "/tepublic/iosevka-fixed-extended.ttf"
    // },
    "Courier": {
        fontHeightPre: 38,
        // fontWidthPre: 18,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "Courier",
    },
    "CourierThin": {
        fontHeightPre: 38,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "Courier",
    },
    "Courier New": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "Courier New",
    },
    "Menlo": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "Menlo",
    },
    "AmericanTypewriter": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "AmericanTypewriter",
    },
    "GillSans": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "GillSans",
    },
    "SFMono": {
        // I think this actually only works because we default to ui-monospace
        // SFMono seems to not be known
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "ui-monospace",
        // fontName: "SFMono",
    },
    "SFMonoThin": {
        // I think this actually only works because we default to ui-monospace
        // SFMono seems to not be known
        fontHeightPre: 38,
        fontWidthPre: 15,
        fontSize: 30,
        fontName: "SFMono",
    },
    "SourceCodePro": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "SourceCodePro",
        // url: "https://fonts.gstatic.com/s/sourcecodepro/v14/HI_QiYsKILxRpg3hIP6sJ7fM7PqlONvUlMIFxGC8.woff2"
        url: "https://fonts.gstatic.com/s/sourcecodepro/v14/HI_SiYsKILxRpg3hIP6sJ7fM7PqlPevWnsUnxg.woff2"
    },
    "RedditMono": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "RedditMono",
        url: "https://fonts.gstatic.com/s/redditmono/v3/oPWL_kRmmu4oQ88oo13o4-rLRjtdRHSW.woff2"
    },
    "GeistMono": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "GeistMono",
        url: "https://fonts.gstatic.com/s/geistmono/v1/or3nQ6H-1_WfwkMZI_qYFrcdmhHkjko.woff2"
    },
    "InputMonoLucida": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "InputMonoLucida",
        url: proxyPath + "/tepublic/input_mono/input_mono_lucida.ttf"
    },
    "VictorMono": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "VictorMono",
        url: proxyPath + "/tepublic/victor_mono/TTF/VictorMono-Regular.ttf"
    },
    "VictorMonoMedium": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "VictorMonoMedium",
        url: proxyPath + "/tepublic/victor_mono/TTF/VictorMono-Medium.ttf"
    },
    "VictorMonoSemiBold": {
        fontHeightPre: 38,
        fontWidthPre: 18,
        fontSize: 30,
        fontName: "VictorMonoSemiBold",
        url: proxyPath + "/tepublic/victor_mono/TTF/VictorMono-SemiBold.ttf"
    },
   "robotomono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "robotomono",
      "url": "https://fonts.gstatic.com/s/robotomono/v23/L0xuDF4xlVMF-BfR8bXMIhJHg45mwgGEFl0_3vqPQw.ttf"
   },
    "NanumGothicCoding": {
        fontHeightPre: 38,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "NanumGothicCoding",
        url: "https://fonts.gstatic.com/s/nanumgothiccoding/v14/8QIVdjzHisX_8vv59_xMxtPFW4IXROwsy6ExUM1WtMRe4NStuSM4eXtk7e0M06IfTaI.119.woff2"
    },
    "IosevkaLucida": {
        fontHeightPre: 38,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaLucida",
        // TODO: fix url/path etc
        // url: "http://tel.drewles.com:8000/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf"
        //url: "http://192.168.0.21:8000/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf"
        url: proxyPath + "/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf"
    },
    "IosevkaLucidaMedium": {
        fontHeightPre: 38,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaLucidaMedium",
        url: proxyPath + "/tepublic/iosevka_lucida/iosevka-fixed-ss13-medium.ttf"
    },
    "IosevkaLucidaSemiBold": {
        fontHeightPre: 38,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaLucidaSemiBold",
        url: proxyPath + "/tepublic/iosevka_lucida/iosevka-fixed-ss13-semibold.ttf"
    },
    "IosevkaLucidaThin": {
        fontHeightPre: 38,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaLucidaThin",
        url: proxyPath + "/tepublic/iosevka_lucida/iosevka-fixed-ss13-thin.ttf"
    },
    "IosevkaThin": {
        fontHeightPre: 38,
        // fontWidthPre: 13.5,
        fontWidthPre: 14,
        fontSize: 30,
        fontName: "IosevkaThin",
        url: "http://192.168.0.21:8000/tepublic/iosevka_lucida/iosevka-fixed-ss13-regular.ttf"
    },
    "Iosevka": {
        fontHeightPre: 38,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "Iosevka",
        url: "http://tel.drewles.com:8000/tepublic/iosevka/iosevka-fixed-regular.ttf"
    },
    "IosevkaSlab": {
        fontHeightPre: 38,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaSlab",
        url: "http://tel.drewles.com:8000/tepublic/iosevka_slab/iosevka-fixed-slab-regular.ttf"
    },

    "Inconsolata": {
        fontHeightPre: 38,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "Inconsolata",
        url: "https://fonts.gstatic.com/s/inconsolata/v21/QlddNThLqRwH-OJ1UHjlKENVzlm-WkL3GZQmAwPyya15IDhunA.woff2"
    },
    // https://usefulangle.com/post/74/javascript-dynamic-font-loading
    "InconsolataThin": {
        fontHeightPre: 38,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "InconsolataThin",
        descriptors: {
            // because inconsolata has this special property
            // feature not working?
            stretch: "70%",
        },
        url: "https://fonts.gstatic.com/s/inconsolata/v21/QlddNThLqRwH-OJ1UHjlKENVzlm-WkL3GZQmAwPyya15IDhunA.woff2"
    },
    "XanhMono": {
        fontHeightPre: 38,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "XanhMono",
        url: "https://fonts.gstatic.com/s/xanhmono/v4/R70YjykVmvKCep-vWhSonwqRfTHxTw.woff2"
    },
    "Fake": {
        fontHeightPre: 38,
        fontWidthPre: 16,
        fontSize: 30,
        fontName: "IosevkaLucida",
        // TODO: fix url/path etc
        url: "http://192.168.0.21:8000/tepublic/notreal.ttf"
    },
}

var extraFonts = {
   "anonymouspro": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "anonymouspro",
      "url": "https://fonts.gstatic.com/s/anonymouspro/v21/rP2Bp2a15UIB7Un-bOeISG3pLlw.ttf"
   },
   "azeretmono": {
      "fontHeightPre": 38,
      "fontWidthPre": 20,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "azeretmono",
      "url": "https://fonts.gstatic.com/s/azeretmono/v17/3XF5ErsiyJsY9O_Gepph-FvtTQgMQUdNekSfnPVh0g.ttf"
   },
   "b612mono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "b612mono",
      "url": "https://fonts.gstatic.com/s/b612mono/v14/kmK_Zq85QVWbN1eW6lJl1w.ttf"
   },
   "chivomono": {
      "fontHeightPre": 38,
      // "fontHeightPre": 34,
      // "fontWidthPre": 17,
      "fontWidthPre": 18,
      // "fontWidthPre": 18.5,
      // "fontWidthPre": 19,
      // "fontWidthPre": 22,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "chivomono",
      "url": "https://fonts.gstatic.com/s/chivomono/v9/mFThWbgRxKvF_Z5eQMO9qRMrJJrnKNtC3D7hr6fV.ttf"
   },
   "chivomonolight": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      "fontSize": 30,
      "fontName": "chivomonolight",
      "url": "https://fonts.gstatic.com/s/chivomono/v9/mFThWbgRxKvF_Z5eQMO9qRMrJJrnKNtC3D6_r5fSIJlp0Gl5.woff2"
   },
   "courierprime": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "courierprime",
      "url": "https://fonts.gstatic.com/s/courierprime/v9/u-450q2lgwslOqpF_6gQ8kELWwY.ttf"
   },
   "cousine": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "cousine",
      "url": "https://fonts.gstatic.com/s/cousine/v27/d6lIkaiiRdih4SpPzSM.ttf"
   },
   "cutivemono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "cutivemono",
      "url": "https://fonts.gstatic.com/s/cutivemono/v20/m8JWjfRfY7WVjVi2E-K9H5RF.ttf"
   },
   "dmmono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "dmmono",
      "url": "https://fonts.gstatic.com/s/dmmono/v14/aFTU7PB1QTsUX8KYhh0.ttf"
   },
   "firacode": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "firacode",
      "url": "https://fonts.gstatic.com/s/firacode/v22/uU9eCBsR6Z2vfE9aq3bL0fxyUs4tcw4W_D1sFVc.ttf"
   },
   "firamono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "firamono",
      "url": "https://fonts.gstatic.com/s/firamono/v14/N0bX2SlFPv1weGeLZDtQIQ.ttf"
   },
   "fragmentmono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "fragmentmono",
      "url": "https://fonts.gstatic.com/s/fragmentmono/v4/4iCr6K5wfMRRjxp0DA6-2CLnN4Q.ttf"
   },
   "ibmplexmono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "ibmplexmono",
      "url": "https://fonts.gstatic.com/s/ibmplexmono/v19/-F63fjptAgt5VM-kVkqdyU8n5ig.ttf"
   },
   "inconsolata": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "inconsolata",
      "url": "https://fonts.gstatic.com/s/inconsolata/v32/QldgNThLqRwH-OJ1UHjlKENVzkWGVkL3GZQmAwLYxYWI2qfdm7Lpp4U8aRo.ttf"
   },
   "jetbrainsmono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "jetbrainsmono",
      "url": "https://fonts.gstatic.com/s/jetbrainsmono/v18/tDbY2o-flEEny0FZhsfKu5WU4zr3E_BX0PnT8RD8yKxjPQ.ttf"
   },
   "mplus1code": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "mplus1code",
      "url": "https://fonts.gstatic.com/s/mplus1code/v12/ypvMbXOOx2xFpzmYJS3N2_J2hBN6RZ5oIp8m_7iN0HHp.ttf"
   },
   "martianmono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "martianmono",
      "url": "https://fonts.gstatic.com/s/martianmono/v3/2V08KIcADoYhV6w87xrTKjs4CYElh_VS9YA4TlTnQzaVMIE6j15dYY1qu86W.ttf"
   },
   "nanumgothiccoding": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "nanumgothiccoding",
      "url": "https://fonts.gstatic.com/s/nanumgothiccoding/v21/8QIVdjzHisX_8vv59_xMxtPFW4IXROwsy6Q.ttf"
   },
   "notosansmono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "notosansmono",
      "url": "https://fonts.gstatic.com/s/notosansmono/v30/BngrUXNETWXI6LwhGYvaxZikqZqK6fBq6kPvUce2oAZcdthSBUsYck4-_FNJ49o.ttf"
   },
   "overpassmono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "overpassmono",
      "url": "https://fonts.gstatic.com/s/overpassmono/v16/_Xm5-H86tzKDdAPa-KPQZ-AC_COcRycquHlL6EXUokzz.ttf"
   },
   "oxygenmono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "oxygenmono",
      "url": "https://fonts.gstatic.com/s/oxygenmono/v14/h0GsssGg9FxgDgCjLeAd7ijf.ttf"
   },
   "ptmono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "ptmono",
      "url": "https://fonts.gstatic.com/s/ptmono/v13/9oRONYoBnWILk-9ArCg.ttf"
   },
   "redhatmono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "redhatmono",
      "url": "https://fonts.gstatic.com/s/redhatmono/v11/jVyY7nDnA2uf2zVvFAhhzEs-VMSjJpBTfgjwQV3I-7E.ttf"
   },
   "sharetechmono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "sharetechmono",
      "url": "https://fonts.gstatic.com/s/sharetechmono/v15/J7aHnp1uDWRBEqV98dVQztYldFc7pA.ttf"
   },
   "sometypemono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "sometypemono",
      "url": "https://fonts.gstatic.com/s/sometypemono/v1/70lGu745KGk_R3uxyq0WrROhAJiJsJ_eTWllpTAMGE9a.ttf"
   },
   "sono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "sono",
      "url": "https://fonts.gstatic.com/s/sono/v6/aFT97PNiY3U2Cqf_aYEN64CYaK18YWJEsV6u-QLiOsxVtkWdEg.ttf"
   },
   "sourcecodepro": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "sourcecodepro",
      "url": "https://fonts.gstatic.com/s/sourcecodepro/v23/HI_diYsKILxRpg3hIP6sJ7fM7PqPMcMnZFqUwX28DMyQhM4.ttf"
   },
   "spacemono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "spacemono",
      "url": "https://fonts.gstatic.com/s/spacemono/v13/i7dPIFZifjKcF5UAWdDRUEY.ttf"
   },
   "splinesansmono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "splinesansmono",
      "url": "https://fonts.gstatic.com/s/splinesansmono/v10/R70MjzAei_CDNLfgZxrW6wrZOF2WdZ6xabUGSVtNuGBiMrtV.ttf"
   },
   "ubuntumono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "ubuntumono",
      "url": "https://fonts.gstatic.com/s/ubuntumono/v17/KFOjCneDtsqEr0keqCMhbBc9.ttf"
   },
   "victormono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "victormono",
      "url": "https://fonts.gstatic.com/s/victormono/v3/Yq6Q-LGQWyfv-LGy7lEO0_ZdtxUGS7ZG.woff2"
   },
   "wellfleet": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "wellfleet",
      "url": "https://fonts.gstatic.com/s/wellfleet/v22/nuF7D_LfQJb3VYgX6eyT4w.ttf"
   },
   "AtkinsonMono": {
      "fontHeightPre": 38,
      "fontWidthPre": 18,
      // "fontOffsetYPre": 3,
      "fontSize": 30,
      "fontName": "AtkinsonMono",
      "url": "https://fonts.gstatic.com/s/atkinsonhyperlegiblemono/v4/tss4AoFBci4C4gvhPXrt3wjT1MqSzhA4t7IIcncBiwKthFyDHi0j.woff2"
   }
}
Object.assign(fonts, extraFonts)



// this gets changes later down.
// Just need to set some variables I guess
currentFont = fonts["Courier"]
setFontVars()

// currentFont = fonts["SFMono"]
// https://medium.com/@caulfieldOwen/programming-fonts-a-visual-guide-567fc210d2c6
// https://vfoley.xyz/lesser-known-coding-fonts/
// https://www.programmingfonts.org/#iosevka

var showFilesFlatFirst = true
var bluetoothKeyboard = false
var floatingKeyboard = false
var fauxMono = false
var fraktur = false
var syntaxHighlight = false
var caseSensitiveSearch = false
// not wired up yet 
var showGoErrors = false

var lastFile = fx
// not using indexes so we can move files around without worrying about the indexes
// It means we'll have to use files.indexOf in various places
    // var currentFileIndex = 0
    // var lastFileIndex = 0

var reorderFiles = false

var lockX = false
var fontColor = "white"
var theBackgroundColor = "black"
var lightFontColor = "rgba(255, 255, 255, 0.5)"
var veryLightFontColor = "rgba(255, 255, 255, 0.1)"
var isDark = true
var workspaceName = ""
var cursorX=0
var cursorY=0
// 4 chars for line number and 1 for space
// var marginLeft = 6
// Note that the width and height need to match
// the width and height of the canvas tag attribute.

var canvasWidth
var canvasHeightFull
var canvasHeightKeyboard
var navTouchSize
var selectTouchSize = 30
var selectAreaRatio = .1
var selectedRegion = {} // really used for local handling, see fx.selectedRegions

function makeTouchRatios(layout) {
    var ratios = []
    layout = layout.trim().replaceAll(" ", "")
    var curLetter = ""
    for (var i=0; i<layout.length; i++) {
        var letter = layout[i]
        if (curLetter != letter) {
            if (curLetter != "") {
                ratios.push(i/layout.length)
            }
            curLetter = letter
        }
    }
    ratios.push(1)
    return ratios
}
// var layout = "aaa s bbb cc dddd ee fff s ggg"
// var layout = "aa ss bbbb cc ddddd ee ffff ss gg"
// var layout = "aa ss bb cc dddd ee ff ss gg"
// var layout = "aa s bbb cc dddd ee fff s gg"
// var layout = "aa s bb cc dddd ee ff s gg"
// var layout = "aa ss bb cc ddddd ee ff ss gg"
// var layout = "aa s bb cc dddddd ee ff s gg"
var layout = "aa ss bb cc dddddd ee ff ss gg"

var touchRatios = makeTouchRatios(layout)
// setTimeout(function () {
//     log(touchRatios)
// }, 1000)



// var verticalTouchSize = 120
// var verticalTouchSize = 100
// var verticalTouchSize = 80
// var verticalTouchSize = 100
var verticalTouchSize = 80
var originalVerticalTouchSize = verticalTouchSize
var device = "iphone12mini"
var canvasHeightShell
var canvasHeightTerminal
var canvasHeightIframe
var canvasHeightKeyboardTerminal
var maxLines
var maxCols
var canvasHeight
var isMoving = false

var clientId = Math.floor((Math.random() * 100000))

// alert(innerWidth + ", " + innerHeight)
// alert(screen.width + ", " + screen.height)
function doSizing() {
    canvasWidth=innerWidth * 3
    // TODO: make these configurable in UI
    canvasHeightFull=1710 // - (36*3*1) // extra button row now
    // I turned off "Predictive" to get more vertical space
    // canvasHeightKeyboard=1200 
    canvasHeightKeyboard=1060 
    // navTouchSize = 40
    navTouchSize = 50
    // navTouchSize = 30
    device = "iphone12mini"

    // landscape mode
    if (innerWidth > innerHeight) {
        canvasHeightFull = 575  
        canvasHeightKeyboard = 400 
        navTouchSize = 60
    }
    
    // iPhone 16 plus
    if (screen.width == 430 && screen.height == 932) {
        device = "iphone16plus"
        var oneRow = 36*3
        canvasHeightFull=2200
        canvasHeightKeyboard=1365
        navTouchSize = 35
        if (innerWidth > innerHeight) {
            canvasHeightFull = 900
            canvasHeightKeyboard = 300
            navTouchSize = 100
        }
    }
    
    if (screen.width == 768 && screen.height == 1024) {
        device = "someipad"
        var oneRow = 36*3
        // canvasHeightFull=1820 //+ (oneRow*2)
        // canvasHeightFull=1820 + (oneRow*1)
        canvasHeightFull=2600 
        canvasHeightKeyboard=2000
        navTouchSize = 35
        // if (innerWidth > innerHeight) {
        //     canvasHeightFull = 900
        //     canvasHeightKeyboard = 300
        //     navTouchSize = 100
        // }
    }
    // This condition for the 2022 iPhone 14 Pro
    if (screen.width == 393 && screen.height == 852) {
        device = "iphone14pro"
        var oneRow = 36*3
        // canvasHeightFull=1820 //+ (oneRow*2)
        // canvasHeightFull=1820 + (oneRow*1)
        canvasHeightFull=1820 + (oneRow*1)

        // canvasHeightKeyboard=1154
        // iOS 26 gives less space with keyboard so I shrunk it
        canvasHeightKeyboard=1116

        // navTouchSize = 50
        // navTouchSize = 40
        // navTouchSize = 30
        navTouchSize = 35
        if (innerWidth > innerHeight) {
            canvasHeightFull = 900
            canvasHeightKeyboard = 300
            navTouchSize = 100
        }
    }

    // This condition for the 2021 iPad mini
    if (screen.width == 744 && screen.height == 1133) {
        device = "ipad6"
        canvasHeightFull = 2720 
        canvasHeightKeyboard = 2200 
        navTouchSize = 60
        // alert(innerWidth + ", " + innerHeight)
        // warning if the page is zoomed the numbers will be off
        // if ipad is in landscape mode at 100% zoom, saved to homescreen
        // innerWidth is 1133
        // innerHeight is 720

        // if ipad is in landscape mode at 100% zoom, not saved to homescreen, with compact browsing mode
        // innerWidth is 1133
        // innerHeight is 665

        // Simple detection for landscape
        if (innerWidth > innerHeight) {
            canvasHeightFull = 1600 + (36*3*1)
            canvasHeightKeyboard = 800
            navTouchSize = 100
        }
    }
    c.style.width = innerWidth + "px"
    c.width = canvasWidth
    c.height = canvasHeightFull
    // var canvasHeightKeyboardTerminal=canvasHeightKeyboard-(36*3*1)
    // TODO: clean this special case up. changed so files always show. bit now it needs 2 rows
    // ok now back to 1 row
    // canvasHeightKeyboardTerminal=canvasHeightKeyboard-(36*3*1)
    // canvasHeightKeyboardTerminal=canvasHeightKeyboard-(36*3*2)
    
    // back to 0 rows
    canvasHeightKeyboardTerminal=canvasHeightKeyboard-(36*3*0)

    // 34 button height plus 1px*2 margin
    // 2 rows of new buttons for shell
    // var canvasHeightShell = canvasHeightFull - ((36*3) * 2)
    // var canvasHeightTerminal = canvasHeightFull - ((36*3) * 1)
    // var canvasHeightIframe = canvasHeightFull + ((36*3) * 2)

    // experiment with keeping height
    canvasHeightShell = canvasHeightFull
    canvasHeightTerminal = canvasHeightFull
    canvasHeightIframe = canvasHeightFull

    setCanvasHeight(canvasHeightFull)
    setCanvasWidth(canvasWidth)
}
doSizing()

function deleteBelow() {
    if (fx.fileMode == "terminal") {
        clearLog()
    } else {
        setLines(fx.lines.slice(0, fx.cursorLineIndex))
    }
    docChanged()
    render()
}

window.onorientationchange = function(event) {
    doSizing()
    render()
    // seems that we need to double check in a few milliseconds
    setTimeout(function(){
        doSizing()
        render()
    }, 500)
};



var touchScaleY = 3 // was 3 for a while, then 2 for a while, now 3 again
var touchScaleX = 3 // was 3 for a while, then 2 for a while, now 3 again
var touchScaleY = 2
var touchScaleX = 2
// #snappingCursor 3
// var touchScaleX = 1 // 1 now because of snapping

var lastAction = "move" // move or type
var lastDirection = "vertical" // vertical or horizontal
var lastSearchDirForSameTerm = "" // up or down or ""
var lastSearchMatchLength = 0
var hasMovedSinceNewLine = false
var inEdit = false
var copyBuffer = []
var copyBuffer2 = []
var cutBuffer = []
var selectMode = "line"
var selectAction
var longPressAction
var cursorType = "move"
// cursorType can be
// * move
// * select

var theStatus = {}

// note: fileMode can be
// * file
// * shell (like a terminal lite)
// * fileList
// * directory
// * terminal
// if last keyDown is a backspace
var wasWasDelete = false
var wasDelete = false
var moveHomeEndTimeout
var moveHomeEndTimeoutMillis = 150
var moveHomeEndDirection
var cleanUpFilesTimeout
var selectTimeout
// var selectTimeoutMillis = 150
// selectTimeoutMillis could also be called longPressTimeoutMillis
var selectTimeoutMillis = 120
var selectTimeoutMillisMove = 350
var expandSelectTimeout
// var expandSelectTimeoutMillis = 200
// this low ofntimeout (120) makes it harder to select by holding then dragging
// but you can get that same thing by dragging from the leftish
var expandSelectTimeoutMillis = 120
var moveListenerCount = 0
var endListenerCount = 0
var startListenerCount = 0
var autoSave = false
var lastPageYOffset = 0
var originalCanvasHeightFull = canvasHeightFull
var scrollTimeout
var useRegexSearch = true
// TODO: as you add or delete lines
// go thru these locations and update them
// selectFont("IosevkaLucida")
// selectFont("Courier")

// Using menlo while in poor intetnet situation to save space
selectFont("Menlo")

var hasDoneOverflowYAction = false
var alternateTap = true // the false doesn't even fully work anymore



function copyOneTimeLink() {
    var fullPath
    if (fx.fileMode == "directory") {
        fullPath = getSelectedFilePathInDirectory()
    } else if (fx.fileMode == "file") {
        fullPath = fx.fullPath
    } else if (fx.fileMode == "fileList") {
        var file = treeFilesShadow[fx.cursorLineIndex]
        fullPath = file.fullPath
    }
    
    fetch(proxyPath + "/makeOneTimeLink?fullpath="+encodeURIComponent(fullPath), {
        cache: "no-cache",
        method: "POST"
    }).then(r => r.text()).then(r => {
        var link = location.protocol + r
        copyString(link)
        // osCopyText()
        alert("created")
    })
}


// it was the tap to cut flow. we can maybe bring that back even with alternate tap
function osCopyText() {
    copy()
    navigator.clipboard.writeText(copyBuffer.join("\n")).then(function() {
    }, function() {
        alert("not copied")
    })
}
function osPasteText() {
    navigator.clipboard.readText().then(function(text) {
        copyBuffer = text.split("\n")
    }, function(e) {
        alert("not copied: " + e)
    })
}

function doRefresh() {
    saveWorkspace().then(function() {
        // location.reload()
        var fileIndex = files.indexOf(fx)
        var newURL = addParamToCurrentURL("fileIndex", fileIndex)
        location.href = newURL
    })
}

function getAbsoluteURL(baseURL, newURL) {
    baseURLParsed = new URL(baseURL)
    // TODO add ? and #
    if (newURL.startsWith("https://") || newURL.startsWith("http://")) {
        return newURL
    } else if (newURL.startsWith("//")) {
        return baseURLParsed.protocol + newURL
    } else if (newURL.startsWith("/")) {
        return baseURLParsed.origin + newURL
    } else {
        var pathPart = baseURLParsed.pathname.split("/").slice(0, -1).join("/")
        var finalURL = baseURLParsed.origin + pathPart + "/" + newURL
        return finalURL
    }
}
var iframeScale = .5
function addIframe(url, id, name, cwd) {
    // var f = makeFile(url, 0, "")
    var f = makeFile(url, 0, "")
    f.fileMode = "iframe"

    if (id) {
        f.ID = id
    }
    if (cwd) {
        f.shellCWD = cwd
    }
    if (name) {
        f.name = name
    }
    f.iframeCursorX = 0
    f.iframeCursorY = 0
    var iframeWrapper = document.createElement("div")
    var iframe = document.createElement("iframe")
    iframe.src = url
    // iframe.sandbox = "allow-same-origin allow-scripts allow-popups allow-forms"
    // iframe.setAttribute("sandbox", "allow-same-origin allow-scripts allow-popups allow-forms")
    iframe.currentElement = document.createElement("div")
    iframe.onload = function() {
        iframe.contentWindow.document.body.style.transform = "scale("+iframeScale+")"
        iframe.contentWindow.document.body.style.transformOrigin = "top left"


        // iframe.style.width = (1200 * .75) + "px"
        // iframe.style.height = (1000 * .75)+"px"
        // iframe.style.transform = "scale(.75)"
        // iframe.style.transformOrigin = "top left"
        // iframe.style.width = (1200 / .75) + "px"
        // iframe.style.height = (1000 / .75)+"px"


        f.fullPath = iframe.src
        saveWorkspace()
        var openFunction = function(url) {
            // TODO add ? and #
            // if (url.startsWith("https://") || url.startsWith("http://")) {
            //     parent.addIframe(url)
            // } else if (url.startsWith("//")) {
            //     parent.addIframe(iframe.contentWindow.location.protocol + url)
            // } else if (url.startsWith("/")) {
            //     parent.addIframe(iframe.contentWindow.location.origin + url)
            // } else {
            //     var pathPart = iframe.contentWindow.location.pathname.split("/").slice(0, -1).join("/")
            //     var finalURL = iframe.contentWindow.location.origin + pathPart + "/" + url
            //     parent.addIframe(finalURL)
            // }
            var finalURL = getAbsoluteURL(iframe.contentWindow.location, url)
            parent.addIframe(finalURL)
        }

        iframe.contentWindow.open = openFunction
        var handleClick = function(e) {
            e.preventDefault()
            openFunction(e.currentTarget.getAttribute("data-te-href"))
            return false
        }

        var oldSubmit = iframe.contentWindow.HTMLFormElement.prototype.submit
        iframe.contentWindow.HTMLFormElement.prototype.submit = function() {
            var newIframe = addIframe("about:blank")
            this.removeAttribute("target")
            this.action = getAbsoluteURL(iframe.contentWindow.location, this.action)
            newIframe.iframe.contentWindow.document.body.appendChild(this)
            oldSubmit.call(this)
            this.teModified = true
            return false
        }


        // hacky
        var replaceLinks = function() {
            var aTags = iframe.contentWindow.document.querySelectorAll("a")
            for (let i=0; i<aTags.length; i++) {
                let aTag = aTags[i]
                if (aTag.hasAttribute("target") && !aTag.hasAttribute("onclick") && !aTag.hasAttribute("data-te-href")) { // TODO: better handling
                    let href = aTag.getAttribute("href")
                    aTag.onclick = handleClick
                    aTag.removeAttribute("href")
                    aTag.setAttribute("data-te-href", href)
                    aTag.style.border = "1px solid hotpink"
                }
            }
            // var formTags = iframe.contentWindow.document.querySelectorAll("form")
            // for (let i=0; i<formTags.length; i++) {
            //     let formTag = formTags[i]
            //     if (formTag.hasAttribute("target") && !formTag.hasAttribute("onsubmit")) { // TODO: better handling
            //         let action = formTag.getAttribute("action")
            //         formTag.onsubmit = handleSubmit
            //         formTag.removeAttribute("target")
            //         formTag.style.border = "1px solid lime"
            //     }
            // }
        }
        replaceLinks()

        const config = { attributes: false, childList: true, subtree: true };
        const callback = function(mutationsList, observer) {
            // TODO: only change the modified ones, also you may need to look at attribute changes
            replaceLinks()
        };
        const observer = new MutationObserver(callback);
        observer.observe(iframe.contentWindow.document.body, config);


    }
    iframe.onerror = function() {
        window.open(iframe.src)
    }
    iframeWrapper.style.position = "absolute"
    // iframeWrapper.style.width = (innerWidth - (navTouchSize*2)) + "px"
    // iframeWrapper.style.left = navTouchSize + "px"

    iframeWrapper.style.width = (innerWidth) + "px"

    iframeWrapper.style.height = (canvasHeightIframe*.7/3) + "px"
    iframeWrapper.style.display = "none"
    iframeWrapper.style.overflow = "scroll"
    iframe.style.border = "none"
    iframe.style.backgroundColor = "white"



    iframe.style.width = "1400px"
    iframe.style.height = "1000px"
    iframeWrapper.appendChild(iframe)
    iframeContainer.appendChild(iframeWrapper)
    f.iframe = iframe
    f.iframeWrapper = iframeWrapper
    addFileToList(f)
    setCurrentFile(f)

    // TODO: in future can we handle the id creation on the client side for less overhead?
    if (!id) {
        fetch(proxyPath + "/myaddfile?fileType=iframe&fullPath="+encodeURIComponent(url), {
            cache: "no-cache"
        }).then(r => {
            if (r.headers.get("X-ID")) {
                f.ID = r.headers.get("X-ID") - 0
            }
        }).catch(e => {
            alert("Error adding iframe " + e)
        })

    }
    return f
}

function showDiff() {
    var start = Date.now()
    var contents = simpleDiffOld3(fx.undo.lastSavedLines, fx.lines, false).join("\n")
    var f3 = makeFile("__diffOld3", 0, contents)
    f3.fileMode = "file"
    f3.cursorLineIndex = 0
    addFileToList(f3)
    setCurrentFile(f3)

    // For now we don't load in the third party diff algorithm
    // var oldContents = fx.undo.lastSavedLines.join("\n")
    // var newContents = fx.lines.join("\n")
    // var start = Date.now()
    // var contents = Diff.createPatch("foo", oldContents, newContents, "", "", {context:0})
    // var f4 = makeFile("__diffMyers", 0, contents)
    // f4.fileMode = "file"
    // f4.cursorLineIndex = 0
    // addFileToList(f4)
    // setCurrentFile(f4)

    updateCursorXY()
    ensureCursorInScreen()
}

// heuristical
function simpleDiffOld3(aLines, bLines, showSame) {
    var aLastMatched = -1
    var bLastMatched = -1
    var ai = -1
    var bi = -1

    // TODO: you can handle a bit better when it gets to the end for one?
    // NOTE: this is my experimenting with diff. likely not fastest or most
    // efficient. For example I don't get largest common substring.
    // max 1000000 line diff
    // this has large issues, see scratch5
    // one thing we can do to improve is another pass where we optimize this output.
    // or just implement the Myers diff algorithm and compare speed
    var ret = []
    lastMatched = true
    outerLoop:
    for (var i=0; i<1000000; i++) {
        ai += 1
        bi += 1
        if (ai >= aLines.length && bi >= bLines.length) {
            break
        }
        var aLine = aLines[ai]
        var aLineString = (aLine || "").toString()
        for (var b=bLastMatched+1; b<=bi; b++) {
            var bLine = bLines[b]
            var bLineString = (bLine || "").toString()
            // if (aLine != bLine) {
            // undefineds are from not even line count
            // toString is needed because we sometimes deal with String objects (capital s)
            if ((typeof aLine == "undefined") || (typeof bLine == "undefined") || aLineString != bLineString) {
                continue
            }
            if (!lastMatched) {
               // use a hash for this?
               var trimmed = (aLine || "").trim()
               if (trimmed == "") {
                   continue
               }
               if (trimmed == "}") {
                   continue
               }
               if (trimmed.startsWith == "/>") {
                   continue
               }
               if (trimmed == "break") {
                   continue
               }
               if (trimmed == "continue") {
                   continue
               }
               if (trimmed == "return") {
                   continue
               }
            }
            lastMatched = true
            if (!showSame && (aLastMatched+1<ai || bLastMatched+1<b)) {
                ret.push("@@ -" + (aLastMatched+2) + " @@")
            }
            for (var a=aLastMatched+1; a<ai; a++) {
                ret.push("-" + aLines[a])
            }
            for (var b2=bLastMatched+1; b2<b; b2++) {
                ret.push("+" + bLines[b2])
            }
            aLastMatched = ai
            bLastMatched = b
            bi = b
            if (showSame) {
                ret.push(" " + aLines[ai])
            }
            continue outerLoop
        }

        var bLine = bLines[bi]
        var bLineString = (bLine || "").toString()
        for (var a=aLastMatched+1; a<=ai-1; a++) {
            var aLine = aLines[a]
            var aLineString = (aLine || "").toString()
            // if (aLine != bLine) {
            if ((typeof aLine == "undefined") || (typeof bLine == "undefined") || aLineString != bLineString) {
                continue
            }
            if (!lastMatched) {
               // use a hash for this?
               var trimmed = (aLine || "").trim()
               if (trimmed == "") {
                   continue
               }
               if (trimmed == "}") {
                   continue
               }
               if (trimmed.startsWith == "/>") {
                   continue
               }
               if (trimmed == "break") {
                   continue
               }
               if (trimmed == "continue") {
                   continue
               }
               if (trimmed == "return") {
                   continue
               }
            }
            lastMatched = true
            if (!showSame && (aLastMatched+1<a || bLastMatched+1<bi)) {
                ret.push("@@ -" + (aLastMatched+2) + " @@")
            }
            for (var a2=aLastMatched+1; a2<a; a2++) {
                ret.push("-" + aLines[a2])
            }
            for (var b=bLastMatched+1; b<bi; b++) {
                ret.push("+" + bLines[b])
            }
            if (showSame) {
                ret.push(" " + bLines[bi])
            }
            aLastMatched = a
            bLastMatched = bi
            ai = a
            continue outerLoop
        }

        lastMatched = false
    }
    if (i == 1000000) {
        alert("likely a bug with diff code")
    }

    // any left over
    if (!showSame && (aLastMatched+1<aLines.length || bLastMatched+1<bLines.length)) {
        ret.push("@@ -" + (aLastMatched+2) + " @@")
    }
    if (aLastMatched + 1 < aLines.length) {
        for (var aR=aLastMatched+1; aR<aLines.length; aR++) {
            ret.push("-" + aLines[aR])
        }
    }
    if (bLastMatched + 1 < bLines.length) {
        for (var bR=bLastMatched+1; bR<bLines.length; bR++) {
            ret.push("+" + bLines[bR])
        }
    }
    return ret
}

function getAtCursor() {
    if (fx.cursorLineIndex >= fx.lines.length) {
        return
    }
    var line = fx.lines[fx.cursorLineIndex]
    var strIndex = u(fx.cursorColIndex)
    for (var i=strIndex; i>=0; i--) {
        // if ((line.charAt(i).trim() == "")) {
        if (line.charCodeAt(i) <= 32) {
            break
        }
    }
    i += 1
    for (var j=strIndex+1; j<line.length; j++) {
        if (line.charCodeAt(j) <= 32) {
            break
        }
    }
    return line.slice(i, j)
}

function openAtCursor() {
    var path = getAtCursor()
    if (fx.fileMode == "shell") {
        var fileName = doTrimPrefix(fx.shellCWD, rootLocation) + "/" + path
    } else if (fx.fileMode == "terminal") {
        // TODO: how do we know what the cwd is?
        // isn't there a way to get the cwd of a running process?
    } else if (path.startsWith("/")) {
        var fileName = path
    } else {
        var parts = fx.fullPath.split("/")
        var basePath = parts.slice(0, -1).join("/")
        var fileName = basePath + "/" + path
    }
    
    // handle output like this
    // ./path/to/dir/somefile.go:20:func TestFoo (t *testing.T) {
    var parts = fileName.split(":")
    if (parts.length > 2) {
        parts = parts.slice(0, 2)
        fileName = parts.join(":")
    }
    addFile(fileName)
}

function urlAtCursor() {
    var url = getAtCursor()
    open(url)
}

function addSpace() {
    if (fx.cursorLineIndex >= fx.lines.length) {
        return
    }
    var line = fx.lines[fx.cursorLineIndex]
    updateLine(-1, line.slice(0, u(fx.cursorColIndex)) + " " + line.slice(u(fx.cursorColIndex)))
    fx.cursorColIndex += 1
    updateCursorXY()
    docChanged()
    render()
}

function backspace() {
    if (fx.cursorLineIndex >= fx.lines.length) {
        return
    }
    var line = fx.lines[fx.cursorLineIndex]
    if (fx.cursorColIndex == 0) {

        return
    }
    // fx.lines[fx.cursorLineIndex] = line.slice(0, u(fx.cursorColIndex) - 1) + line.slice(u(fx.cursorColIndex))
    updateLine(fx.cursorLineIndex, line.slice(0, u(fx.cursorColIndex) - 1) + line.slice(u(fx.cursorColIndex)))
    fx.cursorColIndex = expandTabIndex(line, u(fx.cursorColIndex - 1))
    docChanged()
    updateCursorXY()
    render()
}
function selectFont(fontName) {
    currentFont = fonts[fontName] || fonts["Courier"]
    if (currentFont.url) {
        var font
        if (currentFont.descriptors) {
            font = new FontFace(fontName, "url(" + currentFont.url + ")")
        } else {
            font = new FontFace(fontName, "url(" + currentFont.url + ")", currentFont.descriptors)
        }
        font.load().then(function(loaded){
            document.fonts.add(loaded)
            whenFontReady(fontName)
        }).catch(function(e){
            alert(e)
        })
    } else {
        // assuming we have this font
        whenFontReady(fontName)
    }
}

function whenFontReady(fontName) {
    editorCommandText.style.fontFamily = fontName
    searchText.style.fontFamily = fontName
    theText.style.fontFamily = fontName
    updateFontScale()
}

function updateFontScale() {
    if (!fontScale) {
        fontScale = 1
    }
    setFontVars()

    setCanvasHeightAccordingly()
    setCanvasWidth(canvasWidth)

    render()
}

function setFontVars() {
    fontHeight = currentFont.fontHeightPre * fontScale
    fontWidth = currentFont.fontWidthPre * fontScale
    
    // this makes scaling text more jaggedy
    fontHeight = Math.ceil(fontHeight)
    fontWidth = Math.ceil(fontWidth)
    
    
    fontOffsetY = (currentFont.fontOffsetYPre || 0) * fontScale
    // fontCSS = (currentFont.fontSize * fontScale) + "px '"+currentFont.fontName+"', ui-monospace"
    // fontCSS = (currentFont.fontSize * fontScale) + "px 'Courier', ui-monospace"
    // fontCSS = (currentFont.fontSize * fontScale) + "px ui-monospace"
    // after experimentation, there seems to be a bug in ios 15 where if we use the ui-monospace font
    // which would render SF Mono before, but now
    // causes the page to crash
    // fontCSS =  "100 " +(currentFont.fontSize * fontScale) + "px '"+currentFont.fontName+"', Menlo, monospace"
    fontCSS = (currentFont.fontSize * fontScale) + "px '"+currentFont.fontName+"', Menlo, monospace"
    fontCSSTiny = (currentFont.fontSize * fontScale/2) + "px '"+currentFont.fontName+"', monospace"
    fontCSSEmoji = (currentFont.fontSize * fontScale * .6 * emojiWidth) + "px '"+currentFont.fontName+"', ui-monospace, monospace"

    // fontCSSPunctuation = (currentFont.fontSize * fontScale) + "px Menlo, monospace"
    // fontCSSPunctuation = (currentFont.fontSize * fontScale) + "px 'Courier New', monospace"
    fontCSSPunctuation = (currentFont.fontSize * fontScale) + "px GoogleSansCode, monospace"
    
    // extraYEmoji = (currentFont.fontSize * fontScale * .6) / 2 / emojiWidth
    extraYEmoji = 0
}
// fonts.chivomono.fontWidthPre = 18.5
// fonts.chivomono.fontWidthPre = 18
// log2("hello world this font is cool")
// updateFontScale()


function importPaste() {
    copyBuffer = pasteEl.value.split("\n")
    selectMode = "line"
}

function toggleDarkMode() {
    isDark = !isDark
    renderDarkMode()
}

var lighModeFontColor = "black"
var darkModeFontColor = "rgba(255, 255, 200, 1)"
var lineNumberColor = "brown"
function renderDarkMode() {
    if (!isDark) {
        darkModeButton.innerText = "dark"
        document.body.classList.remove("dark")
        document.body.classList.add("light")
        updateClassForSelector("input", "dark","light")
        updateClassForSelector("textarea", "dark","light")
        fontColor = lighModeFontColor
        lightFontColor = "rgba(0, 0, 0, 0.5)"
        veryLightFontColor = "rgba(0, 0, 0, 0.1)"
        theBackgroundColor = darkModeFontColor
        // lineNumberColor = veryLightFontColor
        render()
        return
    }
    darkModeButton.innerText = "light"
    document.body.classList.remove("light")
    document.body.classList.add("dark")
    updateClassForSelector("input", "light", "dark")
    updateClassForSelector("textarea", "light", "dark")
    // fontColor = "white"
    // fontColor = "rgba(100, 255, 100)"
    // fontColor = "rgba(255, 255, 200)"
    fontColor = darkModeFontColor
    // fontColor = "deeppink"
    // fontColor = "pink"

    lightFontColor = "rgba(255, 255, 255, 0.5)"
    veryLightFontColor = "rgba(255, 255, 255, 0.1)"
    theBackgroundColor = "black"
    // lineNumberColor = veryLightFontColor
    
    render()
}
function updateClassForSelector(selector, remove, add) {
    var inputs = document.querySelectorAll(selector)
    for (var i=0; i<inputs.length; i++) {
        var input = inputs[i]
        input.classList.remove(remove)
        input.classList.add(add)
    }
}
function runEditorCommand(e) {
    e.preventDefault()
    // editorCommandText.style.display = "none"
    var parts = editorCommandText.value.split(" ")
    if (parts.length == 0) {
        return false
    }
    var cmd = parts[0]
    var rest = parts.slice(1).join(" ")

    switch (cmd) {
    case "ccol": // change color
        var fromColor = parts[1]
        var toColor = parts[2]
        for (var i=0; i<files.length; i++) {
            var theFile = files[i]
            if (theFile.color == fromColor) {
                theFile.color = toColor
            }
        }
        renderFileDropdown()
        saveWorkspace()
        break
    case "color":
        while (true) { // my hack to break wherever I want
            if (fx.fileMode == "fileList") {
                if (fx.selectedRegions.length>0) {
                    var r = fx.selectedRegions[0]
                    // we subtract 1 because of the initial "-" at the beginning
                    var fileIndexStart = r.startY - 1
                    var fileIndexStop = r.stopY - 1
                    for (var i=fileIndexStart; i<= fileIndexStop; i++) {
                        files[i].color = rest
                    }
                }
                seeFilesForReal(false)
            }
            break
        }
        fx.color = rest
        // TODO: you could have a custom function that just sets the color
        render()
        renderFileDropdown()
        saveWorkspace()
        break
    case "group":
        while (true) { // my hack to break wherever I want
            if (fx.fileMode == "fileList") {
                if (fx.selectedRegions.length>0) {
                    var r = fx.selectedRegions[0]
                    // we subtract 1 because of the initial "-" at the beginning
                    var fileIndexStart = r.startY - 1
                    var fileIndexStop = r.stopY - 1
                    for (var i=fileIndexStart; i<= fileIndexStop; i++) {
                        files[i].group = rest
                    }
                }
                seeFilesForReal(false)
            }
            break
        }
        fx.group = rest
        render()
        renderFileDropdown()
        saveWorkspace()
        break
    case "name":
        fx.name = rest
        // TODO: could you also call saveName?
        saveWorkspace()
        renderFileDropdown()
        break
    case "so":
        fx.seeOnly = rest
        render()
        break
    case "sox":
        fx.seeOnly = ""
        render()
        break
    // foreground light
    case "fgl":
        lighModeFontColor = rest || "black"
        renderDarkMode()
        break
    // foreground light
    case "fgd":
        darkModeFontColor = rest || "white"
        renderDarkMode()
        break
    // line number color
    case "lnc":
        lineNumberColor = rest || "brown"
        render()
        break
    // background light
    case "bgl":
        var rules = document.styleSheets[0].cssRules
        for (var i=0; i<rules.length; i++) {
            var rule = rules[i]
            if (rule.selectorText == ".light") {
                rule.style.backgroundColor = rest || "#ddf"
            }
        }
        break
    // background dark
    case "bgd":
        var rules = document.styleSheets[0].cssRules
        for (var i=0; i<rules.length; i++) {
            var rule = rules[i]
            if (rule.selectorText == ".dark") {
                rule.style.backgroundColor = rest || '#002'
            }
        }
        break
    case "wname":
        // for now just going by name
        var oldWorkspaceName = workspaceName
        var currentWorkspace = workspacesList.find(function (w) {
            return w.Name == workspaceName
        })
        if (currentWorkspace) {
            currentWorkspace.Name = rest
        }
        workspaceName = rest
        saveWorkspace(oldWorkspaceName)
        renderFileDropdown()
        break
    case "copyurl":
        copyBuffer = [location.href]
        break
    case "reloadall":
        reloadAll()
        break
    case "reload":
        reloadFile()
        break
    case "light":
        toggleDarkMode()
        break
    case "dark":
        toggleDarkMode()
        break
    case "copypath":
        copyString(fx.fullPath + ':' + (fx.cursorLineIndex + 1))
        break
    case "js":
        // see also runScript
        var oldCopyBuffer = copyBuffer
        var f = new Function(code)
        var ret = f()
        ret = ret + ""
        copyBuffer = ret.split("\n")
        paste()
        copyBuffer = oldCopyBuffer
        break
    case "e":
        var resp = eval(rest)
        if (resp != undefined) {
            alert(JSON.stringify(resp, null, "  "))
        }
        break
    case "sort":
        sortSelected()
        break
    case "uniq":
        uniqSelected()
        break
    case "pretty":
        prettyJsonSelected()
        break
    case "wr":
        wordWrapSelected()
        break
    case "lower":
        var _t = getSelectedLines(fx, true)
        var linesToProcess = _t.lines
        if (_t.isWholeFile) {
            break
        }
        let lowered = linesToProcess.map(l => l.toLowerCase())
        pasteLines(lowered, false, false)
        break
    case "sum":
        var _t = getSelectedLines(fx, false)
        var linesToProcess = _t.lines
        // let numbers = linesToProcess.map(n => n.trim() - 0)
        let numbers = linesToProcess.map(n => n.trim().replace(/[^0-9.-]/g, '') - 0)
        let sum = numbers.reduce((acc, curr) => acc + curr, 0);
        cleanLines = numbers.map(x => x + "")
        cleanLines.push("= " + sum)
        pasteLines(cleanLines, false, false)
        break
    case "c":
        var word = getWordAtCursor().word
        if (word != "") {
            // clear it out first
            highlightMatches = highlightMatches.filter(m => m.Regex !== word);
            if (rest != "") {
                highlightMatches.push({
                    Regex: word,
                    // It's really underline color
                    BackgroundColor: rest,
                })
                processHighlightMatches()
                saveWorkspace()
                highlightMatches
            }

        }
        break
    case "upper":
        var _t = getSelectedLines(fx, true)
        var linesToProcess = _t.lines
        if (_t.isWholeFile) {
            break
        }
        let uppered = linesToProcess.map(l => l.toUpperCase())
        pasteLines(uppered, false, false)
        break
    case "sp":
        stripPrefixes([rest])
        break
    case "script":
    case "s":
        // see also scriptLines
        scriptLinesWithOneLineScript(rest)
        break
    case "r":
        scriptLinesWithOneLineScript(editorCommandText.value)
        break
    case "l":
        scriptLinesWithOneLineScript(editorCommandText.value)
        break
    case "h":
        if (fx.selectedRegions.length == 0) {
            break
        }
        var r = fx.selectedRegions[0]
        if (!fx.highlightRanges) {
            // TODO: Figure out why this is
            fx.highlightRanges = []
        }
        fx.highlightRanges.push({
            StartY: r.startY,
            StartX: r.startX,
            StopY: r.stopY,
            StopX: r.stopX,
            BackgroundColor: rest || "deeppink"
        })
        saveWorkspace()
        render()
        break
    case "hx":
        highlightRanges = []
        for (var i=0; i<fx.highlightRanges.length; i++) {
            var r = fx.highlightRanges[i]
            if (fx.cursorLineIndex >= r.StartY && fx.cursorLineIndex <= r.StopY) {
                // skip
            } else {
                highlightRanges.push(r)
            }
        }
        fx.highlightRanges = highlightRanges
        saveWorkspace()
        render()
        break
    // case "h":
    //     // if (!rest && fx.selectedRegions.length) {
    //     //     rest = getSelectedLines(fx, false).lines[0]
    //     // }
    //     if (!rest) {
    //         rest = copyBuffer[0]
    //     }
    //     fx.highlightText = rest;
    //     saveWorkspace()
    //     break
    // case "hx":
    //     fx.highlightText = "";
    //     saveWorkspace()
    //     break
    case "fontscale":
        fontScale = rest - 0
        updateFontScale()
        break
    case "rr":
    case "rerun":
        clearLog()
        // up arrow
        sendTerminal("\x1b[A");
        // return
        sendTerminal("\r");
        break
    case "f":
        // Fuzzy Search
        searchText.value = rest.split(" ").map(function(w) {
            // TODO: you don't need word boundary at the end 
            return "\\b" + (w.split("").join('[\\w]*')) + "[\\w]*\\b"
        // }).join("\\s+") // >
        }).join(".*") //  
        saveSearchHistory()
        
        // var r = fuzzyLineMatchToRegexp(rest)
        // searchText.value = r.string
        findDown()
        render()
        break
    case "g":
        // runChatGPT('gpt-4', {inline: true, extra: "\n\n" + rest})
        runChatGPT('gpt-4o-mini', {inline: true, extra: "\n\n" + rest})
        break
    case "g3":
        runChatGPT('gpt-3.5-turbo', {inline: true, extra: "\n\n" + rest})
        break
    case "pin":
        doPin(true)
        break
    case "unpin":
        doPin(false)
        break
    }
    editorCommandText.blur()
    return false
}
function openEditorCommandText() {
    editorCommandText.style.display = "block"
    editorCommandText.focus()
}
function focusEditorCommandText() {
    window.scrollTo(0, 0)
    editorCommandText.setSelectionRange(0, editorCommandText.value.length)
    editorCommandText.style.display = "block"
    theText.style.display = "none"
    searchText.style.display = "none"
    voiceCommandText.style.display = "none"
    setCanvasHeightAccordingly()
}
function inputEditorCommandText() {
}
function blurEditorCommandText() {
    // handle the case where when you collapse the keyboard on iPad
    // it triggers a blur event, but it's still the activeElement
    if (document.activeElement == editorCommandText) {
        editorCommandText.blur()
        return
    }
    theText.style.display = "block"
    searchText.style.display = "none"
    editorCommandText.style.display = "none"
    voiceCommandText.style.display = "none"
    setCanvasHeightAccordingly()
}

// coral #color
// This is the old way, the new way is webkitSpeechRecognition flow
function openVoiceCommandText() {
    voiceCommandText.style.display = "block"
    voiceCommandText.value = ""
    voiceCommandProcessedIndex = 0
    voiceCommandLastProcessedWordIndex = 0
    voiceCommandText.focus()
}
function focusVoiceCommandText() {
    window.scrollTo(0, 0)
    voiceCommandText.setSelectionRange(0, voiceCommandText.value.length)
    voiceCommandText.style.display = "block"
    theText.style.display = "none"
    searchText.style.display = "none"
    editorCommandText.style.display = "none"
    setCanvasHeightAccordingly()
}
function inputVoiceCommandText() {
}
function blurVoiceCommandText() {
    // handle the case where when you collapse the keyboard on iPad
    // it triggers a blur event, but it's still the activeElement
    if (document.activeElement == voiceCommandText) {
        voiceCommandText.blur()
        return
    }
    theText.style.display = "block"
    searchText.style.display = "none"
    editorCommandText.style.display = "none"
    voiceCommandText.style.display = "none"
    setCanvasHeightAccordingly()
}
// end #color

function doTogglePin() {
    if (fx.fileMode == "fileList") {
        if (fx.selectedRegions.length>0) {
            var r = fx.selectedRegions[0]
            // we subtract 1 because of the initial "-" at the beginning
            var fileIndexStart = r.startY - 1
            var fileIndexStop = r.stopY - 1
            var shouldPin = !files[fileIndexStart].pinned
            for (var i=fileIndexStart; i<= fileIndexStop; i++) {
                files[i].pinned = shouldPin
            }
        } else {
            files[fx.cursorLineIndex - 1].pinned = !files[fx.cursorLineIndex - 1].pinned
        }
        seeFilesForReal(false)
    } else {
        fx.pinned = !fx.pinned
    }
    render()
    renderFileDropdown()
    saveWorkspace()
}
function doPin(pinned) {
    if (fx.fileMode == "fileList") {
        if (fx.selectedRegions.length>0) {
            var r = fx.selectedRegions[0]
            // we subtract 1 because of the initial "-" at the beginning
            var fileIndexStart = r.startY - 1
            var fileIndexStop = r.stopY - 1
            for (var i=fileIndexStart; i<= fileIndexStop; i++) {
                files[i].pinned = pinned
            }
        } else {
            files[fx.cursorLineIndex - 1].pinned = pinned
        }
        seeFilesForReal(false)
    } else {
        fx.pinned = pinned
    }
    render()
    renderFileDropdown()
    saveWorkspace()
}

function editSearch() {
    searchText.style.display = "block"
    searchText.focus()
}
function focusSearchText() {
    window.scrollTo(0, 0)
    searchText.setSelectionRange(0, searchText.value.length)
    searchText.style.display = "block"
    theText.style.display = "none"
    editorCommandText.style.display = "none"
    voiceCommandText.style.display = "none"
    setCanvasHeightAccordingly()
}
function inputSearchText() {
    if (fx.fileMode == "directory") {
        findDown(true, true)
    }
    render()
}
function blurSearchText() {
    // handle the case where when you collapse the keyboard on iPad
    // it triggers a blur event, but it's still the activeElement
    if (document.activeElement == searchText) {
        searchText.blur()
        return
    }
    theText.style.display = "block"
    searchText.style.display = "none"
    editorCommandText.style.display = "none"
    voiceCommandText.style.display = "none"
    setCanvasHeightAccordingly()
}

var searchHistory = []
var searchI = 0
function setSearchText(value) {
    searchText.value = value
    saveSearchHistory()
}
function saveSearchHistory() {
    if (searchText.value != "") {
        searchHistory.push(searchText.value)
        var maxHistory = 10
        if (searchHistory.length > maxHistory) {
            searchHistory = searchHistory.slice(searchHistory.length - maxHistory)
        }
        searchI = searchHistory.length - 1
    }
}
function handleSearchFocusBefore() {
    theText.style.display = "none"
    editorCommandText.style.display = "none"
    voiceCommandText.style.display = "none"
    searchText.style.display = "block"
    searchText.focus()
    setCanvasHeightAccordingly()
    // findUp()
    searchI--
    if (searchI < 0) {
        searchI = 0
    }
    searchText.value = searchHistory[searchI]
    searchText.setSelectionRange(searchText.value.length, searchText.value.length)
}
function handleSearchFocusAfter() {
    theText.style.display = "none"
    editorCommandText.style.display = "none"
    voiceCommandText.style.display = "none"
    searchText.style.display = "block"
    searchText.focus()
    setCanvasHeightAccordingly()
    // findDown()
    searchI++
    if (searchI >= searchHistory.length) {
        searchI = searchHistory.length - 1
    }
    searchText.value = searchHistory[searchI]
    searchText.setSelectionRange(searchText.value.length, searchText.value.length)
}

var requirePinned = true
function cleanUpFiles() {
    var seenFiles = {}
    var filesToClose = []
    var filesToKeep = []
    var pinnedFiles = []
    for (var i=0; i<files.length; i++) {
        var file = files[i]
        if (file.fileMode == "file" || file.fileMode == "directory") {
            // old logic, no need for pinned

            if (!requirePinned) {
                if (file.pinned) {
                    pinnedFiles.push(file)
                } else if (file.fullPath in seenFiles) {
                    filesToClose.push(file)
                } else {
                    seenFiles[file.fullPath] = true
                    filesToKeep.push(file)
                }
            } else {
                // must be pinned
                if (file.pinned) {
                    if (!seenFiles[file.fullPath]) {
                        pinnedFiles.push(file)
                        seenFiles[file.fullPath] = true
                    } else {
                        filesToClose.push(file)
                    }
                } else {
                    filesToClose.push(file)
                }
            }
        } else if (file.fileMode == "terminal" || file.fileMode == "shell") {
            if (file.pinned) {
                pinnedFiles.push(file)
            } else {
                if (file.name)  {
                    filesToKeep.push(file)
                } else {
                    filesToClose.push(file)
                }
            }
        } else {
            filesToKeep.push(file)
        }
    }
    
    for (var i=0; i<filesToClose.length; i++) {
        var file = filesToClose[i]
        closeFileServer(file).then(() => {
        }).catch(e => alert(e))
        if (file.iframeWrapper) {
            file.iframeWrapper.remove()
        }
    }
    
    filesToKeep.sort((a, b) => {
        var key = "fullPath"
        if (a[key] < b[key]) {
            return -1;
        }
        if (a[key] > b[key]) {
            return 1;
        }
        return 0;
    });
    files = pinnedFiles.concat(filesToKeep)
    
    render()
    renderFileDropdown()
    // seeFiles()
    seeFilesForReal(true)
}
function closeFile(theFX) {
    var resolve; var reject; var p = new Promise(function(res, rej) { resolve = res; reject = res });
    if (!theFX) {
        theFX = fx
    }
    if (theFX.pinned && !confirm("close pinned " + theFX.fullPath + "?")) {
        return
    }
    if (theFX.thumbscriptWorld) {
        theFX.thumbscriptWorld.global.stopped = true
    }
    if (theFX.fileMode == "fileList") {
        var fileIndex = files.indexOf(treeFilesShadow[theFX.cursorLineIndex])
        if (fileIndex != -1) {
            var fileToClose = files[fileIndex]
            // try to get index again because it could have changed
            var indexToClose = files.indexOf(fileToClose)
            if (indexToClose != -1) {
                var afterTreeSeparator = treeFilesShadow.indexOf("treeSeparator") < theFX.cursorLineIndex
                if (afterTreeSeparator) {
                    // after the tree separator we need to move up one because 2 lines are deleted
                    // see showFilesFlatFirst
                    theFX.cursorLineIndex -= 1
                    ensureCursorInScreen()
                }
                files.splice(indexToClose, 1)
            }
            theFX.lines = getLinesForFileList()
            theFX.marginLeft = calcMarginLeft(theFX.lines.length)
            // TODO?: to the useUnicode stuff here and related places
            // or maybe don't show unicode in file list?
            render()
            renderFileDropdown()
            closeFileServer(fileToClose).then(() => {
                resolve()
            }).catch(e => {
                alert(e)
                reject()
            })
        }
        theFX.lines = getLinesForFileList()
        theFX.marginLeft = calcMarginLeft(theFX.lines.length)
    } else {
        if (theFX.fileMode == "file") {
            if (theFX.version != theFX.savedVersion) {
                if (!confirm("Unsaved changes, click OK if you still want to close. ")) {
                    return
                }
            }
        }
        if (theFX.iframeWrapper) {
            theFX.iframeWrapper.remove()
        }
        var indexToClose = files.indexOf(theFX)
        if (indexToClose != -1) {
            files.splice(indexToClose, 1)
            // this changes fx
            selectFileIndex(indexToClose-1 < 0 ? 0: indexToClose-1)
        }
        render()
        renderFileDropdown()
        closeFileServer(theFX).then(() => {
        }).catch(e => alert(e))
    }
    return p
}

var shellHelpers = [
    // some common commands to use quickly
    // TODO: make these common commands configurable
    "gofmt -s -w .",
    "golangci-lint run --print-issued-lines=false",
    "git commit -m '' --author='Drew LeSueur <drewalex@gmail.com>'",
    "git checkout master",
    "git pull origin master",
    "git checkout -b ",
    "git log --all --decorate --graph -10",
    "grep -Rin '' --include=*.pm .",
    "grep -Rin '' --include=*.go .",
    "grep -Rin '' --include=*.php .",
    "grep -Rin '' .",
    "find . -iname '**'",
    // "diff -y --width=240",
    // "go test ./...",
    // a way to do `git add -p` non-interactively
    // "git --no-pager diff > gitdiff",
    // "open gitdiff",
    // "git apply --cached gitdiff",
    // "go doc -all ''",
    "git stash show -p stash@{0}",
    'git for-each-ref --sort=-committerdate refs/heads/ --format="%(refname:short)" | head -n 10',
    "clear",
    "git branch",
    "git status",
    "git log -10",
    "git log -p -3",
    "git add -u :/",
    'ssh-keygen -t ed25519 -C ""',
    "",
    "",
]

function getDefaultCWD(f) {
    var cwd = getDefaultCWDInner(f)
    if (isGitBash && !cwd.startsWith("/c/")) {
        cwd = "/c/" + cwd
    }
    return cwd
}
function getDefaultCWDInner(f) {
    // TODO: check again the proxyPath stuff here
    // it might be old and not used.
    if (f.shellCWD) {
        return f.shellCWD
    }

    if (f.fileMode == "directory") {
        return rootLocation + doTrimPrefix(f.fullPath, proxyPath)
    }

    if (f.fileMode == "file") {
        var parts = doTrimPrefix(f.fullPath, proxyPath).split("/")
        parts = parts.slice(0, parts.length - 1)
        return rootLocation + parts.join("/")
    }
}

function addCmdTab(id=0, cwd="", name="") {
    // I think this /cmd isn't hit on the server
    // I think we need a special endpoint for serving files and not just /
    var file = makeFile(proxyPath + "/cmd", 0, shellHelpers.join("\n"))
    file.fileMode = "shell"
    if (id) {
        file.ID = id
    }
    file.name = name
    if (!cwd) {
        cwd = getDefaultCWD(fx)
    }
    file.shellCWD = cwd
    addFileToList(file)
    setCurrentFile(file)
    fx.cursorLineIndex = fx.lines.length - 1
    updateCursorXY()
    runShellCommand("git branch | grep '*'")
    //theText.focus()
}

// TODO: addTerminalTab and addExistingTerminalTab can probably be consolidated,
// like addCmdTab
function addTerminalTab() {
    // TODO: follow up on the path variable, seems mostly useless for now.
    var file = makeFile(proxyPath + "/terminal", 0, "")
    file.fileMode = "terminal"
    file.shellCWD = getDefaultCWD(fx)
    addFileToList(file)
    setCurrentFile(file)
    fx.cursorLineIndex = fx.lines.length - 1
    updateCursorXY()
    openTerminal()
    //theText.focus()
    return file
}
function addExistingTerminalTab(id, name, cwd) {
    var file = makeFile(proxyPath + "/terminal", 0, "")
    file.fileMode = "terminal"
    file.ID = id
    file.shellCWD = cwd
    if (name) {
        file.name = name
    }
    addFileToList(file)
    setCurrentFile(file)
    fx.cursorLineIndex = fx.lines.length - 1
    updateCursorXY()
    if (!isPollingTerminal) {
        pollTerminals()
    }
    return file
    //theText.focus()
}
function normalizeFullPath(fullPath) {
    if (fullPath.charAt(0) != "/") {
        fullPath = "/" + fullPath
    }
    // TODO: also apply the .. and .
    var newParts = []
    var parts = fullPath.split("/")
    for (var i=0; i<parts.length; i++) {
        var part = parts[i]
        if (part == ".") {
            continue
        }
        if (part == "..") {
            newParts.pop()
        }
        newParts.push(part)
    }
    newFullPath = newParts.join("/")
    return newFullPath
}


function doEval() {
    var code = prompt("code")
    var resp =  eval(code)
    alert(resp)
}
function log(v) {
    var d = document.createElement("pre")
    d.style.display = "block"
    d.style.border = "1px solid blue"
    if (typeof v == "object") {
        d.innerText = JSON.stringify(v, "", "    ")
    } else {
        d.innerText = v
    }
    logEl.appendChild(d)
    logEl.scrollTop = logEl.scrollHeight
}

function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
var hasUpdatedSearchTextForReplaceFlow = false
function setLastWord(maybeLastWord) {
    if (maybeLastWord != "") {
        lastWord = maybeLastWord
        if (lastAction == "type" && !hasMovedSinceCut) {
            if (copyBuffer.length && !hasUpdatedSearchTextForReplaceFlow) {
                
                if (copyBuffer.length == 1 && copyBuffer[0] == lastWord) {
                    // weird case where the acPlop stuff gets weird with this feature
                } else {
                    searchText.value = "\\b" + escapeRegExp(copyBuffer[0]) + "\\b"
                    saveSearchHistory()
                    // searchText.value = copyBuffer[0]
                    hasUpdatedSearchTextForReplaceFlow = true
                }
            }
            // cut a word and then type, the new word automatically gets copied
            // this is for a nifty find and replace flow
            // and above we find other occurrences of the word we just cut
            if (copyBuffer.length == 1 && copyBuffer[0].indexOf(" ") == -1) {
                copyBuffer = lastWord.split("\n")
            }
        }
    } else {
        // TODO: do we need this
        // hasMovedSinceCut = true
    }
}
function docChanged(preventUndo) {
    fx.version += 1
    setLastWord(getWordAtCursor().word)
    if (!preventUndo) {
        // var start = Date.now()
        saveUndo(preventUndo)
    }
    renderSaves()
    fx.marginLeft = calcMarginLeft(fx.lines.length)
}
function saveUndo(preventUndo) {
    // 3 ways of doing undo
    //   1. any time you want an undo point just snapshot the whole file
    //      to a stack of snapshots and just restore the whole file on undo
    //      pro: simple to implement
    //      con: more memory usage.
    //   2. any time you want an undo point just diff the lines from last undo point (lastDocState)
    //.      and add that diff to a stack of diffs
    //       then snapahot to a single variable "lastDocState"
    //.      and just reverse apply the diff on undo.
    //       pro: Less memory, theoretically allows more undos
    //.      con: more cpu usage calcing the diff
    //.      con: more complicated to implement
    //.  3. make setters for any modification of the document (instead of just manual array modification)
    //.     in those setters we'd manually create diffs without diffing the whole document.
    //.     pro: less cpu and less memory all around
    //.     pro: would cause us to wrangle the document changes into simple functions
    //.          and we could reuse some logic for screen share
    //.     con: also complicated to implementwould have to
    //.     con: would have to go through all changes to fx.lines and update code (that actually could be a good thing)
    //.     con: in first 2 it might be easier to not make every single change cause an undo point
    //.          for example we currently don't want every letter typed to be an undo point. we currently undo at the line level
    //.          (see calls to docChanged)
    //.
    var currentContents = fx.lines.join("\n")
    if (currentContents == fx.undo.stack[fx.undo.index]) {
        return
    }
    if (fx.undo.index != fx.undo.stack.length - 1) {
        fx.undo.stack.splice(fx.undo.index + 1, fx.undo.stack.length - fx.undo.index +1)
        fx.undo.yStack.splice(fx.undo.index + 1, fx.undo.yStack.length - fx.undo.index +1)
        fx.undo.xStack.splice(fx.undo.index + 1, fx.undo.xStack.length - fx.undo.index +1)
    }
    fx.undo.index += 1
    fx.undo.stack.push(currentContents)
    fx.undo.yStack.push(fx.cursorLineIndex)
    fx.undo.xStack.push(fx.cursorColIndex)
    if (fx.undo.stack.length > maxUndos) {
        fx.undo.stack.shift()
        fx.undo.yStack.shift()
        fx.undo.xStack.shift()
        fx.undo.index -= 1
    }
}

function mergeLastUndos(count) {
    fx.undo.index -= (count - 1)
    fx.undo.stack.splice(fx.undo.stack.length - count, (count - 1));
    fx.undo.yStack.splice(fx.undo.yStack.length - count, (count - 1));
    fx.undo.xStack.splice(fx.undo.xStack.length - count, (count - 1));
}


// uncomment this line if you want to add back emoji, etc support
// var splitter = new GraphemeSplitter()
var segmenter = new Intl.Segmenter('en', {granularity: "grapheme"})
function splitGraphemes(theLine) {
    // return theLine.split("")
    // return splitter.splitGraphemes(theLine)
    var a = []
    var segments = segmenter.segment(theLine)
    for (let {segment, index, isWordLike} of segments) {
      a.push(segment)
    }
    return a
    
    // This also works, strange to me this interface?
    // var si = segmenter.segment(theLine)[Symbol.iterator]()
    // return [...si].map(x => x.segment)
    // https://github.com/tc39/proposal-intl-segmenter
}

// setter for lines
// this should help keep track of changes etc
// for use in undo maybe, and streaming
// in the future you can have more granular changes about what in the line
// is being updated, like a splice?
// maybe you can do a line diff too.
function updateLineFile(file, index, value) {
    if (index == -1) {
        index = file.cursorLineIndex
    }

    var theLine = value
    if (useUnicode) {
        // TODO; this needs wrangling, compare with what's done in getCachedGraphemes
        theLine = new String(value)
        theLine.cachedGraphemes = splitGraphemes(value)
        file.lines[index] = theLine
    } else {
        file.lines[index] = value
    }
    return theLine
}
function updateLine(index, value) {
    return updateLineFile(fx, index, value)
}
var emptyArray = []


function cacheLineMeta(theLine, index, file, key, value, nocache) {
    if (nocache == "nocache") {
        return
    }
    if (typeof file == "undefined") {
        file = fx
    }
    if (typeof index == "undefined" || index == -1) {
        index = file.cursorLineIndex
    }
    if (typeof theLine !== "object") {
        theLine = new String(theLine) 
    }
    theLine[key] = value
    if (index < file.lines.length) {
        file.lines[index] = theLine
    }
}
function getCachedTrimmedLine(theLine, index, file, nocache) {
    if (theLine.trimmedCache) {
        return theLine.trimmedCache
    }
    var trimmed = theLine.trim()
    cacheLineMeta(theLine, index, file, "trimmedCache", trimmed, nocache)
    return trimmed
}
function getCachedGraphemes(theLine, index, file, nocache) {
    if (theLine.length == 0) {
         return emptyArray
    }
    if (theLine.cachedGraphemes) {
        return theLine.cachedGraphemes
    }
    // log("getCachedGraphemes not cached: " + Date.now())
    var graphemes = splitGraphemes(theLine)
    cacheLineMeta(theLine, index, file, "cachedGraphemes", graphemes, nocache)
    return graphemes
}

function setLines(lines) {
    // TODO: calc a whole diff here?
    // because there can be multiple files
    // referencing the same lines,
    // we can't just set the lines on one
    // for when you have to update the whole object
    fx.lines = lines
    fx.marginLeft = calcMarginLeft(fx.lines.length)
    for (var i=0; i<files.length; i++) {
        // TODO: maybe you souldn't make terminal and shell have the same path anyway?
        if (fx.fileMode != "terminal" && fx.fileMode != "shell") {
            if (fx != files[i] && files[i].fullPath == fx.fullPath) {
                files[i].lines = fx.lines
                files[i].marginLeft = fx.marginLeft
            }
        }
    }
}
function repositionUndo(isUndo) {
    setLines(fx.undo.stack[fx.undo.index].split("\n"))
    if (isUndo) {
        fx.cursorColIndex = fx.undo.xStack[fx.undo.index + 1]
        fx.cursorLineIndex = fx.undo.yStack[fx.undo.index + 1]
    } else {
        fx.cursorColIndex = fx.undo.xStack[fx.undo.index]
        fx.cursorLineIndex = fx.undo.yStack[fx.undo.index]
    }
    if (fx.cursorLineIndex < fx.offsetY || fx.cursorLineIndex > fx.offsetY+maxLines) {
        fx.offsetY = max(0, fx.cursorLineIndex - fx.marginLeft)
    }
    if (fx.cursorColIndex < fx.offsetX || fx.cursorColIndex > fx.offsetX+maxCols) {
        fx.offsetX = max(0, fx.cursorColIndex - fx.marginLeft)
    }
    updateCursorXY()
    render()
}

function undo() {
    fx.undo.index = bind(fx.undo.index-1, 0, fx.undo.index)
    repositionUndo(true)
}

function redo() {
    fx.undo.index = bind(fx.undo.index+1, fx.undo.index, fx.undo.stack.length-1)
    repositionUndo(false)
}
function clearLog() {
    if (fx.fileMode == "shell") {
        runShellCommand("clear")
    } else if (fx.fileMode == "terminal") {
        // TODO: should I be using setLines?
        // fx.lines = [""]
        setLines([""])
        fx.cursorLineIndex = 0
        fx.cursorColIndex = 0
        updateCursorXY()
        // fx.offsetY = -minSpaceForHeader
        fx.offsetY = 0
        ensureCursorInScreen()
    }
    logEl.innerHTML = ""
    render()
}
function isNumeric(s) {
    var c = s.charCodeAt(0)
    return (c >= 48 && c <= 57)
}

function getCharClass(a) {
    if (a >= 65 && a <= 90) {
        return "cap"
    }
    if (a >= 97 && a <= 122) {
        return "low"
    }
    if (a >= 48 && a <= 57) {
        return "num"
    }
    return a
}
function findNextCharClass(theLine, index) {
    var currClass = getCharClass(theLine.charCodeAt(index))
    for (var i=index+1; i<theLine.length; i++) {
        var nextClass = getCharClass(theLine.charCodeAt(i))
        if (nextClass != currClass) {
            if ((i == index+1) && currClass == "cap") {
                currClass = nextClass
                continue
            }
            return i
        }
    }
    return theLine.length
}
function findPrevCharClass(theLine, index) {
    var currClass = getCharClass(theLine.charCodeAt(index))
    for (var i=index-1; i>=0; i--) {
        var prevClass = getCharClass(theLine.charCodeAt(i))
        if (prevClass != currClass) {
            if ((i == index-1) && currClass == "cap") {
                currClass = prevClass
                continue
            }
            return i+1
            continue
        }
    }
    return 0
}
function isWordyChar(c, strict) {
    return c && isWordy(c.charCodeAt(0), strict)
}

// check for A-Za-z0-9_
function isWordy(a, strict) {
    return (
        (a >= 65 && a <= 90) ||  // A-Z
        (a >= 97 && a <= 122) || // a-z
        (a >= 48 && a <= 57) ||  // 0-9
        (a == 95)            ||    // _

        ((!strict && fx.fileMode == "shell" || fx.fileMode == "terminal") && a == 46) || // .
        ((!strict && fx.fileMode == "shell" || fx.fileMode == "terminal") && a == 45) // -
    )
}

function isHashTag(a) {
    return (
        (a >= 65 && a <= 90) ||  // A-Z
        (a >= 97 && a <= 122) || // a-z
        (a >= 48 && a <= 57) ||  // 0-9
        (a == 95)            ||    // _
        (a == 35)                  // #

    )
}
function isRegularWord(theLine) {
    // a little regex could replace this :)
    for (var cI=0; cI<theLine.length; cI++) {
       if (!isWordy(theLine.charCodeAt(cI))) {
         return false
       }
    }
    return true
}
function getWordAtCursor(isWordyFunc) {
    if (!isWordyFunc) {
        isWordyFunc = isWordy
    }
    return getWordAt(fx.lines[fx.cursorLineIndex], u(fx.cursorColIndex), isWordyFunc)
}
function getWordAt(line, x, isWordyFunc) {
    if (!isWordyFunc) {
        isWordyFunc = isWordy
    }
    if (!line) return {start: x, end: x, word: ""}
    for (var startIndex=x-1; startIndex>=0; startIndex--) {
        if (!isWordyFunc(line.charCodeAt(startIndex))) {
            startIndex += 1
            break
        }
    }
    if (startIndex < 0) startIndex = 0
    for (var endIndex=x; endIndex < line.length; endIndex++) {
        if (!isWordyFunc(line.charCodeAt(endIndex))) {
            break
        }
    }
    //if (startIndex < endIndex) {
        return {start: startIndex, end: endIndex, word: line.substring(startIndex, endIndex)}
    //}
    return {start: x, end: x, word: ""}
}
function getWordBeforeCursor() {
    return getWordBefore(fx.lines[fx.cursorLineIndex], u(fx.cursorColIndex))
}
function getWordBefore(line, x) {
    if (!line) return {start: x, end: x, word: ""}
    for (var startIndex=x-1; startIndex>=0; startIndex--) {
        if (!isWordy(line.charCodeAt(startIndex))) {
            startIndex += 1
            break
        }
    }
    if (startIndex < 0) startIndex = 0
    var endIndex = x
    //if (startIndex < endIndex) {
        return {start: startIndex, end: endIndex, word: line.substring(startIndex, endIndex)}
    //}
    return {start: x, end: x, word: ""}
}
function findDownForm(e) {
    e.preventDefault()
    if (fx.fileMode == "directory" && document.activeElement == searchText) {
        clickItemInDirectory()
        searchText.select()
        return
    }
    findDown()
    return false
}

function nextHighlightRange() {
    // find the closest highlightRange that is after
    var hrs = fx.highlightRanges || []
    var closestYAfter = fx.lines.length - 1
    for (var i=0; i<hrs.length; i++) {
        var hr = hrs[i]
        if (hr.StartY > fx.cursorLineIndex && hr.StartY < closestYAfter) {
            closestYAfter = hr.StartY
        }
    }
    // now are there any marker comments between us and where we want to be? if so, stop there
    for (var i=fx.cursorLineIndex+1; i<closestYAfter; i++) {
        var line = fx.lines[i]
        if (line.endsWith(" marker")) {
            closestYAfter = i
            break
        }
    }
    fx.cursorLineIndex = closestYAfter
    ensureCursorInScreen()
}
function prevHighlightRange() {
    // find the closest highlightRange that is before
    var hrs = fx.highlightRanges || []
    var closestYBefore = 0
    for (var i=0; i<hrs.length; i++) {
        var hr = hrs[i]
        if (hr.StartY < fx.cursorLineIndex && hr.StartY > closestYBefore) {
            closestYBefore = hr.StartY
        }
    }
    // now are there any marker comments between us and where we want to be? if so, stop there
    for (var i=fx.cursorLineIndex-1; i>closestYBefore; i--) {
        var line = fx.lines[i]
        if (line.endsWith(" marker")) {
            closestYBefore = i
            break
        }
    }
    fx.cursorLineIndex = closestYBefore
    ensureCursorInScreen()
}

function nextHighlightText() {
    if (!highlightMatchesSingleRegExp) {
        return
    }
    var prevSearchText = searchText.value
    // searchText.value = fx.highlightText
    searchText.value = highlightMatchesSingleRegExp.toString().slice(1, -2)
    findDown()
    searchText.value = prevSearchText
}
function prevHighlightText() {
    if (!highlightMatchesSingleRegExp) {
        return
    }
    var prevSearchText = searchText.value
    // searchText.value = fx.highlightText
    searchText.value = highlightMatchesSingleRegExp.toString().slice(1, -2)
    findUp()
    searchText.value = prevSearchText
}

var lastFindWasHighlightText = false
function findDown(searchDir, wrap, startTop) {
    lastAction = "move"
    shouldAutocompleteLine = false
    hasMovedSinceNewLine = true
    acWord = null
    if (searchText.value.slice(0, 1) == ":" && (searchText.value.slice(1) - 0) == searchText.value.slice(1)) {
        fx.cursorLineIndex = searchText.value.slice(1) - 1
        ensureCursorInScreen()
        return
    }

    var startY = fx.cursorLineIndex
    if (startTop) {
       startY = 0
    }
    if (document.activeElement != searchText) {
        if (searchText.value == "" && fx.selectedRegions.length) {
            searchText.value = escapeRegExp(getSelectedLines(fx, false, true).lines[0])
            saveSearchHistory()
            return
        } else if (searchText.value == "" && !lastFindWasHighlightText && fx.cursorColIndex != -fx.marginLeft) {
            searchText.value = getWordAtCursor().word
            saveSearchHistory()
            if (searchText.value) {
                return
            }
        }
        if (searchText.value == "") {
            // nextHighlightRange()
            // return
            // navForward()
            if (false && fx.cursorColIndex == -fx.marginLeft) { //     red marker
                fx.cursorLineIndex++
                searchText.value = " mar"+"ker$"
                saveSearchHistory()
                searchText.preventXNav = true
                findDown()
                searchText.value = ""
            } else if (fx.fileErrors && fx.cursorColIndex == -fx.marginLeft) {
                var lineNumbers = Object.keys(fx.fileErrors).map(x => x - 0).sort((a, b) => a - b)
                // set @lineNumbers file @fileErrors keys map {as @x x - 0} sort { as2 @a @b a - b}
                var curLine = fx.cursorLineIndex + 1
                for (let i=0; i <lineNumbers.length; i++) {
                    let ln = lineNumbers[i]
                    if (ln > curLine && (i == 0 || lineNumbers[i-1] <= curLine)) {
                        fx.cursorLineIndex = ln - 1
                        updateCursorXY()
                        ensureCursorInScreen()
                        break
                    }
                }
            } else {
                nextHighlightText()
            }
            lastFindWasHighlightText = true
            return
        } // red marker
    }
    for (var i=startY; i<fx.lines.length; i++) {
        var lineToSearch = fx.lines[i]
        var originalLineToSearch = lineToSearch
        if (!startTop && i == fx.cursorLineIndex) {
            var startX = u(fx.cursorColIndex)
            if (!searchDir && lastSearchDirForSameTerm == "down") {
                startX = u(fx.cursorColIndex + lastSearchMatchLength)
            }
            lastSearchDirForSameTerm = "down"
            lineToSearch = lineToSearch.substr(startX)
        }
        var pos = -1
        if (false && document.activeElement == searchText) {
            pos = lineToSearch.toLowerCase().indexOf(searchText.value.toLowerCase())
            lastSearchMatchLength = searchText.value.length
        } else {
            if (useRegexSearch) {
                var theMatch = lineToSearch.match(cachedSearchRegexp(searchText.value))
                if (theMatch == null) {
                    pos = -1
                } else {
                    pos = theMatch.index
                    lastSearchMatchLength = theMatch[0].length
                }
            } else {
                pos = lineToSearch.indexOf(searchText.value)
                lastSearchMatchLength = searchText.value.length
            }
        }
        if (pos != -1) {
            if (!startTop && i == fx.cursorLineIndex) {
                // compensate for that we sliced the line originally
                pos += startX
            }
            fx.cursorLineIndex = i
            if (!searchText.preventXNav) {
                fx.cursorColIndex = expandTabIndex(originalLineToSearch, pos, i, fx)
            }
            if (fx.selectedRegions.length) {
                moveSelectionToCursor(fx.selectedRegions[0])
            }
            updateCursorXY()
            ensureCursorInScreen()

            render()
            return true
        }
    }
    if (wrap) {
        findDown(searchDir, false, true)
        return
    }
    render()
    return false
}

function ensureCursorInScreen(file, yOnly) {
    if (!file) {
        file = fx
    }
    if (file.cursorLineIndex < file.offsetY + minSpaceForHeader) {
        file.offsetY = file.cursorLineIndex - minSpaceForHeader
    } else if (file.cursorLineIndex >= file.offsetY+maxLines) {
        file.offsetY = file.cursorLineIndex-maxLines +1
    }
    
    if (fx.offsetY < 0) {
        fx.offsetY = 0
    }
    if (!yOnly) {
        // TODO: there is something more elegant
        // that you can do here
        if (file.cursorColIndex < file.offsetX) {
            //file.offsetX = file.cursorColIndex
            file.offsetX = file.cursorColIndex - Math.floor(maxCols/2)
        } else if (file.cursorColIndex > file.offsetX+maxCols) {
            file.offsetX = file.cursorColIndex - Math.floor(maxCols/2)
        }
        if (file.offsetX < -file.marginLeft) {
            file.offsetX = -file.marginLeft
        }
    }
    updateCursorXY(file)
    render()
}
// Note this won't work for certain chars
function reverse(str) {
    return str.split("").reverse().join("")
}
function findUp() {
    lastAction = "move"
    shouldAutocompleteLine = false
    hasMovedSinceNewLine = true
    acWord = null
    if (searchText.value.slice(0, 1) == ":" && (searchText.value.slice(1) - 0) == searchText.value.slice(1)) {
        fx.cursorLineIndex = searchText.value.slice(1) - 1
        ensureCursorInScreen()
    }
    // if (fx.selectedRegions.length) {
    if (searchText.value == "" && fx.selectedRegions.length) {
        searchText.value = escapeRegExp(getSelectedLines(fx, false, true).lines[0])
        saveSearchHistory()
        return
    }
    if (searchText.value == "" && !lastFindWasHighlightText && fx.cursorColIndex != -fx.marginLeft) {
        searchText.value = getWordAtCursor().word
        saveSearchHistory()
        if (searchText.value) {
            return
        }
    }
    if (searchText.value == "") {
        // prevHighlightRange()
        // return
        // navBack()
        
        
        if (false && fx.cursorColIndex == -fx.marginLeft) {
            fx.cursorLineIndex--
            searchText.value = " mar"+"ker$"
            saveSearchHistory()
            searchText.preventXNav = true
            findUp()
            searchText.value = ""
        } else if (fx.fileErrors && fx.cursorColIndex == -fx.marginLeft) {
            var lineNumbers = Object.keys(fx.fileErrors).map(x => x - 0).sort((a, b) => a - b)
            // set @lineNumbers file @fileErrors keys map {as @x x - 0} sort { as2 @a @b a - b}
            var curLine = fx.cursorLineIndex + 1
            for (let i=lineNumbers.length-1; i >= 0; i--) {
                let ln = lineNumbers[i]
                if (ln < curLine && (i == (lineNumbers.length - 1) || lineNumbers[i+1] >= curLine)) {
                // if (ln < curLine) and { (i is lineNumbers len - 1) or {lineNumbers at (1+i) >= curLine} }
                    fx.cursorLineIndex = ln - 1
                    updateCursorXY()
                    ensureCursorInScreen()
                    break
                }
            }
        } else {
            prevHighlightText()
        }
        lastFindWasHighlightText = true
        return
        // searchText.value = " mar"+"ker"
    }
    for (var i=fx.cursorLineIndex; i>=0; i--) {
        var lineToSearch = fx.lines[i]
        if (!lineToSearch) {
            continue
        }
        if (i == fx.cursorLineIndex) {
            lineToSearch = lineToSearch.substr(0, u(fx.cursorColIndex))
        }
        var pos = -1
        if (false && document.activeElement == searchText) {
            pos = reverse(lineToSearch.toLowerCase()).indexOf(reverse(searchText.value.toLowerCase()))
            lastSearchMatchLength = searchText.value
        } else {
            if (useRegexSearch) {
                var theMatches = lineToSearch.matchAll(cachedSearchRegexpGlobal(searchText.value))
                var theMatch  = null
                for (theMatch of theMatches) {
                    // This lets theMatch var be the last one (or none)
                }
                if (theMatch == null) {
                    pos = -1
                } else {
                    pos = theMatch.index
                    lastSearchMatchLength = theMatch[0].length
                }
            } else {
                pos = reverse(lineToSearch).indexOf(reverse(searchText.value))
                lastSearchMatchLength = searchText.value
            }
        }
        if (pos != -1) {
            if (i == fx.cursorLineIndex && !useRegexSearch) {
                pos += (fx.lines[i].length - u(fx.cursorColIndex))
            }
            fx.cursorLineIndex = i
            if (!searchText.preventXNav) {
                if (!useRegexSearch) {
                    var colIndex = fx.lines[i].length - (pos + searchText.value.length)
                    fx.cursorColIndex = expandTabIndex(fx.lines[i], colIndex, i)
                } else {
                    // this pos is from the left
                    // in the future we could probably make the non regexp more consistent where it loops to the last one. (maybe better than reversing string?)
                    fx.cursorColIndex = expandTabIndex(lineToSearch, pos, null, null, "nocache")
                }
            }
            if (fx.selectedRegions.length) {
                moveSelectionToCursor(fx.selectedRegions[0])
            }
            updateCursorXY()
            ensureCursorInScreen()
            render()
            return true
        }
    }
    render()
    return false
}
function clearSearch() {
    lastFindWasHighlightText = false
    searchText.preventXNav = false
    searchText.value = ""
    
    // reusing this for 2 things
    // if (lastDirection == "vertical") {
    //     lastDirection = "horizontal"
    // } else {
    //     lastDirection = "vertical"
    // }
    // log(lastDirection)
    render()
}

function updateCursorXY(file) {
    if (!file) {
        file = fx
    }
    cursorX = (fx.cursorColIndex - fx.offsetX) * fontWidth
    cursorY = (fx.cursorLineIndex - fx.offsetY) * fontHeight
}

var tabWidth = 4
function indent(region) {
    // seems to be buggy
    // when first line indent is more than
    // last line indent
    if ((fx.lines[fx.cursorLineIndex] || "")[0] == "\t") {
        addPrefix("\t", region)
        return
    }
    addPrefix(" ".repeat(tabWidth), region)

}
function dedent(region) {
    stripPrefixes(["\t", " ".repeat(tabWidth)], region)
}

function getCommentPrefix() {
    var prefix
    if (
        fx.fullPath.endsWith(".sh") ||
        fx.fullPath.endsWith(".py") ||
        fx.fullPath.endsWith(".pm") ||
        fx.fullPath.endsWith(".pl") ||
        fx.fullPath.endsWith(".yaml") ||
        fx.fullPath.endsWith(".yml") ||
        fx.fullPath.endsWith(".env") ||
        fx.fullPath.endsWith(".ch") ||
        fx.fullPath.endsWith(".ls") ||
        fx.fullPath.endsWith(".py") ||
        fx.fullPath.endsWith(".st") ||
        fx.fullPath.endsWith(".graphqls") ||
        fx.fullPath.endsWith(".graphql") ||
        fx.fullPath.endsWith(".conf") ||
        fx.fullPath.split("/").slice(-1)[0].startsWith(".") ||
        fx.fullPath.split("/").slice(-1)[0].indexOf(".") == -1
    ) {
        // Special case hack for sql script
        if (fx.lines[fx.lines.length-1] == "EOD") {
            prefix = "--"
        } else {
            prefix = "#"
        }
    } else if (fx.fullPath.endsWith(".ini"))  {
        prefix = ";"
    } else {
        prefix = "//"
    }
    return prefix
}

function comment(prefix) {
    var theLine
    if (ghostSelectionComment) {
        theLine = fx.lines[ghostSelectionComment.startY]
    } else if (fx.selectedRegions.length > 0) {
        theLine = fx.lines[fx.selectedRegions[0].startY]
    } else {
        theLine = fx.lines[fx.cursorLineIndex]
    }

    if (!prefix) {
        prefix = getCommentPrefix()
    }

    if (theLine.trim().startsWith(prefix)) {
        stripPrefixes([prefix+" ", prefix])
    } else {
        addPrefix(prefix+" ")
    }
    
    if (fx.selectedRegions.length) {
        ghostSelectionComment = fx.selectedRegions[0] // lightblue marker
        fx.selectedRegions = []
    }
}



function addPrefix(prefix, region) {
    var r = region || fx.selectedRegions[0] || ghostSelectionComment
    if (r) {
        var line = fx.lines[r.startY]
        var firstNonSpace = 0
        for (var i=0; i<line.length; i++) {
            var chr = line.charAt(i)
            if (chr != " " && chr != "\t") {
                firstNonSpace = i
                break
            }
        }
        
        for (var y=r.startY; y<=r.stopY; y++) {
            var myPrefix = prefix
            var line = fx.lines[y]
            var myFirstNonSpace = 0
            for (var i=0; i<line.length; i++) {
                var chr = line.charAt(i)
                if (chr != " " && chr != "\t") {
                    myFirstNonSpace = i
                    break
                }
            }
            if (myFirstNonSpace > firstNonSpace) {
                myFirstNonSpace = firstNonSpace
            } else if (myFirstNonSpace < firstNonSpace) {
                if (line.trim() == "") {
                    line = " ".repeat(firstNonSpace)
                    myFirstNonSpace = firstNonSpace
                    myPrefix = prefix.trimEnd()
                }
            }
            updateLine(y, line.slice(0, myFirstNonSpace) + myPrefix + line.slice(myFirstNonSpace))
        }
    } else {
        var line = fx.lines[fx.cursorLineIndex]
        var firstNonSpace = 0
        for (var i=0; i<line.length; i++) {
            var chr = line.charAt(i)
            if (chr != " " && chr != "\t") {
                firstNonSpace = i
                break
            }
        }
        // fx.lines[fx.cursorLineIndex] = line.slice(0, firstNonSpace) + prefix + line.slice(firstNonSpace)
        updateLine(fx.cursorLineIndex, line.slice(0, firstNonSpace) + prefix + line.slice(firstNonSpace))
    }
    docChanged()
    render()
}

function stripPrefixes(prefixes, region) {
    var r = region || fx.selectedRegions[0] || ghostSelectionComment
    if (r) {
        for (var y=r.startY; y<=r.stopY; y++) {
            // fx.lines[y] = stripPrefixesInner(fx.lines[y], prefixes)
            updateLine(y, stripPrefixesInner(fx.lines[y], prefixes))

        }
    } else {
        var line = fx.lines[fx.cursorLineIndex]
        // fx.lines[fx.cursorLineIndex] = stripPrefixesInner(line, prefixes)
        updateLine(fx.cursorLineIndex, stripPrefixesInner(line, prefixes))
    }
    docChanged()
    render()
}

function isWhiteSpace(str) {
    for (var i=0; i<str.length; i++) {
        var chr = str.charAt(i)
        if (chr != " " && chr != "\t") {
            return false
        }
    }
    return true
}
function stripPrefixesInner(line, prefixes) {
    for (var i=0; i<prefixes.length; i++) {
        var prefix = prefixes[i]
        var prefixPos = line.indexOf(prefix)
        if (prefixPos != -1) {
            if (isWhiteSpace(line.slice(0, prefixPos))) {
                line = line.slice(0, prefixPos) + line.slice(prefixPos + prefix.length)
                break
            }
        }
    }
    return line
}

function copyString(s) {
    copyBuffer = s.split("\n")
    copyEl.value = s
}
function copy(preventUnselect = false) {
    // wrapping in for loop to simulate goto
    for (var s=0; s<1; s++) {
        if (fx.selectedRegions.length>0) {
            var r = fx.selectedRegions[0]
            
            if (fx.fileMode == "directory") {
                cutDirectoryFiles = []
                copiedDirectoryFiles = fx.lines.slice(r.startY, r.stopY+1).map(function(f) {
                    return fx.fullPath + "/" + f
                })
                copyBuffer = copiedDirectoryFiles
                if (!preventUnselect) {
                    fx.selectedRegions = []
                    cursorType = "move" // I think you don't need this cursor type thing. that's when you are actually selecting
                }
                render()
                return
            }
            
            if (r.startY == r.stopY) {
                copyBuffer = [fx.lines[r.startY].slice(u(r.startX), u(r.stopX))]
                if (!preventUnselect) {
                    fx.selectedRegions = []
                    cursorType = "move"
                }
                render()
                break
            }
            copyBuffer = [
                unExpandSlice(fx.lines[r.startY], r.startX, -1, r.startY),
                ...fx.lines.slice(r.startY + 1, r.stopY),
                unExpandSlice(fx.lines[r.stopY], 0, r.stopX, r.stopY)
            ]
            if (!preventUnselect) {
                fx.selectedRegions = []
                cursorType = "move"
            }
            render()
            break
        }
        selectMode = "line"
        copyBuffer = [fx.lines[fx.cursorLineIndex]]
    }

    var copyBufferString = copyBuffer.join("\n")
    copyEl.value = copyBufferString

    // I think this is not working because it's on a touchmove event?
    // And not a simple on like onclick
    // navigator.clipboard.writeText(copyBufferString).then(function() {
    //    alert("copied")
    // }, function(e) {
    //    alert("not copied: " + e)
    // })


    // copyEl.setSelectionRange(0, copyEl.value.length)
    // var range = document.createRange()
    // range.selectNodeContents(copyEl)
    // var sel = window.getSelection()
    // sel.removeAllRanges()
    // sel.addRange(range)
    // document.execCommand("copy")
}

var debugOutput = []
var logFile = null

function clearLog2() {
    // debugOutput = []
    debugOutput.splice(0, debugOutput.length)
}
function showLog(preventFocus) {
    if (logFile == null || files.indexOf(logFile) == -1) {
        logFile = makeFile("__output", 0, "")
        logFile.fileMode = "file"
        logFile.cursorLineIndex = 0
        addFileToList(logFile)
        setCurrentFile(logFile)
        logFile.lines = debugOutput
        logFile.marginLeft = calcMarginLeft(logFile.lines.length)
        render()
        return
    }
    if (!preventFocus) {
        setCurrentFile(logFile)
    }
}

function log2Internal(pre, args) {
    var logRow = []
    for (var i=0; i<args.length; i++) {
        if (typeof args[i] == "object") {
            try {
                logRow.push(JSON.stringify(args[i], "", "   "))
            } catch (e) {
                logRow.push("**curcular**")
            }
            continue
        }
        logRow.push(args[i])
    }
    var logLines = logRow.join(" ").split("\n")
    for (var i=0; i<logLines.length; i++) {
        if (!pre) {
            debugOutput.push(logLines[i])
        } else {
            debugOutput.unshift(logLines[i])
        }
    }
    if (logFile) {
        logFile.marginLeft = calcMarginLeft(logFile.lines.length)
    }
    render()
}
function log2() {
    log2Internal(false, arguments)
}
function log2Pre() {
    log2Internal(true, arguments)
}




function log2Inline(str) {
    try {
        var subs = str.split("\n")
        debugOutput[debugOutput.length -1] += subs[0]
        for (var i=1; i<subs.length; i++) {
            debugOutput.push(subs[i])
        }
        render()
    } catch(e) {
        alert(e)
    }
}
// var getShellCodeForRunningGoFile = thumbscript4.makeJsFunc(() => { /*
//     :lines :filename
//     runCode: []
//     if. lines[0] ‚Ä¢is "// How to run:" {
//         // 100 max #darkorange
//         looprange. 1 100 { :i
//             if. lines[i] trim ‚Ä¢is "" {
//                 breakp
//             }
//             runCode ‚Ä¢push (lines[i] ‚Ä¢slicefrom 3)
//         }
//         // joining on cr because that's how terminal wants it
//         runCode ‚Ä¢join cr
//     }
//     else. {
//         // "time go run " ‚Ä¢cc filename
//         "time go run *.go"
//     }
// */ })

function getShellCodeForRunningFile(filename, lines, theDefault) {
    let runCode = [];
    // Check if first line says // How to run:
    
    if (lines[0].startsWith("#!")) {
        lines = lines.slice(1)
    }
    
    if (lines[0].trim() === "// How to run:" || lines[0].trim() === "// How to install:") {
        for (let i = 1; i < Math.min(101, lines.length); i++) {
            if (lines[i].trim() === "") {
                break;
            }
            runCode.push(lines[i].slice(3));
        }
        return runCode.join('\r');
    } else if (lines[0].trim() === "# How to run:") {
        for (let i = 1; i < Math.min(101, lines.length); i++) {
            if (lines[i].trim() === "") {
                break;
            }
            runCode.push(lines[i].slice(2));
        }
        return runCode.join('\r');
    } else {
        // Otherwise, return the default command string
        // return "time go run *.go";
        return theDefault
    }
}



function runScript() {
    clearLog2()
    var sl = getSelectedLines(fx)
    var theScriptLines = sl.lines
    var isWholeFile = sl.isWholeFile
    var thumbscriptWorld
    
    if (isWholeFile) {
        if (fx.fileMode != "file") {
            alert("needs to be a file")
            return
        }
        if (fx.version != fx.savedVersion) {
            alert("need to save before running to prevent accidents")
            return
        }
    }
    
    if (isWholeFile && fx.fullPath.endsWith(".go")) {
        let filename = fx.fullPath.split("/").slice(-1)
        addTerminalTab()
        fx.terminalLoadPromise.then(function () {
            // showLog()
            // let code = getShellCodeForRunningFile(filename, theScriptLines, "time go run *.go")
            let code = getShellCodeForRunningFile(filename, theScriptLines, "go test -race -v")
            sendTerminal(code, function() {
                saveWrapper() // hits Enter
            })
        })
        return
    }
    if (isWholeFile && (fx.fullPath.endsWith(".sh") || fx.fullPath.endsWith(".ls") || fx.fullPath.endsWith(".st"))) {
        let filename = fx.fullPath.split("/").slice(-1)
        let code = getShellCodeForRunningFile(filename, theScriptLines, "./" + filename)
        addTerminalTab()
        fx.terminalLoadPromise.then(function () {
            sendTerminal(code, function() {
                saveWrapper() // hits Enter
            })
        })
        return
    }
    if (isWholeFile && fx.fullPath.endsWith(".php")) {
        let filename = fx.fullPath.split("/").slice(-1)
        addTerminalTab()
        fx.terminalLoadPromise.then(function () {
            sendTerminal("php " + filename, function() {
                saveWrapper() // hits Enter
            })
        })
        return
    }
    if (isWholeFile && fx.fullPath.endsWith(".py")) {
        let filename = fx.fullPath.split("/").slice(-1)
        addTerminalTab()
        fx.terminalLoadPromise.then(function () {
            sendTerminal("python3 " + filename, function() {
                saveWrapper() // hits Enter
            })
        })
        return
    }
    if (isWholeFile && (fx.lines[0] || "").startsWith("#!")) {
        let filename = fx.fullPath.split("/").slice(-1)
        addTerminalTab()
        fx.terminalLoadPromise.then(function () {
            sendTerminal("./" + filename, function() {
                saveWrapper() // hits Enter
            })
        })
        return
    }
    
    if (false && theScriptLines[0] == "#thumbscript" || theScriptLines[0] == "#ths") {
            // thumbscriptWorld = thumbscript4.eval(theScriptLines.join("\n"), window) // lol the window
    } else {
        // add return to the last non-empty line
        for (var i=theScriptLines.length-1; i>=0; i--) {
            if (theScriptLines[i].trim() != "") {
                theScriptLines[i] = "return " + theScriptLines[i]
                break
            }
        }
        // var oldCopyBuffer = copyBuffer
        var code = theScriptLines.join("\n")
        var f = new Function(code)
        var ret = f()
        log2(ret)
        // if (typeof ret != "undefined") {
        //     ret = ret + ""
        //     copyBuffer = ret.split("\n")
        //     paste()
        //     copyBuffer = oldCopyBuffer
        // }
    }
    
    showLog()
    if (false && thumbscriptWorld) {
        // only one at a time for now
        logFile.thumbscriptWorld = thumbscriptWorld
    }
}

// deprecated
async function runChatGPTNonStreaming(model, options) {
    alert("yay!")
    var selectedLinesWrapper = getSelectedLines(fx, false, true);
    if (selectedLinesWrapper.isWholeFile) {
        return
    }
    var theScriptLines = selectedLinesWrapper.lines

    fx.chatGPTIndent = getIndent(theScriptLines[0])
    var content = theScriptLines.join("\n")
    if (options.extra) {
        content = content + options.extra
    }
    var messages = [
          {
            "role": "user",
            // "content": content + ". Add a newline after every 10-ish tokens, except when writing code."
            "content": content
          },
    ]
    clearLog2()
    showLog()
    // var resp = await fetch(proxyPath + "/chatgptNoStream", {
    //     cache: "no-cache",
    //     method: "POST"
    // })
    // var r = await resp.json()
    // log2(ret)
    log2(messages)
    
}

async function runChatGPT(model, options) {
    options = options || {}
    if (!isPollingTerminal) {
        pollTerminals()
    }
    if (!gptButton.oldInnerText) {
        gptButton.oldInnerText = gptButton.innerText

        gptButton.innerText = "cancel GPT"
    } else {
        fetch(proxyPath + "/cancelchatgpt", {
            cache: "no-cache",
            method: "POST"
        })
       gptButton.innerText = gptButton.oldInnerText
       gptButton.oldInnerText = ""
        
        return
    }
    clearLog2()
    var oldCopyBuffer = copyBuffer
    
    var deleteSelection = false
    if (options.inline) {
        deleteSelection = true
    }
    var selectedLinesWrapper = getSelectedLines(fx, deleteSelection);
    fx.selectedRegions = []
    if (selectedLinesWrapper.isWholeFile) {
        // don't want accidental whole file processing.
        // gptButton.innerText = gptButton.oldInnerText
        // gptButton.oldInnerText = ""
        // return

        selectedLinesWrapper = {lines: [""]}
    }

    var theScriptLines = selectedLinesWrapper.lines

    // add return to the last non-empty line
    fx.chatGPTIndent = getIndent(theScriptLines[0])
    var content = theScriptLines.join("\n")
    if (options.extra) {
        content = content + options.extra
    }
    if (options.inline) {
        content = content + "\n" 
            + "Do not output anything else other than the code. No explanation, just code. Do not surround the code with backticks."
    }
    var messages = [
          // o1 doesn't allow system prompts
          // {
          //   "role": "system",
          //   "content": "You are a helpful assistant."
          //   // "content": "You are a helpful assistant. In your responses, add new lines after about every 8 words, except when writing code."
          //   // "content": "When you answer prompts, be sure to add a new line after every 7 or so words, except when writing code. Be sure to add those new lines that's a '\\n' character!"
          // },
          {
            "role": "user",
            // "content": content + ". Add a newline after every 10-ish tokens, except when writing code."
            "content": content
          },
    ]
    // Todo: see if saveWorkspace is heavy
    // only do it if this fx doesn't have an ID?
    //
    if (!fx.ID) {
        await saveWorkspace()
    }
    // fetch(proxyPath + "/chatgpt?id=" + fx.ID + "&index="+fx.cursorLineIndex+"&messages=" + encodeURIComponent(JSON.stringify(messages)), {
    var formData = new FormData()
    formData.append("model", model)
    formData.append("id", fx.ID)
    formData.append("messages", JSON.stringify(messages))
    fetch(proxyPath + "/chatgpt", {
        cache: "no-cache",
        method: "POST", body: formData
    }).then(r => {
    }).catch(e => {
        alert("There was an error sending to chatgpt: " + e)
    })
    fx.lines.splice(fx.cursorLineIndex + 1, 0, "")
    fx.cursorLineIndex++
    if (!options.inline) {
        fx.lines.splice(fx.cursorLineIndex + 1, 0, fx.chatGPTIndent)
        fx.cursorLineIndex++
    }

    // docChanged()
    if (selectedLinesWrapper.isWholeFile) {
        fx.chatGPTCursorLineIndex = fx.lines.length - 1
    } else {
        fx.chatGPTCursorLineIndex = fx.cursorLineIndex
    }
    fx.chatGPTInline = options.inline
    render()

}


// generated by chatgpt
function findDifferences(aLines, bLines) {
  const aLinesObj = {};
  const bLinesObj = {};
  aLines.forEach(a => aLinesObj[a] = true);
  bLines.forEach(b => bLinesObj[b] = true);
  let inANotB = [];
  let inBNotA = [];
  let common = [];
  for (let a in aLinesObj) {
    if (a in bLinesObj) {
      common.push(a);
    } else {
      inANotB.push(a);
    }
  }
  for (let b in bLinesObj) {
    if (!(b in aLinesObj)) {
      inBNotA.push(b);
    }
  }
  return { inANotB, inBNotA, common };
}

function compareSets() {
    // second-most-recent file
    var aLines = getSelectedLines(lastFile).lines
    var bLines = getSelectedLines(fx).lines

    const results = findDifferences(aLines, bLines);
    
    var a_not_b = makeFile("__a_not_b", 0, results.inANotB.join("\n"))
    a_not_b.fileMode = "file"
    a_not_b.cursorLineIndex = 0
    addFileToList(a_not_b)
    setCurrentFile(a_not_b)

    var b_not_a = makeFile("__b_not_a", 0, results.inBNotA.join("\n"))
    b_not_a.fileMode = "file"
    b_not_a.cursorLineIndex = 0
    addFileToList(b_not_a)
    setCurrentFile(b_not_a)

    var both = makeFile("__both", 0, results.common.join("\n"))
    both.fileMode = "file"
    both.cursorLineIndex = 0
    addFileToList(both)
    setCurrentFile(both)

    updateCursorXY()
    ensureCursorInScreen()
}

function diffFiles() {
    // second-most-recent file
    var aLines = getSelectedLines(lastFile).lines
    var bLines = getSelectedLines(fx).lines

    // var contents = simpleDiffOld3(aLines, bLines, false).join("\n")
    var start = Date.now()
    var contents = simpleDiffOld3(aLines, bLines, false).join("\n")
    var f3 = makeFile("__diffOld3", 0, contents)
    f3.fileMode = "file"
    f3.cursorLineIndex = 0
    addFileToList(f3)
    setCurrentFile(f3)

    updateCursorXY()
    ensureCursorInScreen()
    
    return

    runQuickShellCommand("git diff --no-index " + lastFile.fullPath + " " + fx.fullPath, function(err, contents) {
        var f3 = makeFile("__diffOld3", 0, contents)
        f3.fileMode = "file"
        f3.cursorLineIndex = 0
        addFileToList(f3)
        setCurrentFile(f3)
        updateCursorXY()
        ensureCursorInScreen()
    })
}

// this is a little hacky by changing and restoring state.
function getSelectedLines(f, shouldDeleteSelected, shouldUnselect) {
    // save old
    // in scriptLines we also have "oldPreventRender" business going on. doesn't 'harm' anything but a bit ugly.
    var oldPreventRender = preventRender
    var oldCopyBuffer = copyBuffer
    var oldFx = fx

    // mutate
    // Setting the global fx because functions like del() and copy depend on it
    // We could instrad have extra functions that allow you to pass in
    // the file, like updateLine bs updateLineFile
    fx = f
    preventRender = true
    var isWholeFile = false
    // run and snag
    if (fx.selectedRegions.length) {
        // now copyBuffer has the lines we want to tweak
        if (shouldDeleteSelected) {
            // TODO: make it so this delete doesn't update the undo stack
            // or change use so there is no option to delete here
            del(false, false, true) // true to prevent Undo
        } else {
            copy(!shouldUnselect)
        }
    } else {
        // if nothing is selected, let's deal with all the lines
        // note that we don't yet support shouldDeleteSelected here.
        copyBuffer = fx.lines.slice() // slice here acts as a copy. Do we need a copy? doing it to be safe
        isWholeFile = true
    }
    theLines = copyBuffer

    // restore
    copyBuffer = oldCopyBuffer
    preventRender = oldPreventRender
    fx = oldFx

    return {
        lines: theLines,
        isWholeFile: isWholeFile,
    }
}
function prettyJsonSelected() {
    var _t = getSelectedLines(fx, true)
    var linesToProcess = _t.lines
    var isWholeFile = _t.isWholeFile
    var prettied = JSON.stringify(JSON.parse(linesToProcess.join("\n")), null, "    ").split("\n")
    if (isWholeFile) {
        setLines(prettied)
        docChanged()
    } else {
        pasteLines(prettied, false, false)
    }
}
function wordWrapSelected() {
    var _t = getSelectedLines(fx, true)
    var linesToProcess = _t.lines
    var isWholeFile = _t.isWholeFile
    var wordWrapped = wordWrap(linesToProcess)
    if (isWholeFile) {
        setLines(wordWrapped)
        docChanged()
    } else {
        pasteLines(wordWrapped, false, false)
    }
}
function wordWrap(lines) {
    let width = maxCols - fx.marginLeft
    let newLines = []
    var newLine = ""
    for (let line of lines) {
        let words = line.split(" ")
        // for (let word of words) {
        for (let i = 0; i < words.length; i++) {
            let word = words[i]
            // if (newLine == "") {
            if (i == 0) {
                if (word.length > width) {
                    newLines.push(word)
                } else {
                    newLine = word
                }
            } else {
                // TODO: don't split quote (see quote parsing elsewhere in this file)
                if (newLine.length + word.length + 1 >= width) {
                    newLines.push(newLine)
                    var prefix = getIndent(line) + "    "
                    if (line.trim().startsWith("//")) {
                        prefix = getIndent(line) + "//     "
                    } else if (newLine.indexOf("//") != -1) {
                        prefix = getIndent(line) + "    // "
                    }
                    newLine = prefix +  word
                } else {
                    newLine += " " + word
                }
            }
        }
        newLines.push(newLine)
        newLine = ""
    }
    return newLines
}

function sortSelected() {
    var _t = getSelectedLines(fx, true)
    var linesToProcess = _t.lines
    var isWholeFile = _t.isWholeFile
    linesToProcess.sort()
    if (isWholeFile) {
        setLines(linesToProcess)
        docChanged()
    } else {
        pasteLines(linesToProcess, false, false)
    }
}
function uniqSelected() {
    var _t = getSelectedLines(fx, true)
    var linesToProcess = _t.lines
    var isWholeFile = _t.isWholeFile
    
    var updatedLines = []
    var lastLine = null
    linesToProcess.forEach(line => {
        if (line !== lastLine) {
            updatedLines.push(line)
        }
        lastLine = line
    })
    if (isWholeFile) {
        setLines(updatedLines)
        docChanged()
    } else {
        pasteLines(updatedLines, false, false)
    }
}

function scriptFileLinesWithOneLineScript(f, oneLineScript) {
    try {
        var oldFx = fx
        fx = f
        scriptLinesWithOneLineScript(oneLineScript)
        fx = oldFx
    } catch (e) {
        alert(e)
    }
}

function scriptLinesWithOneLineScript(oneLineScript) {
    var oldPreventRender = preventRender
    preventRender = true

    var _t = getSelectedLines(fx, true)
    var linesToProcess = _t.lines
    var isWholeFile = _t.isWholeFile
    var s = oneLineScript
    if (s.slice(0, 2) == "r ") {
        var parts = s.split(" ")
        s = `x.replaceAll("${parts[1]}", "${parts[2]}")`
    } else if (s.slice(0, 2) == "l ") {
        // l w w x n r - $a $b $c $d
        var parts = s.split(" - ")
        // s = `ll(x,"${parts[0].slice(2)}", ${parts.slice(1).join(" - ")}")`
        s = `ll(x,"${parts[0].slice(2)}", ` + "`" + parts.slice(1).join(" - ") + "`" + `)`
    }
    var theScriptLines = [s]
    // This next part mostly copy-pasted from scriptLines function
    if (theScriptLines.length) {
        // add return to the last non-empty line
        for (var i=theScriptLines.length-1; i>=0; i--) {
            if (theScriptLines[i].trim() != "") {
                theScriptLines[i] = "return " + theScriptLines[i]
                break
            }
        }
        var funcBody = theScriptLines.join("\n")
        // log2(funcBody)
        // showLog()
        // preventRender = oldPreventRender
        // render()
        // return
        
        var f = function(x) {
            return x
        }
        try {
            line = f(line)
            f = new Function("x", "i", funcBody)
        } catch (e) {
            alert(e)
        }
        var retLines = []
        for (var i=0; i<linesToProcess.length; i++) {
            var line = linesToProcess[i]
            try {
                line = f(line, i)
            } catch (e) {
                alert(e)
                break; // if one fails, stop
            }
            var splitLine = (line + "").split("\n")
            for (var j=0; j<splitLine.length; j++) {
                retLines.push(splitLine[j])
            }
        }
    }
    if (isWholeFile) {
        setLines(retLines)
        docChanged()
    } else {
        pasteLines(retLines, false, false)
    }

    preventRender = oldPreventRender
    render()
}
function scriptLines() {
    var oldPreventRender = preventRender
    preventRender = true
    
    var expectedFx = fx
    
    var _t = getSelectedLines(expectedFx, true)
    var linesToProcess = _t.lines
    var isWholeFile = _t.isWholeFile

    var theScriptLines = getSelectedLines(lastFile, false).lines
    
    if (theScriptLines.length) {
        // add return to the last non-empty line
        for (var i=theScriptLines.length-1; i>=0; i--) {
            if (theScriptLines[i].trim() != "") {
                theScriptLines[i] = "return " + theScriptLines[i]
                break
            }
        }
        var funcBody = theScriptLines.join("\n")
        var f = function(x) {
            return x
        }
        try {
            line = f(line)
            f = new Function("x", funcBody)
        } catch (e) {
            alert(e)
        }
        var retLines = []
        for (var i=0; i<linesToProcess.length; i++) {
            var line = linesToProcess[i]
            try {
                line = f(line)
            } catch (e) {
                alert(e)
            }
            retLines.push(line)
        }
    }
    if (isWholeFile) {
        setLines(retLines)
        docChanged()
    } else {
        pasteLines(retLines, false, false)
        expectedFx.cursorLineIndex++
    }

    preventRender = oldPreventRender
    render()
}



function regexer(r) {
    return function(c, line, index) {
       return r.test(c)
    }
}
function notRegexer(r) {
    return function(c, line, index) {
       return (line.length == index) || !r.test(c)
    }
}
function ll(line, script, replacement) {
    var cmds = script.split(" ")
    var index = 0
    var startSelect = 0
    var vars = {"$": "$"}
    var varsArray = []
    var cmd
    var c
    var matchIndex = 0
    matchVars = "abcdefghijklmnoqrs"
    var findCurrentOrNext = function(capture, rs, re, process) {
        var start = -1

        // need to go past the end, this <=
        for (index = index; index <= line.length; index++) {
            if (start == -1) {
                // you could do fewer checks if you manage more state
                if (rs(line[index], line, index) && (index == 0 || !rs(line[index-1], line, index))) {
                    start = index
                }
            } else {
                if (re(line[index], line, index)) {
                    // you could have a processor func
                    if (!capture) {
                        break
                    }
                    var v = line.slice(start, index)
                    if (process) {
                       v = process(v)
                    }
                    vars[matchVars[matchIndex]] = v
                    varsArray.push(v)
                    matchIndex++
                    break
                }
            }
        }
    }
    for (var i=0; i<cmds.length; i++) {
        cmd = cmds[i]
        switch (cmd) {
        case "w":
            findCurrentOrNext(true, regexer(/[\w]/), notRegexer(/[\w]/))
            break
        case "z":
            findCurrentOrNext(true, regexer(/[\w\-]/), notRegexer(/[\w\-]/))
            break
        case "f":
            findCurrentOrNext(true, regexer(/[\w\-\.]/), notRegexer(/[\w\-\.]/))
            break
        case "x":
            findCurrentOrNext(false, regexer(/[\w]/), notRegexer(/[\w]/))
            break
        case "n":
            findCurrentOrNext(true, regexer(/[0-9\.\-]/), notRegexer(/[0-9\.\-]/), function(x) {
                return x - 0
            })
            break
        case "0":
            findCurrentOrNext(false, regexer(/[0-9\.\-]/), notRegexer(/[0-9\.\-]/))
            break
        case "r":
            findCurrentOrNext(true, regexer(/[\w]/), function(c, line, index) {
              if (index == line.length) {
                  return true
              }
              return false
            })
            break
        // you could use closures to things like capture strings with escaping?
        }
    }
    if (typeof replacement ==  "function") {
        return replacement.apply(null, varsArray)
    } else {
        var index = -1
        return replacement.replace(/\$[a-z\$]/g, function(match) {
            index++
            // if (match[1] == "$#") {
            //     return index
            // }
            return vars[match[1]]
        })
    }

}
/*
r = ll(
    `-34.2 number %% 400.123 # forever young `,
    "n w n r",
    "$b is $a and $c === $d"
)
r

r = ll("1/2/300", "n 0 n", (a,b) => {
   return a + b
})
r
301
NaN
303

number is -34.2 and 400.123 === forever young
$b is $a and $c === $d
number is -34.2 and 400.123 === forever young
*/


function setCanvasHeight(h) {
    canvasHeight = h

    // maybe rearrange this so you don't always have to do the if checks
    if (c.height != canvasHeight) {
        c.height = canvasHeight
    }
    if (c.style.height != (canvasHeight/3)+"px") {
        c.style.height = (canvasHeight/3)+"px"
    }

    maxLines = Math.floor(canvasHeight / fontHeight)
    
    verticalTouchSize = originalVerticalTouchSize
    if (verticalTouchSize * 5 > (canvasHeight/3)) {
        verticalTouchSize = (canvasHeight/3) / 5
    }

    if (verticalTouchSize * 5 < (canvasHeight/3 /2)) {
        verticalTouchSize = (canvasHeight/3) * (0.66) / 5
    }


    if (verticalTouchSize < 50) {
         verticalTouchSize = 50
    }
    
    // verticalTouchSize = (h/3)/5 // 5 buttons
    // verticalTouchSize = (h/3)/7 // 



    // if (verticalTouchSize > 130) {
    //     verticalTouchSize = 130
    // }
}
function setCanvasHeightAccordingly() {
    var heightReduction = 0
    if (inDebugView) {
        // If this is too big then iOS wiLl auto scroll
        // it up so that the text isn't so low I guess
        // an attempt to window.scrollTo(0,0) failed
        // var statusElHeight = 100
        // var statusElHeight = 190
        // var statusElHeight = 150
        var statusElHeight = 170
        statusEl.style.height = statusElHeight + "px"
        logEl.style.height = statusElHeight + "px"

        // statusEl.style.border = "1px solid orange"
        heightReduction = statusElHeight * 3
    }
    // for the ipad, try to use the floating keyboard

    if (!floatingKeyboard && (document.activeElement == theText || document.activeElement == searchText || document.activeElement == editorCommandText || document.activeElement == voiceCommandText)) {
        if (fx.fileMode == "terminal") {
            setCanvasHeight(canvasHeightKeyboardTerminal - heightReduction)
        } else {
            setCanvasHeight(canvasHeightKeyboard - heightReduction)
        }
    } else {
       if (fx && fx.fileMode == "shell") {
           setCanvasHeight(canvasHeightShell - heightReduction)
           // fileRow.style.display = "none" // red marker
       } else if (fx && fx.fileMode == "terminal") {
           setCanvasHeight(canvasHeightTerminal - heightReduction)
           // fileRow.style.display = "none" // red marker
       } else if (fx && fx.fileMode == "iframe") {
           setCanvasHeight(canvasHeightIframe - heightReduction)
           // fileRow.style.display = "flex" // red marker
       } else {
           setCanvasHeight(canvasHeightFull - heightReduction)
           // fileRow.style.display = "flex" // red marker
       }
    }
    
    // hack here to ignore whatever we set it before and set it to be canvasHeightFull if we have a bluetooth keybaord
    if (bluetoothKeyboard) {
        setCanvasHeight(canvasHeightFull - heightReduction)
    }
    render()
}
function setCanvasWidth(w) {
    canvasWidth = w
    maxCols = Math.floor(canvasWidth / fontWidth)
}

function linkToRemote() {
    runQuickShellCommand("git symbolic-ref --short HEAD", function(err, branch) {
        branch = branch.trim();
        runQuickShellCommand("git remote -v", function(err, remote) {
            remote = remote.trim();
            let lines = remote.split('\n');
            let originFetch;
            for (let line of lines) {
                let parts = line.split(/\s+/);
                if (parts[0] === "origin" && parts[2] === "(fetch)") {
                    originFetch = parts[1];
                    break;
                }
            }
            let repoUrl;
            let repoPlatform;
            if (originFetch.startsWith('git@github.com')) {
                repoPlatform = 'github';
                repoUrl = originFetch.replace('git@github.com:', 'https://github.com/');
            } else if (originFetch.startsWith('git@gitlab.com')) {
                repoPlatform = 'gitlab';
                repoUrl = originFetch.replace('git@gitlab.com:', 'https://gitlab.com/');
            } else if (originFetch.startsWith('https://')) {
                repoUrl = originFetch;
                if (originFetch.includes('github.com')) {
                    repoPlatform = 'github';
                } else if (originFetch.includes('gitlab.com')) {
                    repoPlatform = 'gitlab';
                } else {
                    alert('Unsupported remote platform');
                    return;
                }
            } else {
                alert('Invalid remote format');
                return;
            }
            // Normalize .git suffix:
            if (repoUrl.endsWith('.git')) {
                repoUrl = repoUrl.slice(0, -4);
            }
            // Get the file path relative to the Git root:
            runQuickShellCommand(`git rev-parse --show-toplevel`, function(err, gitRoot) {
                gitRoot = gitRoot.trim();
                let relativePath = fx.fullPath.replace(gitRoot + "/", "");
                // Get current line number and, if applicable, the selected range:
                let lineNumber = fx.cursorLineIndex + 1;
                let selectedRegions = fx.selectedRegions;
                if (selectedRegions.length > 0) {
                  let firstRegion = selectedRegions[0];
                  let startLine = firstRegion.startY + 1;
                  let endLine = firstRegion.stopY + 1;
                  lineNumber = `${startLine}-${endLine}`;
                }
                // Create the codebase link:
                let codebaseLink = `${repoUrl}/tree/${branch}/${relativePath}#L${lineNumber}`;
                // Show and navigate to the link:
                alert(codebaseLink);
                location.href = codebaseLink;
                // Copy the link to the clipboard:
                copyBuffer = [codebaseLink];
                osCopyText();
            });
        });
    });
}



function insertText(theLines, yOffset, xOffset) {
    selectMode = "line"
    if (xOffset == -1) {
       xOffset = theLines[yOffset].length
    }
    var oldCopyBuffer = copyBuffer
    copyBuffer = theLines
    paste()
    fx.selectedRegions = []
    cursorType = "move"
    fx.cursorLineIndex = fx.cursorLineIndex + yOffset + 1
    var theLine = fx.lines[fx.cursorLineIndex]
    fx.cursorColIndex = expandTabIndex(theLine, xOffset)
    ensureCursorInScreen()
    render()
    copyBuffer = oldCopyBuffer
}
function readySameCommitAsBefore() {
    runQuickShellCommand("git log -1", function(err, result) {
        if (err) {
            return
        }
        // commit 7567b8aed34738da36b23d67b3053f3b6a30e13e
        // Author: Drew LeSueur <drewalex@gmail.com>
        // Date:   Mon Oct 4 19:24:54 2021 -0700
        //
        //     remove navBack and navForward features, wasnt using them

        if (result.indexOf("\r") != -1) {
            alert("you got cr!")
        }
        var lines = result.split("\n")
        if (lines.length < 5) {
            alert("could not get previous commit")
            return
        }
        var author = lines[1].substr("Author:".length).trim()
        var message = lines[4].trim()
        insertText(["git commit -m '"+bashEscapeSingleQuote(message)+"' --author '"+bashEscapeSingleQuote(author)+"'"], 0, 15)

    })
}

function bashEscapeSingleQuote(str) {
    return str.replaceAll("'", "'\\''")
}

function paste(unselect, pasteBefore, fromTap, unselectIfCharOneWord) {
    ghostSelection = null
    // todo: fromTap really means "smart" paste
    if (fx.fileMode == "directory" && copiedDirectoryFiles.length) {
        var dest = "."
        
        var shouldContinue = false
        if (copiedDirectoryFiles.length == 1) {
            dest = prompt("copy file", copiedDirectoryFiles[0].split("/").slice(-1) + "")
            if (dest) {
                shouldContinue = true
                // add quotes
                dest = '"' + dest + '"'
            }
        } else {
            shouldContinue = confirm("copy " + copiedDirectoryFiles.length + " files?")
        }
        if (shouldContinue) {
            var theCmd = copiedDirectoryFiles.map(function(f) {
                // return "cp -r \"" + f  + "\" ." + ";"
                return `cp -r "${f}" ${dest};`
            }).join("")
            runQuickShellCommand(theCmd, function(err, result) {
                if (err) {
                    alert("copy files error: " + err)
                    return
                }
                if (result) {
                    alert(result)
                }
                reloadFile()
            })
        }
        return
    }
    if (fx.fileMode == "directory" && cutDirectoryFiles.length) {
        cutDirectoryFiles = []
        // unimplemented
        return
    }
    return pasteLines(copyBuffer, unselect, pasteBefore, fromTap, unselectIfCharOneWord)
}
var pasteDebug = false
var p = []

function pasteLines(localCopyBuffer, unselect, pasteBefore, fromTap, unselectIfCharOneWord) {
    ghostSelection = null
    if (pasteDebug) {
        p.unshift(new Error().stack)
    }
    if (fx.iframe) {
        return 0
    }
    if (fromTap && !hasMovedSinceCut && globalOldCopyBuffer.length) {
        localCopyBuffer = globalOldCopyBuffer
    }
    if (localCopyBuffer.length == 0) {
        return 0
    }
    var linesPasted = 0
    if (selectMode == "line") {
        var theOffset = 1
        var theOffset2 = 0
        if (pasteBefore) {
            theOffset = 0
            theOffset2 = -1
        }
        fx.lines.splice(fx.cursorLineIndex + theOffset, 0, ...localCopyBuffer)
        adjustHighlightRanges(fx.cursorLineIndex + theOffset, localCopyBuffer.length)
        
        var stopY = fx.cursorLineIndex + localCopyBuffer.length + theOffset2
        var lastLine = fx.lines[stopY] || ""
        var newSelection = {
                startY: fx.cursorLineIndex + theOffset,
                // remember stopY is inclusive, stopX no
                stopY: stopY,
                startX: 0,
                stopX: expandTabIndex(lastLine, lastLine.length, stopY),
            }
        if (false && !unselect) {
            fx.selectedRegions = [newSelection]
        } else {
            ghostSelection = newSelection // lightblue marker
        }
        linesPasted = localCopyBuffer.length

        // so you can paste then run
        // because we don't select after paste anymore
        if (fx.fileMode == "shell") {
            fx.cursorLineIndex++
            ensureCursorInScreen()
        }
    } else if (selectMode == "char") {
        if (localCopyBuffer.length == 1) {
            // fx.lines[fx.cursorLineIndex] = fx.lines[fx.cursorLineIndex].slice(0, u(fx.cursorColIndex)) +
            // localCopyBuffer[0] +
            // fx.lines[fx.cursorLineIndex].slice(u(fx.cursorColIndex))
            updateLine(fx.cursorLineIndex, fx.lines[fx.cursorLineIndex].slice(0, u(fx.cursorColIndex)) +
                localCopyBuffer[0] +
                fx.lines[fx.cursorLineIndex].slice(u(fx.cursorColIndex))
            )

            // #alternateTap
            var theLine = fx.lines[fx.cursorLineIndex] || ""
            var stopX = expandTabIndex(theLine, u(fx.cursorColIndex) + localCopyBuffer[0].length)

            if (false) {
                // regex to test for non-wordy characters
                var isOneWord = !/\W/.test(localCopyBuffer[0].trim())
                if (alternateTap && !unselect && (!isOneWord || !unselectIfCharOneWord)) {
                    var sr = {
                        startY: fx.cursorLineIndex,
                        startX: fx.cursorColIndex,
                        stopX: stopX,
                        stopY: fx.cursorLineIndex,
                    }
                    fx.selectedRegions = [sr]
                }
            }
            fx.cursorColIndex = stopX // usually we want the cursor at the end
            updateCursorXY()
            linesPasted = localCopyBuffer.length
        } else {
            var line = fx.lines[fx.cursorLineIndex]
            // fx.lines[fx.cursorLineIndex] = line.slice(0, u(fx.cursorColIndex)) +
            //     localCopyBuffer[0]
            updateLine(fx.cursorLineIndex, line.slice(0, u(fx.cursorColIndex)) +
                localCopyBuffer[0]
            )
            // localCopyBuffer[localCopyBuffer.length-1] += line.slice(u(fx.cursorColIndex))
            // fx.lines.splice(fx.cursorLineIndex+1, 0, ...localCopyBuffer.slice(1))
            lastLine = localCopyBuffer[localCopyBuffer.length-1] + line.slice(u(fx.cursorColIndex))
            fx.lines.splice(fx.cursorLineIndex+1, 0, ...localCopyBuffer.slice(1, -1), lastLine)
            adjustHighlightRanges(fx.cursorLineIndex+1, localCopyBuffer.length-1)

            // #alternateTap
            if (alternateTap && !unselect) {
                var lastCopyBufferLine = localCopyBuffer[localCopyBuffer.length - 1]
                var sr = {
                    startY: fx.cursorLineIndex,
                    startX: fx.cursorColIndex,
                    stopX: expandTabIndex(lastCopyBufferLine, lastCopyBufferLine.length, null, null, "nocache"),
                    stopY: fx.cursorLineIndex + localCopyBuffer.length - 1,
                }
                fx.selectedRegions = [sr]
            }
            linesPasted = localCopyBuffer.length
        }
    }
    docChanged()
    render()
    return linesPasted
}

var splicedFiles = []
var cutDirectoryFiles = []
var copiedDirectoryFiles = []

var globalOldCopyBuffer = []
var hasMovedSinceCut = true
var lastDeleteWasFromSelection = false

// 2 variables because pasting should not allow next comment action to apply to what we pasted
// but commenting should allow the left/right to indent and dedent
var ghostSelection = null
var ghostSelectionComment = null

function del(preventCopy, preventDeleteWholeLine, preventUndo) {
    // var oldCopyBuffer = copyBuffer
    
    copyShenanigans(function () {
        delinternal(preventCopy, preventDeleteWholeLine, preventUndo)
    })
    
    // to allow cut paste, cut paste, cut paste of same word
    // if (copyBuffer.join("\n") != oldCopyBuffer.join("\n")) {
    //     globalOldCopyBuffer = oldCopyBuffer
    // }
}

function copyShenanigans(fn) {
    // see del()
    var oldCopyBuffer = copyBuffer
    fn()
    // to allow cut paste, cut paste, cut paste of same word
    if (copyBuffer.join("\n") != oldCopyBuffer.join("\n")) {
        globalOldCopyBuffer = oldCopyBuffer
    }
    hasMovedSinceCut = false
}




function delinternal(preventCopy, preventDeleteWholeLine, preventUndo) {
    hasUpdatedSearchTextForReplaceFlow = false

    if (fx.selectedRegions.length>0) {
        
        lastDeleteWasFromSelection = true
        var r = fx.selectedRegions[0]
        
        if (!r) {
            r = {
                startX: 0,
                startY: fx.cursorLineIndex,
                stopY: fx.cursorLineIndex,
                stopX: expandTabIndex(fx.lines[fx.cursorLineIndex], -1)
            }
        }

        // kind of a hacky way to allow moving around
        // of files in the file list
        // we use <= instead of just < because of the initial "-" at the beginning of the file list
        if (fx.fileMode == "fileList" && r.startY <= files.length && r.stopY <= files.length) {
            // we subtract 1 because of the initial "-" at the beginning
            var cutFileIndexStart = r.startY - 1
            var cutFileIndexStop = r.stopY - 1

            splicedFiles = files.splice(cutFileIndexStart, (cutFileIndexStop - cutFileIndexStart)+1)
            setLines(getLinesForFileList())
            fx.selectedRegions = []
            cursorType = "move"
            docChanged()
            render()
            return
        }
        if (fx.fileMode == "directory") {
            copiedDirectoryFiles = []
            cutDirectoryFiles = fx.lines.splice(r.startY, (r.stopY - r.startY)+1).map(function(f) {
                return fx.fullPath + "/" + f
            })
            copyBuffer = cutDirectoryFiles
            fx.selectedRegions = []
            cursorType = "move"
            fx.cursorLineIndex = r.startY
            updateCursorXY()
            ensureCursorInScreen()
            docChanged()
            render()
            return
        }

        if (r.startY == r.stopY) {
            if (!preventDeleteWholeLine && r.startX == 0 && unExpandTabIndex(fx.lines[r.startY], r.stopX, r.startY) == fx.lines[r.startY].length) {
                selectMode = "line"
                if (!preventCopy) {
                    copyBuffer = [fx.lines[r.startY]]
                    // cutBuffer = [fx.lines[r.startY]]
                }
                fx.lines.splice(r.startY, 1)
                adjustHighlightRanges(r.startY, -1)
                fx.selectedRegions = []
                cursorType = "move"
                if (r.startY > 0) {
                    // subtract 1 so we can paste right afer
                    fx.cursorLineIndex = r.startY - 1
                    updateCursorXY()
                }
                docChanged()
                render()
                return
            } else {
                // I don't remember adding this. Is this right?
                // selectMode = "char"
                if (!preventCopy) {
                    copyBuffer = [unExpandSlice(fx.lines[r.startY], r.startX, r.stopX, r.startY)]
                    // cutBuffer = [unExpandSlice(fx.lines[r.startY], r.startX, r.stopX)]
                }
                // fx.lines[r.startY] = unExpandSlice(fx.lines[r.startY], 0, r.startX) +
                //     unExpandSlice(fx.lines[r.startY], r.stopX)
                updateLine(r.startY, unExpandSlice(fx.lines[r.startY], 0, r.startX, r.startY) +
                    unExpandSlice(fx.lines[r.startY], r.stopX, -1, r.startY)
                )
                fx.selectedRegions = []
                fx.cursorLineIndex = r.startY
                fx.cursorColIndex = r.startX
                updateCursorXY()
                fx.selectedRegions = []
                cursorType = "move"
                docChanged()
                render()
                if (document.activeElement == theText) {
                    //theText.setSelectionRange(r.startX, r.startX)
                    setSelectionRangeForText(r.startX, r.startX)
                }
                return
            }
        }
        var fullLines = r.startX == 0 && unExpandTabIndex(fx.lines[r.stopY], r.stopX, r.stopY) == fx.lines[r.stopY].length
        if (!preventCopy) {
            // cutBuffer = [
            copyBuffer = [
                unExpandSlice(fx.lines[r.startY], r.startX, -1, r.startY),
                ...fx.lines.slice(r.startY + 1, r.stopY),
                unExpandSlice(fx.lines[r.stopY], 0, r.stopX, r.stopY)
            ]
        }
        // fx.lines[r.startY] = unExpandSlice(fx.lines[r.startY], 0,  r.startX) +
        //     unExpandSlice(fx.lines[r.stopY], r.stopX)
        updateLine(r.startY, unExpandSlice(fx.lines[r.startY], 0,  r.startX, r.startY) +
            unExpandSlice(fx.lines[r.stopY], r.stopX, -1, r.stopY)
        )
        fx.lines.splice(r.startY + 1, r.stopY-r.startY)
        adjustHighlightRanges(r.startY+1, -(r.stopY-r.startY))
        if (!preventDeleteWholeLine) {
            if (fx.lines[r.startY] == "") {
                fx.lines.splice(r.startY, 1)
                adjustHighlightRanges(r.startY, -1)
            }
        }
        fx.cursorLineIndex = r.startY
        // fx.cursorColIndex = r.startX // commented out to avoud jerkiness when cutting when scrolled

        // if full lines then move cursor up once to paste
        if (fullLines) {
            // fx.cursorColIndex = -fx.marginLeft
            if (fx.cursorLineIndex > 0) {
                fx.cursorLineIndex -= 1
            }
        }
        updateCursorXY()
        fx.selectedRegions = []
        cursorType = "move"
        if (!preventUndo) {
            docChanged()
        }
        render()
        if (document.activeElement == theText) {
            //theText.setSelectionRange(r.startX, r.startX)
            setSelectionRangeForText(r.startX, r.startX)
        }
        return
    }
    selectMode = "line"
    if (!preventCopy) {
        // cutBuffer = [fx.lines[fx.cursorLineIndex]]
        copyBuffer = [fx.lines[fx.cursorLineIndex]]
    }
    lastDeleteWasFromSelection = false
    fx.lines.splice(fx.cursorLineIndex, 1)
    adjustHighlightRanges(fx.cursorLineIndex, -1)
    docChanged()
    render()
}
function getIndent(line) {
    var theIndent = ""
    for (var i=0; i<line.length; i++) {
        var theChar = line.charAt(i)
        if (theChar == " " || theChar == "\t") {
            theIndent += theChar
        } else {
            return theIndent
        }
    }
    return theIndent
}
function getExpandedIndentLength(theLine, index, file, nocache) {
    var expandedLine = expandLine(theLine, index, file, nocache)
    for (var i=0; i<expandedLine.length; i++) {
        var theChar = expandedLine[i]
        if (theChar == " " || theChar == "\t") {
            continue
        }
        return i
    }
    return 0
}

function adjustHighlightRanges(index, linesAddedCount, theFile) {
    // splice adds before

    if (!theFile) {
        theFile = fx
    }
    if (!theFile) {
        return
    }
    if (!theFile.highlightRanges) {
        return
    }

    for (var fileI=0; fileI<files.length; fileI++) {
        var file = files[fileI]
        if (file.lines != theFile.lines) { // same lines, same file
            continue
        }

        // TODO: fugure out why it's null (default Go value maybe)
        if (!file.highlightRanges) {
            file.highlightRanges = []
        }
        for (var i=0; i<file.highlightRanges.length; i++) {
            var r = file.highlightRanges[i]
            // This single condition works well enough for now
            if (true || linesAddedCount >= 0) {
                if (index <= r.StartY) {
                    r.StartY += linesAddedCount
                    r.StopY += linesAddedCount
                } else if (index <= r.StopY) {
                    r.StopY += linesAddedCount
                } else if (index > r.stopY) {
                    // nothing
                }
            } else {
               // this is buggy needs plenty of fixes
               // what about undo???
               // var stopIndex = index - linesAddedCount
               // if (index <= r.StartY && stopIndex <= r.StartY) {
               // } else if (index <= r.StartY && stopIndex <= r.StopY) {
               //     var hlLinesRemoved = stopIndex - r.StartY
               //     r.StartY += hlLinesRemoved
               //     r.StopY += hlLinesRemoved
               // } else if (index > r.StartY && stopIndex <= r.StopY) {
               //     r.StopY += linesAddedCount
               // } else if (index <= r.Stopy && stopIndex > r.StopY) {
               //     var hlLinesRemoved = stopIndex - r.Stopy
               //     r.StopY += hlLinesRemoved
               // }
            }
        }
    }
}

function insertLine(closeCurly, oMode) {
    if (fx.fileMode == "iframe") {
        // TODO: figure out this flow, sometimes happens when I click a for button on iframe.
        // likely click causes this and we should change it to not get here on iframe
        // but maybe it happens after a form is posted and opens a new "tab", even when not target=_blank
        return
    }
    if (fx.fileMode == "directory") {
        clickItemInDirectory()
        return
    }
    lastAction = "type"
    hasMovedSinceNewLine = false
    acWord = null
    var theLine = fx.lines[fx.cursorLineIndex]
    var theIndent = getIndent(theLine)
    var prevChar = theLine[u(fx.cursorColIndex - 1)]
    var nextChar = theLine[u(fx.cursorColIndex)]
    var strIndex = theText.selectionStart

    // if they are at the beginning, or there is an auto-closer before us
    // then we don't want oMode
    // otherwise oMode is like typing o in vim
    // if (oMode && strIndex != 0 && !(prevChar in closingMap)) {
    if (oMode && !wasWasDelete && strIndex != 0 && (!prevChar || isWordy(prevChar.charCodeAt(0))) && (!nextChar || isWordy(nextChar.charCodeAt(0)))) {
        // this is where we don't split the line at the cursor, but just insert a new line
        // setting strIndex to theLine.length does that
        // the wasWasDelete is so you can hit backspace and then return
        strIndex = theLine.length
        // get the smaller indent
        var theNextIndent = getIndent(fx.lines[fx.cursorLineIndex + 1] || "")
        theIndent = max(theIndent, theNextIndent)
    }
    fx.lines.splice(fx.cursorLineIndex + 1, 0, theIndent + theLine.substr(strIndex))
    adjustHighlightRanges(fx.cursorLineIndex + 1, 1)
    if (closeCurly && (prevChar in closingMap) && (nextChar == closingMap[prevChar])) {
        theIndent += "    "
        fx.lines.splice(fx.cursorLineIndex + 1, 0, theIndent)
        adjustHighlightRanges(fx.cursorLineIndex + 1, 1)
    }
    // fx.lines[fx.cursorLineIndex] = theLine.substr(0, strIndex)
    updateLine(fx.cursorLineIndex, theLine.substr(0, strIndex))
    fx.cursorLineIndex += 1
    fx.cursorColIndex = expandTabIndex(fx.lines[fx.cursorLineIndex], theIndent.length)
    updateCursorXY()
    ensureCursorInScreen()
    docChanged()
    render()
    renderTheText(fx.lines[fx.cursorLineIndex])
}


function getDirOfFile() {
    if (fx.fileMode == "directory") {
        return fx.fullPath.split("/").join("/")
    }
    return fx.fullPath.split("/").slice(0, -1).join("/")
}
function uploadFile(e) {
    e.preventDefault()
    let formData = new FormData();
    formData.append("thedirectory", getDirOfFile());
    for (var i=0; i<filesToUpload.files.length; i++) {
        formData.append("thefiles", filesToUpload.files[i]);
    }
    fetch(proxyPath + '/myuploadfiles', {
        method: "POST", body: formData
    }).then(() => {
        alert("done uploading")
    }).catch(e => {
        alert("error uploading files:" + e)
    })
    return false
}
function uploadBlob(blob, filename) {
    let formData = new FormData();
    formData.append("thedirectory", getDirOfFile());
    formData.append("thefiles", blob, filename);
    return fetch(proxyPath + '/myuploadfiles', {
        method: "POST", body: formData
    }).then(() => {
        alert("done uploading blob")
    }).catch(e => {
        alert("error uploading blob:" + e)
    })
}

// See other places where we simply splice an empty string 
// like when calling chatGPT
function newLine(e, shouldFocus) {
    var theLine = fx.lines[fx.cursorLineIndex]
    e && e.preventDefault()
    if (fx.fileMode == "shell") {
        runShellCommand(theLine)
        return false
    } else if (fx.fileMode == "terminal") {
        // this is handled somewhere else
        // see handleKeydown
    }
    // insertLine(false, true) // this one just makes a new line
    insertLine(true, true) 
    if (shouldFocus) {
        theText.focus()
        //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
        setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
    }
    return false
}

function runQuickShellCommand(cmdString, cb) {
    fetch(proxyPath + "/myquickshell?cwd="+encodeURIComponent(getDefaultCWD(fx))+"&cmd="+encodeURIComponent(cmdString), {
        cache: "no-cache"
    }).then(r => {
        return r.text()
    }).then(r => {
        cb(null, r)
    })
}
function runShellCommand(line) {
    // outer loop to simulate goto
    if (fx.fileMode != "shell") {
        return
    }
    var oldCopyBuffer = copyBuffer
    for (var s=0; s<1; s++) {
        // ""supposebly" in non interactive mode this will get into some weird loop and use all the memory
        var trimmedLine = line.trim() 
        if (trimmedLine.startsWith("git") && trimmedLine.match(/\s-p\b/) && (trimmedLine.indexOf(" log ") == -1 && trimmedLine.indexOf(" show ") == -1)) {
            copyBuffer = ["run this in terminal (xterm button), not non-interactive shell", ""]
            paste(true)
            fx.cursorLineIndex = fx.lines.length - 1
            updateCursorXY()
            ensureCursorInScreen()
            copyBuffer = oldCopyBuffer
            break
        }
        if (line == "clear") {
            // clear everything but the last 2 lines
            // TODO: should we be using set lines here?
            setLines(fx.lines.slice(-4))
            if (fx.lines.length == 0) {
                setLines([""])
            }
            fx.cursorLineIndex = 0
            fx.cursorColIndex = 0
            updateCursorXY()
            // fx.offsetY = -minSpaceForHeader
            fx.offsetY = 0
            // render()
            // return
            line = "p"
        }

        if (line.startsWith("open ")) {
            var fileToLoad = line.split(" ")[1]
            copyBuffer = [""]
            paste(true)
            fx.cursorLineIndex += 1
            fx.cursorColIndex = 0
            ensureCursorInScreen()
            // TODO: get rid of rootLocation stuff. I am pretty sure it's not used at least on front end
            addFile(doTrimPrefix(fx.shellCWD, rootLocation) + "/" + fileToLoad)
            break
        }

        if (line == "p") {
            // TODO: should we be restoring the old copyBuffer here?
            copyBuffer = shellHelpers.concat([
                // Adding the cwd here because it's helpful
                fx.shellCWD
                    .split("/")
                    .reverse()
                    .join(" < ")
            ])
            paste(true)
            fx.cursorLineIndex = fx.lines.length - 2

            fx.cursorColIndex = 0
            updateCursorXY()
            ensureCursorInScreen()
            break
        }

        let myFx = fx
        // fetch(proxyPath + "/myshell?id="+fx.ID+"&cwd="+encodeURIComponent(fx.shellCWD)+"&cmd="+encodeURIComponent(line), {
        fetch(proxyPath + "/myshell?id="+fx.ID+"&cwd="+encodeURIComponent(fx.shellCWD), {
            cache: "no-cache",
            method: "POST",
            headers: { "Content-Type": "application/x-www-form-urlencoded"},
            body: "cmd="+encodeURIComponent(line)
        }).then(r => {
            if (r.headers.get("X-ID")) {
                myFx.ID = r.headers.get("X-ID") - 0
            }
            return r.text()
        }).then(r => {
            var oldFx = fx
            fx = myFx
            copyBuffer = r.split("\n")
            copyBuffer.unshift("") // leading newline
            // second to last item is cwd
            myFx.shellCWD = copyBuffer[copyBuffer.length - 2]
            // let's restyle the pwd after we grab it

            // TODO: maybe come up with something more elegant than this paste dance
            copyBuffer[copyBuffer.length - 2] = myFx.shellCWD
                .split("/")
                .reverse()
                .join(" < ")
            copyBuffer.push(line) // add the line so it's easy to run again.
            copyBuffer.push("")
            myFx.cursorColIndex = 0
            myFx.cursorLineIndex += copyBuffer.length
            myFx.cursorLineIndex = myFx.lines.length - 1
            selectMode = "line"
            paste(true)
            myFx.cursorLineIndex = myFx.lines.length - 1
            updateCursorXY()
            ensureCursorInScreen()
            copyBuffer = oldCopyBuffer
            fx = oldFx
        }).catch(e => {
            alert("There was an error running the command: " + e)
        })
    }
    copyBuffer = oldCopyBuffer
}
function saveName(name) {
    fetch(proxyPath + "/myname?id="+fx.ID+"&name=" + encodeURIComponent(name), {cache: "no-cache"})
    .then(r => r.json())
    .then(r => {})
    .catch(r => {})
    fx.name = name
    renderFileDropdown()
}

function handleChatGPTResponse(file, responses) {
    // data: {"id":"chatcmpl-6pgqSqpWR1pXp8gZkqfKru6KLnSgH","object":"chat.completion.chunk","created":1677777444,"model":"gpt-3.5-turbo-0301","choices":[{"delta":{"role":"assistant"},"index":0,"finish_reason":null}]}
    // data: {"id":"chatcmpl-6pgqSqpWR1pXp8gZkqfKru6KLnSgH","object":"chat.completion.chunk","created":1677777444,"model":"gpt-3.5-turbo-0301","choices":[{"delta":{"content":"Ah"},"index":0,"finish_reason":null}]}
    // data: {"id":"chatcmpl-6pgqSqpWR1pXp8gZkqfKru6KLnSgH","object":"chat.completion.chunk","created":1677777444,"model":"gpt-3.5-turbo-0301","choices":[{"delta":{"content":"oy"},"index":0,"finish_reason":null}]}
    // data: {"id":"chatcmpl-6pgqSqpWR1pXp8gZkqfKru6KLnSgH","object":"chat.completion.chunk","created":1677777444,"model":"gpt-3.5-turbo-0301","choices":[{"delta":{"content":" there"},"index":0,"finish_reason":null}]}

    // data: {"id":"chatcmpl-6pgqSqpWR1pXp8gZkqfKru6KLnSgH","object":"chat.completion.chunk","created":1677777444,"model":"gpt-3.5-turbo-0301","choices":[{"delta":{"content":" at"},"index":0,"finish_reason":null}]}
    // data: {"id":"chatcmpl-6pgqSqpWR1pXp8gZkqfKru6KLnSgH","object":"chat.completion.chunk","created":1677777444,"model":"gpt-3.5-turbo-0301","choices":[{"delta":{"content":" sea"},"index":0,"finish_reason":null}]}
    // data: {"id":"chatcmpl-6pgqSqpWR1pXp8gZkqfKru6KLnSgH","object":"chat.completion.chunk","created":1677777444,"model":"gpt-3.5-turbo-0301","choices":[{"delta":{"content":"."},"index":0,"finish_reason":null}]}
    // data: {"id":"chatcmpl-6pgqSqpWR1pXp8gZkqfKru6KLnSgH","object":"chat.completion.chunk","created":1677777444,"model":"gpt-3.5-turbo-0301","choices":[{"delta":{},"index":0,"finish_reason":"stop"}]}
    // data: [DONE]
    
    // I really only care about choices[0].delta.content
    var oldCopyBuffer = copyBuffer
    var lineBuffer = []
    for (var i=0; i<responses.length; i++) {
        var content = ""
        try {
           var response = JSON.parse(responses[i])
           content = response.choices[0].delta.content
        } catch (e) {
           content = responses[i]
           if (content == "[DONE]") {
               gptButton.innerText = gptButton.oldInnerText
               gptButton.oldInnerText = ""
               docChanged()
               continue
           }
        }
        if (content) {
            content = content.replace(/\n/g, "\n" + fx.chatGPTIndent);
            var contentLines = content.split("\n");

            for (var j=0; j<contentLines.length; j++) {
                var subContent = contentLines[j]
                lineBuffer.push(subContent)
                // if (j >= 1 && (j != 2 || j < contentLines.length - 1)) {
                if (j < contentLines.length - 1) {
                    updateLineFile(file, file.chatGPTCursorLineIndex, file.lines[file.chatGPTCursorLineIndex] + lineBuffer.join(""))
                    lineBuffer = []
                    file.lines.splice(file.chatGPTCursorLineIndex+1, 0, "")
                    file.chatGPTCursorLineIndex++
                }
            }
            // copyBuffer = [content]
            // paste()
        }
    }
    if (lineBuffer.length) {
        updateLineFile(file, file.chatGPTCursorLineIndex, file.lines[file.chatGPTCursorLineIndex] + lineBuffer.join(""))
    }
    render()
    copyBuffer = oldCopyBuffer
}
var allowPolling = true
var isPollingTerminal = false
var lastPolled = null
var lastAborted = null
var lastPollResponse = null
var lastPollError = null
var pollInFlight = null
// allow hangups and newSession



function processPollResponse(wrapperR) {
    // map of terminals and their payload and maybe meta info
    if (wrapperR.PasteBuffer) {
        copyBuffer = wrapperR.PasteBuffer.split("\n")
    }
    var r = wrapperR.Files
    for (var id in r) {
        var termInfo = r[id]
        var file = files.find(f => f.ID == id)
        var lineLengthBeforeChange = file.lines.length
        if (!file) {
            // TODO: this can happen if we get the response for
            // the poll before we even have the ID
            // we could store these values temporarily?
            // but for now we'll ignore them.
            continue
        }
        if (termInfo.ChatGPTResponses && termInfo.ChatGPTResponses.length) {
            handleChatGPTResponse(file, termInfo.ChatGPTResponses)
        }
        if (termInfo.FileErrors) {
            // reset them all
            file.fileErrors = termInfo.FileErrors
            render()
        }
        if (!termInfo.Base64) {
            continue
        }
        var oldCopyBuffer = copyBuffer
        // btoa("hello")
        // atob("aGVsbG8=")
        // #todoterminal: add xterm parsing here!
        processTerminal(termInfo.Base64, file)
        // don't move the cursor if they are looking up higher in the file
        if (file.cursorLineIndex >= (lineLengthBeforeChange - 1)) {
            file.cursorLineIndex = file.lines.length - 1
            var theLine = file.lines[file.lines.length-1]
            if (theLine != "") {
                file.cursorColIndex = expandTabIndex(theLine, theLine.length, file.lines.length-1, file)
            } else {
                theLine = file.lines[file.lines.length-2] || ""
                file.cursorColIndex = expandTabIndex(theLine, theLine.length, file.lines.length-2, file)
            }
            ensureCursorInScreen(file, true)
        }

    }
    render()
    setTimeout(pollTerminals, 1)
}


// function processTerminal(theBase64, file) {
//     var strToProcess = atob(theBase64)
//     log(strToProcess)
//     log(JSON.stringify(strToProcess))
//     // simple parsing for now
// 
//     // TODO: what if the chunk we get ends on a control character.
//     // Maybe we need to preserve the parseState to the file object.
//     var parseState = "literal"
//     var controlValues = [""]
//     var lineBuffer = []
//     for (var i = 0; i < strToProcess.length; i++) {
//         log(["looping", i, strToProcess.length])
//         // not calling docChanged because we don't care for terminals
//         var theChr = strToProcess[i]
//         switch (parseState) {
//             case "literal":
//                 if (strToProcess[i] == "\n") {
//                     updateLineFile(file, file.lines.length-1, file.lines[file.lines.length-1] + lineBuffer.join(""))
//                     lineBuffer = []
//                     file.lines.push("")
//                     file.marginLeft = calcMarginLeft(file.lines.length)
//                 // for  now commenting out \r, later do I need to code the difference between newline and carriage return?
//                 } else if (strToProcess[i] == "\r") {
//                     // file.lines.push("")
//                     // do nothing for now
//                 } else if (strToProcess[i] == "\b") {
//                     // copied from another part of this code // == 8
//                     var theLine = file.lines[file.cursorLineIndex]
//                     if (theLine.length == 0) {
//                         file.lines.splice(file.cursorLineIndex, 1)
//                         adjustHighlightRanges(file.cursorLineIndex, -1, file)
//                         file.cursorLineIndex -= 1
//                         var prevLine = file.lines[file.cursorLineIndex]
//                         // file.lines[file.cursorLineIndex] = file.lines[file.cursorLineIndex] + theLine
//                         updateLineFile(file, file.cursorLineIndex, file.lines[file.cursorLineIndex] + theLine)
//                         // TODO: process the index here!!!
//                         file.cursorColIndex = prevLine.length
//                         setSelectionRangeForText(prevLine.length, prevLine.length)
//                     } else {
//                         // file.lines[file.lines.length-1] = theLine.slice(0, -1)
//                         updateLineFile(file, file.lines.length-1, theLine.slice(0, -1))
//                     }
//                 } else if (strToProcess[i] == "\x1b") { // escape
//                     parseState = "ESC"
//                 } else if (strToProcess[i] == "\x07") { // bell
//                     // do nothing
//                 } else {
//                     // Todo: look at how the \b works with lineBuffer. May be more optimal to do it that way.
//                     lineBuffer.push(strToProcess[i])
//                 }
//                 break;
//             case "ESC":
//                 switch (theChr) {
//                     case "[":
//                         controlValues = [""]
//                         parseState = "CSI"
//                         break;
//                     default:
//                         parseState = "literal" // for now
// 
//                 }
//                 break;
//             case "CSI":
//                 switch (theChr) {
//                     case "0":
//                         controlValues[controlValues.length-1] += theChr
//                         break;
//                     case "1":
//                         controlValues[controlValues.length-1] += theChr
//                         break;
//                     case "2":
//                         controlValues[controlValues.length-1] += theChr
//                         break;
//                     case "3":
//                         controlValues[controlValues.length-1] += theChr
//                         break;
//                     case "4":
//                         controlValues[controlValues.length-1] += theChr
//                         break;
//                     case "5":
//                         controlValues[controlValues.length-1] += theChr
//                         break;
//                     case "6":
//                         controlValues[controlValues.length-1] += theChr
//                         break;
//                     case "7":
//                         controlValues[controlValues.length-1] += theChr
//                         break;
//                     case "8":
//                         controlValues[controlValues.length-1] += theChr
//                         break;
//                     case "9":
//                         controlValues[controlValues.length-1] += theChr
//                         break;
//                     case ";":
//                         controlValues.push("")
//                         break;
//                     case "K":
//                         // TODO: clear parts of line according to rules
//                         parseState = "literal"
//                         break;
//                     default:
// 
//                         parseState = "literal" // for now
// 
//                 }
//                 break;
//         }
//     }
//     if (lineBuffer.length) {
//         updateLineFile(file, file.lines.length-1, file.lines[file.lines.length-1] + lineBuffer.join(""))
//     }
// }


// Please finish handling terminal commanda
// you don't need to actually implement all things, just have a placeholder and comments
// for how to respond to all cases, but keep the existing handling there.
// add any more comments you want.
// Prefix your comments with "// AI:" to differentiate them from my comments.
// 
// Here‚Äôs an expanded version of your `processTerminal` function. I‚Äôve left your existing logic intact, added placeholders for all the common CSI and ESC sequences you‚Äôll likely need, and prefixed my comments with `// AI:`. Feel free to fill in the stubs with your real implementations later.
// 
// ```javascript
function processTerminal(theBase64, file) {
    var strToProcess = atob(theBase64)
    // log(strToProcess)
    // log(JSON.stringify(strToProcess))
    // simple parsing for now

    // TODO: what if the chunk we get ends on a control character.
    // Maybe we need to preserve the parseState to the file object.
    var parseState = "literal"
    var controlValues = [""]
    var lineBuffer = []
    let privateMode = false;
    let carriagePos = 0;

    for (var i = 0; i < strToProcess.length; i++) {
        var theChr = strToProcess[i]
        switch (parseState) {
            case "literal":
                if (theChr == "\n") {
                    updateLineFile(file, file.lines.length - 1,
                                   file.lines[file.lines.length - 1] + lineBuffer.join(""))
                    lineBuffer = []
                    file.lines.push("")
                    file.marginLeft = calcMarginLeft(file.lines.length)

                } else if (theChr == "\r") {
                    // file.lines.push("")
                    // AI: carriage return - could reset cursor to col 0
                    // handleCarriageReturn()
                    carriagePos = 0
                } else if (theChr == "\b") {
                    if (lineBuffer.length) {
                        lineBuffer = lineBuffer.slice(0, -1)
                    } else {
                        // copied from another part of this code // == 8
                        var theLine = file.lines[file.cursorLineIndex]
                        if (theLine.length == 0) {
                            file.lines.splice(file.cursorLineIndex, 1)
                            adjustHighlightRanges(file.cursorLineIndex, -1, file)
                            file.cursorLineIndex -= 1
                            var prevLine = file.lines[file.cursorLineIndex]
                            updateLineFile(file, file.cursorLineIndex,
                                           file.lines[file.cursorLineIndex] + theLine)
                            file.cursorColIndex = prevLine.length
                            setSelectionRangeForText(prevLine.length, prevLine.length)
                        } else {
                            updateLineFile(file, file.lines.length - 1,
                                           theLine.slice(0, -1))
                        }
                    }
                    carriagePos = file.lines[file.cursorLineIndex].length
                } else if (theChr == "\x1b") { // ESC
                    parseState = "ESC"
                    // AI: entering escape sequence

                } else if (theChr == "\x07") { // BEL
                    // do nothing
                    // AI: you might flash terminal or play a sound

                } else {
                    lineBuffer.push(theChr)
                }
                break

            case "ESC":
                switch (theChr) {
                    case "[":
                        controlValues = [""]
                        parseState = "CSI"
                        privateMode   = false;      // reset for each new CSI
                        break
                    case "]":
                        // AI: OSC (Operating System Command)
                        // stub: handleOSC(the following data until BEL or ESC '\\')
                        parseState = "OSC"
                        // AI: collect characters for OSC
                        break
                    case "7":
                        // AI: DECSC - Save cursor
                        // stub: saveCursorPosition()
                        parseState = "literal"
                        break
                    case "8":
                        // AI: DECRC - Restore cursor
                        // stub: restoreCursorPosition()
                        parseState = "literal"
                        break
                    case "(":
                        // AI: Select G0 character set
                        // stub: selectCharsetG0(nextChar)
                        parseState = "charsetG0"
                        break
                    case ")":
                    case "*":
                    case "+":
                        // AI: Other charset invocations
                        parseState = "charset"
                        break
                    default:
                        // AI: unhandled ESC sequence, drop it
                        parseState = "literal"
                }
                break

            case "CSI":
                // AI: Control Sequence Introducer
                if (theChr === "?") {
                    // remember that this is a DEC private‚Äêmode sequence
                    privateMode = true;
                } else if (theChr >= "0" && theChr <= "9") {
                    controlValues[controlValues.length - 1] += theChr
                } else if (theChr == ";") {
                    controlValues.push("")
                } else {
                    if (privateMode && (theChr === "h" || theChr === "l")) {
                      // DECSET (h) / DECRST (l)
                      const enable = (theChr === "h");
                      controlValues.forEach(param => {
                        switch (param) {
                          case "2004":
                            // bracketed‚Äêpaste mode
                            // this.bracketedPaste = enable;
                            break;
                          // you can add more DEC private modes here:
                          // case "25":  // cursor on/off
                          // case "?7":  // wraparound mode
                          // ‚Ä¶
                          default:
                            // log(`Unhandled DEC private mode ?${param}${theChr}`);
                        }
                      });
                    } else {
                        // final byte of CSI
                        switch (theChr) {
                            case "A":
                                // Cursor Up
                                // stub: cursorUp(parseInt(controlValues[0]||1))
                                break
                            case "B":
                                // Cursor Down
                                // stub: cursorDown(parseInt(controlValues[0]||1))
                                break
                            case "C":
                                // Cursor Forward
                                // stub: cursorForward(parseInt(controlValues[0]||1))
                                break
                            case "D":
                                // Cursor Backward
                                // stub: cursorBackward(parseInt(controlValues[0]||1))
                                break
                            case "E":
                                // Cursor Next Line
                                // stub: cursorNextLine(parseInt(controlValues[0]||1))
                                break
                            case "F":
                                // Cursor Previous Line
                                // stub: cursorPrevLine(parseInt(controlValues[0]||1))
                                break
                            case "G":
                                // Cursor Horizontal Absolute
                                // stub: cursorToColumn(parseInt(controlValues[0]||1))
                                break
                            case "H":
                            case "f":
                                // Cursor Position
                                // stub: cursorPosition(parseInt(controlValues[0]||1), parseInt(controlValues[1]||1))
                                break
                            case "J":
                                // Erase in Display
                                // stub: eraseInDisplay(parseInt(controlValues[0]||0))

                                let parameter = controlValues[0]||0
                                if (parameter == 0) {
                                    // hack but seems to work
                                    lineBuffer = []
                                    // updateLineFile(file, file.lines.length - 1, theLine.slice(0, cursorPosition))
                                }
                                break
                            case "K":
                                // Erase in Line
                                // stub: eraseInLine(parseInt(controlValues[0]||0))
                                break
                            case "m":
                                // Character Attributes (SGR)
                                // stub: setGraphicsRendition(controlValues.map(Number))
                                break
                            case "s":
                                // Save Cursor (DECSC)
                                // stub: saveCursorPosition()
                                break
                            case "u":
                                // Restore Cursor (DECRC)
                                // stub: restoreCursorPosition()
                                break
                            // AI: add any other CSI final bytes you need, e.g. 'r', 'h', 'l'
                            default:
                                // AI: unhandled CSI code: log or ignore
                                // log("Unhandled CSI " + theChr + " params: " + controlValues.join(";"))
                        }
                    }
                    parseState = "literal"
                }
                break

            // what about handling the [?2004h here?
            // This will properly handle [?2004h (turn on) and [?2004l (turn off), and gives you

            case "OSC":
                // AI: collect until BEL (\x07) or ESC '\'
                if (theChr == "\x07") {
                    // stub: handleOSCCommand(oscBuffer)
                    parseState = "literal"
                } else if (theChr == "\x1b") {
                    // maybe ESC \ sequence terminator
                    parseState = "OSC_ESC"
                } else {
                    // AI: accumulate OSC characters
                    // oscBuffer.push(theChr)
                }
                break

            case "OSC_ESC":
                if (theChr == "\\") {
                    // end of OSC
                    // stub: handleOSCCommand(oscBuffer)
                }
                parseState = "literal"
                break

            case "charsetG0":
                // AI: G0 charset selection done
                // stub: applyG0Charset(theChr)
                parseState = "literal"
                break

            case "charset":
                // AI: other charset selection done
                // stub: applyCharset(parseState, theChr)
                parseState = "literal"
                break

            default:
                // AI: should not reach here
                parseState = "literal"
        }
    }

    if (lineBuffer.length) {
        updateLineFile(file, file.lines.length - 1,
                       file.lines[file.lines.length - 1] + lineBuffer.join(""))
       carriagePos = file.lines[file.lines.length - 1].length
    }
}
// ```

// Feel free to flesh out the `stub:` calls with real implementations. The `// AI:` comments indicate where and how each sequence should
// 
// Thank you, does any of this handle terminal colors?
// 
// The short answer is: not yet‚Äîin the snippet above colors live behind the CSI ‚Äúm‚Äù (SGR) handler, but we left that as a stub. Everything you need for colors comes in as numbers in your `controlValues` array when you hit the final byte ‚Äúm‚Äù. At that point you interpret codes like:
// 
//   ‚Ä¢ 0   ‚Üí reset all attributes  
//   ‚Ä¢ 1   ‚Üí bold  
//   ‚Ä¢ 4   ‚Üí underline  
//   ‚Ä¢ 30‚Äì37 ‚Üí set foreground color (black, red, green, ‚Ä¶, white)  
//   ‚Ä¢ 40‚Äì47 ‚Üí set background color  
//   ‚Ä¢ 90‚Äì97 ‚Üí bright foreground colors  
//   ‚Ä¢ 100‚Äì107 ‚Üí bright background colors  
// 
// Here‚Äôs a quick sketch of how you might flesh out `setGraphicsRendition()` to actually apply colors. You‚Äôll need to decide how you track ‚Äúcurrent text style‚Äù (e.g. an attribute object attached to each character, or wrapping spans in your UI, etc.):
// 
// ```javascript
// // AI: stub for SGR (Select Graphic Rendition) ‚Äì i.e. colors, bold, underline, etc.
// function setGraphicsRendition(params) {
//   // AI: params is an array of numbers, e.g. [ '1', '31' ] ‚Üí [1, 31]
//   var codes = params.map(function(p) { return Number(p) || 0 });
//   codes.forEach(function(code) {
//     switch (code) {
//       case 0:
//         // AI: reset all styles to default
//         currentStyle = { fg: null, bg: null, bold: false, underline: false };
//         break;
// 
//       case 1:
//         currentStyle.bold = true;
//         break;
//       case 4:
//         currentStyle.underline = true;
//         break;
// 
//       // AI: foreground colors
//       case 30: case 31: case 32: case 33:
//       case 34: case 35: case 36: case 37:
//         currentStyle.fg = code - 30;  // map 30‚Üí0(black), 31‚Üí1(red),...
//         break;
// 
//       // AI: background colors
//       case 40: case 41: case 42: case 43:
//       case 44: case 45: case 46: case 47:
//         currentStyle.bg = code - 40;
//         break;
// 
//       // AI: bright foregounds
//       case 90: case 91: case 92: case 93:
//       case 94: case 95: case 96: case 97:
//         currentStyle.fg = code - 90 + 8; // extended to bright palette
//         break;
// 
//       // AI: bright backgrounds
//       case 100: case 101: case 102: case 103:
//       case 104: case 105: case 106: case 107:
//         currentStyle.bg = code - 100 + 8;
//         break;
// 
//       // AI: more SGR codes (e.g. italics 3, strike 9, inverse 7, etc.) go here
//       default:
//         console.log("Unhandled SGR code:", code);
//     }
//   });
// }
// 
// // Then in CSI final-byte "m" handler:
// case "m":
//   setGraphicsRendition(controlValues);
//   break;
// ```
// 
// How you actually *render* that depends on your editor/terminal widget:
// 
//   ‚Ä¢ If you‚Äôre building HTML, you might wrap your `lineBuffer` contents in `<span>` tags with appropriate CSS classes for fg/bg/bold, and then flush them to the DOM.
// 
//   ‚Ä¢ If you have a more structured text model, you could store each character with an attribute object `{char, style}`.
// 
// Bottom line: everything for colors flows through the CSI ‚Äúm‚Äù branch. You just need to implement `setGraphicsRendition()` (or whatever you name it) to map SGR codes to your renderer‚Äôs color/bold/underline/etc. system.


// this abortcontroller snippet needed for me since ios18
// if the homescreen app was backgrounded for like 1 minuye
// the current fetch request for polling would hang
// it would eventually work but this helps it along
var abortController = new AbortController()
document.addEventListener("visibilitychange", () => {
    if (document.visibilityState === "visible") {
        // log2Pre(new Date(), "aborting")
        log("a: " + new Date().toLocaleTimeString())
        lastAborted = new Date()
        abortController.abort()
        abortController = new AbortController()
        render()
    }
});

function timeWithMillis() {
    var d = new Date()
    return `${d.toLocaleTimeString()}.${d.getMilliseconds()}`
}
var pollId = 0
function pollTerminals() {
    // log("p: " + timeWithMillis())
    pollId++
    // showLog(true)
    // log2Pre(new Date(), pollId, "pollTerminals")
    lastPolled = new Date()
    lastPollResponse = null
    lastPollError = null
    render()
    if (!allowPolling) {
        // so we can manually disable polling
        return false
    }
    isPollingTerminal = true
    // because of ChatGPT
    // if (!files.some(f => f.fileMode == "terminal")) {
    //     isPollingTerminal = false
    //     return
    // }
    pollInFlight = true
    fetch(proxyPath + "/myterminalpoll?clientid=" + clientId, {
        cache: "no-cache",
        signal: abortController.signal
    }).then(r => {
        return r.json()
    }).then(wrapperR => {
        // log("r: " + timeWithMillis())
        // log2Pre(new Date(), pollId, "successPoll")
        pollInFlight = false
        lastPollResponse = new Date()
        render()
        processPollResponse(wrapperR)
    }).catch(e => {
        log("e: " + timeWithMillis())
        // log2Pre(new Date(), pollId, "failPoll")
        // todo: does an error in the prev block also go here
        // if so we need to make sure we don't double poll
        // as a double check, in the polling code if there id a request
        // in-flight, don't poll again.
        // alert("polling error: " + e)
        lastPollError = new Date()
        pollInFlight = false
        render()
        setTimeout(pollTerminals, 1)
    })
}

function callAllAndClear(cbs) {
    return function(err) {
        for (var i=0; i<cbs.length; i++) {
            cbs[i](err)
        }
        cbs.splice(0, cbs.length)
    }
}
function rerunTerminal() {
    // could convert to await
    
    // ctrl-C
    sendTerminal("\x03", function() {
        clearLog()
        // up arrow
        sendTerminal("\x1b[A", function() {
            // this hits enter (weird naming)
            saveWrapper()
        })
    })
}

// inconsistency with promosies and callbacks would be cool to *resolve* ;)
function sendTerminalFile(file, payload) {
    var resolve; var reject; var p = new Promise(function(res, rej) { resolve = res; reject = res });
    var oldFx = fx
    fx = file
    sendTerminal(payload, function (err) {
        if (err) {
            reject(err)
            return
        }
        resolve()
    })
    fx = oldFx
    return p
}

var sendingTerminal = false
var sendTerminalBuffer = ""
var sendTerminalCallbacks = []
function sendTerminal(payload, cb) {
    if (sendingTerminal) {
        sendTerminalBuffer += payload
        sendTerminalCallbacks.push(cb)
        return
    }
    // big TODO (#todoterminal)...  serialize, consider debounce.
    // make sure we only have one of these going at a time
    // also, binary payload?
    sendingTemrinal = true
    fetch(proxyPath + "/myterminalsend?id=" + fx.ID + "&payload=" + encodeURIComponent(payload), {
        cache: "no-cache"
    // }).then(r => {
    //     return r.json()
    }).then(r => {
        sendingTemrinal = false
        if (sendTerminalBuffer.length) {
            var tmp = sendTerminalBuffer
            sendTerminalBuffer = ""
            sendTerminal(tmp, callAllAndClear(sendTerminalCallbacks))
        }
        cb()
    }).catch(e => {
        sendingTemrinal = false
        if (sendTerminalBuffer.length) {
            var tmp = sendTerminalBuffer
            sendTerminalBuffer = ""
            sendTerminal(tmp, callAllAndClear(sendTerminalCallbacks))
        }
        cb(e)
        alert("There was an error sending terminal: " + e)
    })
}
function openTerminal() {
    var resolve; var reject; var p = new Promise(function(res, rej) { resolve = res; reject = res });
    
    if (fx.fileMode != "terminal") {
        return
    }
    if (!isPollingTerminal) {
        pollTerminals()
    }
    var myFx = fx // in case the scope changes
    fetch(proxyPath + "/myterminalopen?cwd="+encodeURIComponent(fx.shellCWD), {
        cache: "no-cache"
    }).then(r => {
        return r.json()
    }).then(r => {
        myFx.ID = r.ID
        resolve()
    }).catch(e => {
        alert("There was an error running the command: " + e)
        reject()
    })
    fx.terminalLoadPromise = p
    
}
function closeFileServer(theFile) {
    if (!theFile) {
        theFile = fx
    }
    return fetch(proxyPath + "/myclose?id=" + theFile.ID, {
        cache: "no-cache"
    // }).then(r => {
    //     return r.json()
    })
}
function stopServer() {
   fetch(proxyPath + "/stop", {
        cache: "no-cache",
        method: "POST",
        headers: {},
        body: "",
   }).then(r => {
   }).catch(e => {
   })
}

function doTrimPrefix(str, prefix) {
    if (str.startsWith(prefix)) {
        return str.slice(prefix.length)
    }
    return str
}

function setSelectionRangeForText(start, end) {
    var adjustedStart = u(start)
    var adjustedEnd
    if (start == end) {
        adjustedEnd = adjustedStart
    } else {
        adjustedEnd = u(end)
    }
    theText.setSelectionRange(adjustedStart, adjustedEnd)
}

function unExpandSlice(theLine, start, end, index, file) {
    theLine = theLine || ""
    var adjustedStart = unExpandTabIndex(theLine, start, index, file)
    if (typeof end == "undefined" || end == -1) {
        return theLine.slice(adjustedStart)
    }
    var adjustedEnd = unExpandTabIndex(theLine, end, index, file)
    return theLine.slice(adjustedStart, adjustedEnd)
}

var globalTabStop = 4
function toggleTabStop() {
    switch (globalTabStop) {
        case 2:
            globalTabStop = 4
            break;
        case 4:
            globalTabStop = 8
            break;
        case 8:
            globalTabStop = 16
            break;
        case 16:
            globalTabStop = 32
            break;
        case 32:
            globalTabStop = 2
            break;
    }
    toggleTabStopButton.innerText = globalTabStop + " tabs"
    render()
}
var shouldSeeTabs = false
function toggleSeeTabs() {
    shouldSeeTabs = !shouldSeeTabs
    render()
}

var eqCount = 0
function eq(a, b, message) {
    eqCount++
    if (a != b) {
        alert("unequal at number " + eqCount + ".\ngot: " + b + "\nwant: " + a + "\nmessage: " + message )
        window.close()
    }
}

var emojiRegex = /\p{Extended_Pictographic}/u;
function containsEmoji(line) {
    return emojiRegex.test(line)
}
function isEmoji(grapheme) {
    if (grapheme.length == 1 && grapheme.charCodeAt(0) < 256) {
       return false
    }
    // over simplified attempt to Make it faster, but not 100% accurate
    // if (grapheme.length > 1) {
    //     return true
    // }
    
    return containsEmoji(grapheme)
}
function unExpandTabIndexNoCache(theLine, start) {
    return unExpandTabIndex(theLine, start, null, null, "nocache")
}
// go from graphical index to string index, at graphical index
function unExpandTabIndex_old(theLine, start, index, file, nocache) {
    // small todo: why is this called every touchend when not in edit mode?
    // prob a good reason, I just don't know
    var tabStop = globalTabStop

    if (useUnicode) {
        var actualStringIndex = 0
        var expandedIndex = 0
        var newActualStringIndex = 0
        var newExpandedIndex = 0
        var expandedLine = getCachedGraphemes(theLine, index, file, nocache)
        var i = 0
        while (true) {
            if (i >= expandedLine.length) {
                break
            }
            if (i === 100000) {
                alert("loop err 1")
                break
            }
            // ab‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢y
            var grapheme = expandedLine[i]
            if (grapheme == "\t") {
                // newExpandedIndex = expandedIndex + (tabStop - ((expandedIndex) % tabStop)) + 1
                newExpandedIndex = expandedIndex + (tabStop - ((expandedIndex) % tabStop))
                newActualStringIndex = actualStringIndex + 1
            } else {
                if (isEmoji(grapheme)) {
                    newExpandedIndex = expandedIndex + emojiWidth
                } else {
                    newExpandedIndex = expandedIndex + 1
                }
                newActualStringIndex = actualStringIndex + grapheme.length
            }
            if (newExpandedIndex > start) {
                return actualStringIndex
            }
            expandedIndex = newExpandedIndex
            actualStringIndex = newActualStringIndex
            i++
        }

        return newActualStringIndex
    }

    var lastTabPos = -1
    var netSpacesAdded = 0
    var expandedLineLength = 0
    while (true) {
        tabPos = theLine.indexOf("\t", lastTabPos + 1)
        if (tabPos == -1) {
            expandedLineLength += theLine.length - (lastTabPos + 1)
            break
        }
        expandedLineLength += tabPos - (lastTabPos + 1)
        if (expandedLineLength > start) {
            break
        }
        var numberOfSpaces = tabStop - (expandedLineLength % tabStop)
        if ((expandedLineLength + numberOfSpaces) > start) {
            netSpacesAdded += (start - expandedLineLength)
            break
        }
        expandedLineLength += numberOfSpaces

        netSpacesAdded += numberOfSpaces - 1 // subtract 1 because of the actual tab
        lastTabPos = tabPos
    }
    var adjustedStart = start - netSpacesAdded
    return adjustedStart
}
function u(start) {
    var theLine = fx.lines[fx.cursorLineIndex] || ""
    return unExpandTabIndex(theLine, start)
}

function expandTabIndexNoCache(theLine, start) {
    return expandTabIndex(theLine, start, null, null, "nocache")
}
// go from string index to graphical index, at string index
function expandTabIndex_old(theLine, start, index, file, nocache) {
    // todo: This is called every scroll, even if you don't go to another letter.
    theLine = theLine || ""
    var origLine = theLine
    if (!theLine.substring) {
        var err = new Error()
        log(err.stack)
    }

    if (start == -1) {
        start = theLine.length
    } else {
        theLine = theLine.slice(0, start)
    }
    var tabStop = globalTabStop

    if (useUnicode) {
        var actualStringIndex = 0
        var expandedIndex = 0
        var newActualStringIndex = 0
        var newExpandedIndex = 0
        var expandedLine = getCachedGraphemes(origLine, index, file, nocache)
        var expandedLineLength = 0
        if (start == origLine.length) {
            expandedLineLength = expandedLine.length
        } else {
            if (start == 0) {
                expandedLineLength = 0
            } else {
                var actualLength = 0
                for (var j=0; j<expandedLine.length;j++) {
                    expandedLineLength += 1
                    actualLength += expandedLine[j].length
                    if (actualLength == start) {
                        break
                    }
                }
            }
        }
        var i = 0
        while (true) {
            if (i >= expandedLineLength) {
                break
            }
            if (i === 100000) {
                // alert("loop err 2")
                break
            }
            // ab‚Ä¢‚Ä¢y
            var grapheme = expandedLine[i]
            if (grapheme == "\t") {
                newExpandedIndex = expandedIndex + (tabStop - ((expandedIndex) % tabStop))
                newActualStringIndex = actualStringIndex + 1
            } else {
                if (isEmoji(grapheme)) {
                    newExpandedIndex = expandedIndex + emojiWidth
                } else {
                    newExpandedIndex = expandedIndex + 1
                }
                newActualStringIndex = actualStringIndex + grapheme.length
            }
            expandedIndex = newExpandedIndex
            actualStringIndex = newActualStringIndex
            i++
        }
        return expandedIndex
    }



    var expandedLineLength = 0
    var lastTabPos = -1
    var netSpacesAdded = 0
    while (true) {
        tabPos = theLine.indexOf("\t", lastTabPos + 1)
        if (tabPos == -1) {
            expandedLineLength += theLine.length - (lastTabPos + 1)
            break
        }
        expandedLineLength += tabPos - (lastTabPos + 1)
        var numberOfSpaces = tabStop - (expandedLineLength % tabStop)
        expandedLineLength += numberOfSpaces

        netSpacesAdded += numberOfSpaces - 1 // subtract 1 because of the actual tab
        lastTabPos = tabPos
    }
    var adjustedStart = start + netSpacesAdded
    return adjustedStart
}

function expandTabIndex(theLine, start, index, file, nocache) {
    if (typeof start == "undefined") {
        // we get here whe long press 1right
        // not sure why tho
        start = -1
    }
    theLine = theLine || ""
    if (!theLine.substring) {
        var err = new Error()
        log(err.stack)
    }
    if (start == -1) {
        start = theLine.length
    }

    // workaround that I might be able to handle elsewhere
    // happens when running "git commit -m" button
    var expandedLine = expandLine(theLine, index, file, nocache)
    var adjustedStart = start
    // if (adjustedStart >= theLine.length) {
    //     adjustedStart = theLine.length - 1
    // }
    if (adjustedStart >= expandedLine.expandedIndexCache.length) {
        newRet = 0
    } else {
        newRet = expandedLine.expandedIndexCache[adjustedStart]
    }
    
    // var oldRet = expandTabIndex_old(theLine, start, index, file, nocache)  
    // if (oldRet != newRet) {
    //     log({
    //         type: "exp",
    //         line: theLine,
    //         start: start,
    //         len: theLine.length,
    //         index: index,
    //         old: oldRet,
    //         new: newRet,
    //         newType: typeof newRet,
    //         expandedLine: expandedLine,
    //         expandedIndexCache: expandedLine.expandedIndexCache,
    //         adjustedStart: adjustedStart,
    //         start: start,
    //         startType: typeof start,
    //     })
    // }  
    // return oldRet 
    
    
    
    return newRet
}
function unExpandTabIndex(theLine, start, index, file, nocache) {
    var expandedLine = expandLine(theLine, index, file, nocache)
    
    var newRet
    if (start >= expandedLine.length) {
        newRet = theLine.length
    } else if (start < 0) {
        newRet = 0
    } else {
        newRet = expandedLine.unexpandedIndexCache[start]
    }
    
    // var oldRet = unExpandTabIndex_old(theLine, start, index, file, nocache)  
    // if (oldRet != newRet) {
    //     log({type: "unexp", line: theLine, start: start, len: theLine.length, index: index, old: oldRet, new: newRet})    
    // }  
    // return oldRet
    
    return newRet
}

// expandTabIndexNoCache("\t", 0) => 0
// expandTabIndexNoCache("\ta", 1)
// "\t"
	// aüß†bar
// expandTabIndexNoCache("üë®‚Äçüë©‚Äçüëß‚Äçüëß", 0)
// expandTabIndexNoCache("üë®‚Äçüë©‚Äçüëß‚Äçüëßa", 1)
// "üë®üèª".length

// var  = "\tabc"

function testStuff() {
    var theStr = "üë®üèªabcüß†üß†"
    // var theStr = "\tx\ta"
    // var theStr = "abcdefg"
    // var theStr = "‚Ä†a"

    var theStr = "    }  "
    var results = []
    for (var j=0; j<theStr.length; j++) {
        results.push(j + " => " + expandTabIndexNoCache(theStr, j))
    }
    var results2 = []
    var expandedLine = expandLineNew(theStr, undefined, undefined, "nocache")
    for (var j=0; j<expandedLine.length; j++) {
        results2.push(j + " => " + unExpandTabIndexNoCache(theStr, j))
    }
    log2([results, results2, expandedLine.expandedIndexCache, expandedLine, expandedLine.unexpandedIndexCache])
}

var emptyExpandedLine = []
emptyExpandedLine.expandedIndexCache = [0] // #pastTheEnd
emptyExpandedLine.unexpandedIndexCache = 1
function expandLine(theLine, index, file, nocache) {
    var start = Date.now()

    var expandedLine
    var tabStop = globalTabStop
    
    if (theLine.expandedLineCache) {
        return theLine.expandedLineCache
    }
    
    if (theLine == "") {
        return emptyExpandedLine
    }
    
    cachedGraphemes = getCachedGraphemes(theLine, index, file, nocache)
    var expandedLine = []
    var expandedIndex = []
    var unexpandedIndex = []
    
    for (var i=0; i<cachedGraphemes.length; i++) {
        var grapheme = cachedGraphemes[i]
        if (isEmoji(grapheme)) {
            expandedLine.push(grapheme)
            unexpandedIndex.push(expandedIndex.length)
            for (var j=0; j<emojiWidth-1; j++) {
                unexpandedIndex.push(expandedIndex.length)
            }
            for (var j=0; j<grapheme.length; j++) {
                if (j == 0) {
                    expandedIndex.push(expandedLine.length - 1)
                } else {
                    // expandedIndex.push(expandedLine.length - 1 + emojiWidth)
                    expandedIndex.push(expandedLine.length - 1)
                }
            }
            for (var j=0; j<emojiWidth-1; j++) {
                expandedLine.push(" ")
            }
        } else if (grapheme == "\t") {
            // var tabPos = expandedLine.indexOf("\t", afterLastTabPos)
            var numberOfSpaces = tabStop - (expandedLine.length % tabStop)
            expandedIndex.push(expandedLine.length)
            for (var j=0; j<numberOfSpaces; j++) {
                expandedLine.push("\t")
                unexpandedIndex.push(expandedIndex.length - 1)
            }
        } else {
            expandedLine.push(grapheme)
            unexpandedIndex.push(expandedIndex.length)
            for (var j=0; j<grapheme.length; j++) {
                if (j == 0) {
                    expandedIndex.push(expandedLine.length - 1)
                } else {
                    // expandedIndex.push(expandedLine.length - 1 + grapheme.length)
                    expandedIndex.push(expandedLine.length - 1)
                }
            }
        }
    }
    // #pastTheEnd, TODO: maybe clean on entry instead
    expandedIndex.push(expandedLine.length)
    
    expandedLine.expandedIndexCache = expandedIndex
    expandedLine.unexpandedIndexCache = unexpandedIndex
    
    cacheLineMeta(theLine, index, file, "expandedLineCache", expandedLine, nocache)
    // var dur = Date.now() - start
    // log({dur, theLine, index, file, nocache})
    return expandedLine
    
}

function expandLine_old(theLine, theIndex) {
    var expandedLine
    var tabStop = globalTabStop
    var afterLastTabPos = 0
    // expandedLine = [...expandedLine]
    if (useUnicode) {
        // you could render inline here

        if (theLine.tabCache) {
            expandedLine = theLine.tabCache
        } else if (theLine == "") {
            expandedLine = []
        } else {
            expandedLine = getCachedGraphemes(theLine, theIndex)
            expandedLine = expandedLine.slice() // copy it
            
            // expanding emojis for double width emojis
            if (emojiWidth != 1 && containsEmoji(theLine)) {
            // if (emojiWidth != 1) {
                var i = 0
                var afterLastEmojiPos = 0
                while (true) {
                    i++
                    if (i === 500) {
                        alert("loop err 4")
                        break
                    }
                    var emojiPos = -1
                    for (var j=afterLastEmojiPos; j<expandedLine.length;j++) {
                        if (isEmoji(expandedLine[j])) {
                            emojiPos = j
                            break
                        }
                    }
                    
                    if (emojiPos == -1) {
                        break
                    }
                
                    expandedLine.splice(emojiPos+1, 0, ...(" ".repeat(emojiWidth-1).split("")))
                    afterLastEmojiPos = emojiPos + (emojiWidth-1) + 1
                }
            }
            
            var i = 0
            while (true) {
                i++
                if (i === 500) {
                    alert("loop err 3")
                    break
                }
                var tabPos = expandedLine.indexOf("\t", afterLastTabPos)
                if (tabPos == -1) {
                    break
                }
                var numberOfSpaces = tabStop - ((tabPos) % tabStop) -1
                // TODO: you can used cached repeated \t array

                expandedLine.splice(tabPos, 0, ...("\t".repeat(numberOfSpaces).split("")))
                afterLastTabPos = tabPos + numberOfSpaces + 1
            }
            
            if (theIndex < fx.lines.length) {
                fx.lines[theIndex].tabCache = expandedLine
            }

        }
    } else {
        // TODO: you can potentially also cache this part
        expandedLine = ""
        while (true) {
            tabPos = theLine.indexOf("\t", afterLastTabPos)
            if (tabPos == -1) {
                expandedLine += theLine.substr(afterLastTabPos, theLine.length)
                break
            }
            expandedLine += theLine.substring(afterLastTabPos, tabPos)
            // now add the correct number of spaces, taking into account the tabStop
            var numberOfSpaces = tabStop - (expandedLine.length % tabStop)
            expandedLine += "\t".repeat(numberOfSpaces)
            afterLastTabPos = tabPos + 1
        }
    }
    return expandedLine
}
function handleFocusAfter() {
    theTextAfter.blur()
    return

    // old stuff
    if (false && searchText.value) {
        findDown()
    } else {
        if (fx.cursorLineIndex == fx.lines.Length - 1) return
        fx.cursorLineIndex += 1
        // instead of going one line down, let's alt tab
        // setCurrentFile(lastFile);
    }
    setCanvasHeightAccordingly()
    ensureCursorInScreen()
    updateCursorXY()
    render()
    theText.focus()
    //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
    setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
}

function handleFocusBefore() {
    theTextBefore.blur()
    return

    // old stuff
    // if you have something to search, make it search.
    if (false && searchText.value) {
        findUp()
    } else {
        if (fx.cursorLineIndex == 0) return
        fx.cursorLineIndex -= 1
        // instead of going one line down, let's clear the search
        // clearSearch()
    }
    setCanvasHeightAccordingly()
    ensureCursorInScreen()
    updateCursorXY()
    render()
    theText.focus()
    //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
    setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
}

function handleFocusIn() {
    setCanvasHeightAccordingly()
    ensureCursorInScreen()
    // lastAction = "type"
    acWord = null
    render()
    //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
    setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
}

function handleBlur() {
    //topPadding.style.height = "100px"
    //window.scrollTo(0, 0)
    //setTimeout(() => {window.scrollTo(0,100)}, 100)

    // handle the case where when you collapse the keyboard on iPad
    // it triggers a blur event, but it's still the activeElement
    if (document.activeElement == theText) {
        theText.blur()
        return
    }

    if (dirtyInput) {
        saveUndo()
        dirtyInput = false
        // auto saving...
        // different that the timed autosave feature
        // this saves when you blur the text input
        if (fx.fileMode == "file") {
            // save(saveDiffs)
        }
    }
    setCanvasHeightAccordingly()
    render()
    window.scrollTo(0, lastPageYOffset)
    renderTheText("")
}

// pressing the save button disables autosave
function saveWrapper() {
    if (fx.fileMode == "shell") {
        // the save button turns into run when it's a "shell" file
        if (fx.selectedRegions.length) {
            copy()
            runShellCommand(copyBuffer.join("\n"))
        } else {
            runShellCommand(fx.lines[fx.cursorLineIndex] || "")
        }
        return
    } else if (fx.fileMode == "terminal") {
        sendTerminal("\r")
        return
    }
    autoSave = false
    save(saveDiffs)
}

function saveFile(f) {
    var oldFx = fx
    fx = f
    var p = save(saveDiffs)
    fx = oldFx
    
    return p
}
function save(saveDiffsLocal) {
    // delete it, they will come back if needed
    for (let f of files) {
        delete f.fileErrors
    }
    var resolve; var reject; var p = new Promise(function(res, rej) { resolve = res; reject = res });
    
    // using a single for loop to
    // simulate a goto
    // breaks will make sure the 'cleanup' step gets called
    for (var s=0; s<1; s++) {
        if (fx.fileMode != "file") break
        if (fx.savedVersion == fx.version) {
            resolve()
            break
        }
        fx.savingVersion = fx.version
        var toSave = fx.lines.join("\n")
        var toSaveHash = md5(toSave)
        var fetchPromise
        if (saveDiffsLocal) {
            var theDiff = simpleDiffOld3(fx.undo.lastSavedLines, fx.lines, false).join("\n")
            if (theDiff == "") {
                fx.savedVersion = fx.savingVersion
                fx.savingVersion = -1
                render()
                renderFileDropdown()
                renderSaves()
                resolve()
                return p
            }
            fetchPromise = fetch(proxyPath + "/saveload?fullpath=" + encodeURIComponent(fx.fullPath), {
                method: "POST",
                cache: "no-cache",
                headers: { "Content-Type": "application/x-www-form-urlencoded"},
                body: "oldmd5="+fx.undo.lastSavedHash+"&newmd5="+toSaveHash+"&diff=" + encodeURIComponent(theDiff)
            })
        } else {
            fetchPromise = fetch(proxyPath + "/saveload?fullpath=" + encodeURIComponent(fx.fullPath), {
                method: "POST",
                cache: "no-cache",
                headers: { "Content-Type": "application/x-www-form-urlencoded"},
                body: "content=" + encodeURIComponent(toSave)
            })
        }
        var myFx = fx
        fetchPromise.then(r => r.json())
        .then(v => {
            if (v.saved) {
                myFx.savedVersion = myFx.savingVersion
                myFx.savingVersion = -1
                myFx.undo.lastSavedLines = toSave.split("\n")
                myFx.undo.lastSavedHash = toSaveHash
                resolve()
            } else {
                // alert("issue saving: " + v.error)
                var resp = prompt("issue saving: " + v.error + "\nType yolo if you want to save anyway")
                if (resp == "yolo") {
                    return save(false)
                } else {
                    myFx.savingVersion = -1
                    reject()
                }
            }
            render()
            renderFileDropdown()
            renderSaves()
        })
        .catch(e => {
            alert(e)
            reject(e)
        })
        render()
    }

    // no auto save
    if (autoSave) {
        setTimeout(save, saveEveryMS)
    }

    renderFileDropdown()
    renderSaves()
    
    return p
}
if (autoSave) {
    setTimeout(save, saveEveryMS)
}

var ctrlDown = false
var keyMaping = {
    "Enter": "\r", // need to include \n too?
    "Shift": "", // we'd just send upercase letters
    "CapsLock": "",
    "Backspace": "\b",
    "Tab": "\t",
    "Escape": "\x1b",
    "ArrowUp": "\x1b[A",
    "ArrowDown": "\x1b[B",
    "ArrowLeft": "\x1b[D",
    "ArrowRight": "\x1b[C",
}
function handleKeydown(e) {
    // TODO: this is where you could wrap or unwrap quotes, etc
    if (fx.fileMode == "terminal") {
        var mapped = e.key
        if (ctrlDown) {
            // todo add more conditions
            var v = e.key.toUpperCase().charCodeAt(0)-64
            if (v < 0) {
                return
            }
            mapped = String.fromCharCode(v)
        } else {
            // For keyboard
            if (e.key == "Control") {
                ctrlDown = true
                return
            }
            mapped = keyMaping[e.key]
            if (typeof mapped == "undefined") {
                mapped = e.key
            }
        }

        if (mapped === "") {
            return
        }
        sendTerminal(mapped)

        ctrlDown = false
        e.stopPropagation()
        e.preventDefault()
        return false
    }

    wasWasDelete = wasDelete
    wasDelete = e.keyCode == 8
    // 8 means backspace
    if (e.keyCode == 8 && theText.selectionStart == 0 && fx.cursorLineIndex != 0) {
        e.preventDefault()
        var theLine = fx.lines[fx.cursorLineIndex]

        fx.lines.splice(fx.cursorLineIndex, 1)
        adjustHighlightRanges(fx.cursorLineIndex, -1)

        fx.cursorLineIndex -= 1
        var prevLine = fx.lines[fx.cursorLineIndex]
        // fx.lines[fx.cursorLineIndex] = fx.lines[fx.cursorLineIndex] + theLine
        updateLine(fx.cursorLineIndex, fx.lines[fx.cursorLineIndex] + theLine)
        // TODO: process the index here!!!
        fx.cursorColIndex = prevLine.length
        updateCursorXY()
        docChanged()
        render()
        //theText.setSelectionRange(prevLine.length, prevLine.length)
        setSelectionRangeForText(prevLine.length, prevLine.length)
        return true // could be false too?
    }

    if (document.activeElement == theText && fx.selectedRegions.length) {
        e.preventDefault()
        var closer = closingMap[e.key]
        if (!closer) {
            return false
        }
        if (fx.selectedRegions[0].startY != fx.selectedRegions[0].stopY) {
            // for now only deal with singe line
            return false
        }
        var selectedRegion = JSON.parse(JSON.stringify(fx.selectedRegions[0]))
        // for now only deal with singe line
        var oldCopyBuffer = copyBuffer

        del(false, true)
        var part = copyBuffer[0]
        if (!part) {
            return false
        }
        if (part.slice(0, 1) == e.key && part.slice(-1) == closer) {
            copyBuffer = [part.slice(1,-1)]
            selectedRegion.stopX -= 2
        } else {
            copyBuffer = [e.key + part + closer]
            selectedRegion.stopX += 2
        }
        paste()
        fx.selectedRegions = [selectedRegion]
        copyBuffer = oldCopyBuffer
        docChanged()
        render()
        return false
    }
    // log(e.keyCode + " " + Date.now()) 
    if (e.keyCode == 32)  { // space
        // if (!e.shiftKey) {
        if (e.shiftKey) {
            w = getWordBeforeCursor()
            if (w.word != "") {
                if (!isUsedWord(w.word)) {
                    e.preventDefault() // for use with shift
                    acWordToggle()
                    render() // render sets the input box right, not sure why i need that.
                }
            }
        }
    }
    // if (e.keyCode == 13)  { // enter
    //     if (e.shiftKey) {
    //         e.preventDefault()
    //         theText.blur()
    //     }
    // }

    return true
}
function isUsedWord(word) {
    return false
    
    if (word == "if") {
        return true
    }
    return false
}

var closingMap = {
    "[": "]",
    "(": ")",
    "{": "}",
    "<": ">",
    "'": "'",
    "`": "`",
    '"': '"',
    '¬´': '¬ª',
}

// var x = foo
// var x =

// var x = foo bar baz
// var x = foo baz

//     x = foo
// var x = foo

// var max right loop
function findWordEntered(newLine, existingLine) {
    // find first char different from left
    if (newLine.length < existingLine.length) {
        return null
    }
    // Now we know the  new line is bigger
    var index = 0
    var maxLoop = newLine.length
    while (true) {
        var newChar = newLine[index]
        var existingChar = existingLine[index]
        if (newChar != existingChar) {
            break
        }
        index++
        if (index >= maxLoop) {
            break
        }
    }

    // find first char different from right
    var fromRight = 0
    while (true) {
        newLineIndex = newLine.length - 1 - fromRight
        existingLineIndex = existingLine.length - 1 - fromRight
        
        var newChar = newLine[newLineIndex]
        var existingChar = existingLine[existingLineIndex]
        if (newChar != existingChar) {
            break
        }
        fromRight++
        if (fromRight >= maxLoop) {
            break
        }
    }
    var endIndex = newLine.length - fromRight
    var word = newLine.slice(index, endIndex)
    // log(["added?", newLine.slice(index, endIndex), index, fromRight])
    if (!word) {
        return null
    }
    return {
        word: word,
        startIndex: index,
        endIndex: endIndex
    }
}

function handleQuickType() {
    // let's try to figure out if you used swipe typing
    // swipe typing does funny things like
    // only sometimes entering spaces when you are surrounded by quotes
    // also it would be cool to change the default behavior
    // to make an camelCase variabile instead of just adding spaces between words)?
    // but only if the line doesn't start with # or // ?
    // Note that "quicktype" will delete by going backspace many times in a row
    // but insert the word in one go
    
    // sometimes the swipe typing adds a space after, but in a separate event
    // when it adds a space the cursor is off. we need to figure that out.
    var parts = fx.fullPath.split("/")
    if (parts[parts.length-1].indexOf(".") == -1) {
        // don't do the stuff here if it's just a text file with no suffix like SCRATCH
        return
    }
    var trimmedText = theText.value.trim()
    if (trimmedText.startsWith("//") || trimmedText.startsWith("#")) {
        // nothing
    } else {
        // don't do this fancy stuff if we are in a string
        var wordEntered = findWordEntered(theText.value, fx.lines[fx.cursorLineIndex] || "")
        var trimmedEntered = wordEntered && wordEntered.word.trim()
        if (wordEntered && (trimmedEntered.length >= 2 || trimmedEntered == "(") ) {
            var prevCharIsWordy = false
            if (isWordyChar(theText.value[wordEntered.startIndex-1])) {
                prevCharIsWordy = true
            }
            if (wordEntered.word.startsWith(" ") && trimmedEntered != "") {
                // if there is a letter before it 
                var firstChar = wordEntered.word.slice(1, 2)
                if (prevCharIsWordy) {
                    // We uppercase to implement the camel casing
                    firstChar = firstChar.toUpperCase()
                }
                theText.value =
                    theText.value.slice(0, wordEntered.startIndex) +
                         firstChar + wordEntered.word.slice(2) +
                    theText.value.substr(wordEntered.endIndex) 
                    theText.setSelectionRange(wordEntered.endIndex-1, wordEntered.endIndex-1)
            }
        }
    }
}

var dirtyInput = false
function saveLine() {
    dirtyInput = true
    lastAction = "type"
    acWord = null
    aclV2 = null
    
    // do pre
    // handleQuickType()
    
    // useUnicode you could fix this part up?
    var lastTyped = theText.value[theText.selectionStart - 1]
    var secondLastTyped = theText.value[theText.selectionStart - 2] || ""
    var nextChar = theText.value[theText.selectionStart] || ""
    // fx.cursorColIndex = theText.selectionStart
    var theLine = updateLine(-1, theText.value)
    // fx.cursorColIndex = expandTabIndex(theText.value, theText.selectionStart)
    fx.cursorColIndex = expandTabIndex(theLine, theText.selectionStart)


    // Note: handle newline portion too.

    // doing for to be able to break
    for (var s=0; s<1; s++) {
        if (
            !wasDelete &&
            lastTyped in closingMap
        ) {
            var mainClosers = "({["
            var mainClosersEnd = ")}]"
            // first some common checks
            if (lastTyped == "'" && secondLastTyped != " " && secondLastTyped != "" && secondLastTyped != "," && mainClosersEnd.indexOf(nextChar) == -1) {
                break
            }

            if (lastTyped == "<" && theText.value.substring(0, theText.selectionStart - 1).trim() != "") {
                break
            }
            if (mainClosers.indexOf(lastTyped) != -1 && nextChar != "" && nextChar != " " && nextChar != "," && mainClosersEnd.indexOf(nextChar) == -1) {
                break
            }
            // renderTheText sets theText.value
            // theText.value =
            renderTheText(
                theText.value.slice(0, theText.selectionStart) +
                closingMap[lastTyped] +
                theText.value.slice(theText.selectionStart)
            )
            updateLine(-1, theText.value)
            //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
            setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
        }
    }
    // we used to do equivalent updateLine once here but now potentially do it twice with the closers
    cursorX = (fx.cursorColIndex - fx.offsetX) * fontWidth
    cursorY = (fx.cursorLineIndex - fx.offsetY) * fontHeight
    docChanged(true)

    // you need to tell the render to not update the text area
    // weird bugs will happen without this
    inEdit = true
    ensureCursorInScreen()
    render()
    inEdit = false
}
function bind(v, min, max) {
    if (v < min) v = min
    if (v > max) v = max
    return v
}

function round(x) {
    return Math.round(x)
}
function rW(x) {
    return Math.round(x/fontWidth)
}
function rH(y) {
    return Math.round(y/fontHeight)
}
var fillStyleMap = {
    black: 0,
    white: 1,
    brown: 2,
    yellow: 3,
    orange: 4,
    blue: 5,
    // TODO: add updated highlight line here this one is old
    "rgba(0, 255, 255, 0.15)": 6,
    "rgba(0, 0, 0, 0.5)": 7,
    "rgba(255, 255, 255, 0.5)": 8,
}
function fillStyleIndex(f) {
  if (!(f in fillStyleMap)) {
      return f
  }
  return fillStyleMap[f]
}

var mockCanvasContext = {
    mockCanvasContext: true,
    commands: [],
    lastFillStyle: "black",
    fillStyle: "black",
    lastFont: "",
    font: "",
    lastTextBaseline: "",
    textBaseline: "",
    lastY: -9999,
    lastX: -9999,
    lastWasString: false,
    lastWasStringIndex: -1,
    checkFillStyle: function() {
      if (this.lastFillStyle != this.fillStyle) {
          this.lastFillStyle = this.fillStyle
          var fsi = fillStyleIndex(this.fillStyle)
          if (fsi <= 2) {
              this.commands.push(fsi + 7)
          } else {
              this.commands.push([2, fsi])
          }
      }

    },
    beginPath: function() {
        this.commands.push(10)
    },
    arc: function(x, y, startAngle, endAngle, counterClockwise) {
        this.commands.push([11, x, y, startAngle, endAngle, counterClockwise])
    },
    fill: function() {
        this.checkFillStyle()
        this.commands.push(12)
    },
    fillRect: function(x, y, w, h) {
      if (this.fillStyle == "rgba(255, 0, 0, 0.5)") {
          // hack for not rendering red ghost cursor
          return
      }
      this.checkFillStyle()
      this.commands.push([1, round(x), round(y), round(w), round(h)])
    },
    fillText: function(str, x, y) {
      if (this.lastFillStyle != this.fillStyle)  {
          this.lastWasString = false
          this.lastFillStyle = this.fillStyle
          var fsi = fillStyleIndex(this.fillStyle)
          if (fsi <= 2) {
              this.commands.push(fsi + 7)
          } else {
              this.commands.push([2, fsi])
          }
      }
      if (this.lastFont != this.font) {
          this.lastWasString = false
          this.lastFont = this.font
          // simple parsing
          this.commands.push([3, this.font, fonts[this._fontName]])
      }
      if (this.lastTextBaseline != this.textBaseline) {
          this.lastWasString = false
          this.lastTextBaseline = this.textBaseline
          this.commands.push([4, this.textBaseline])
      }
      if (rH(y) == this.lastY) {
          if (this.lastWasString) {
              if ((rW(x) - this.lastX) == 1) {
                // you really only care about isNumeric for the first one after?
                // so you could do one more optimization.
                if (!isNumeric(str)) {
                    this.commands[this.lastWasStringIndex] += (str)
                } else {
                    this.commands[this.lastWasStringIndex] += (" " + str)
                }
              } else {
                this.commands[this.lastWasStringIndex] += (" " + str + rW(x))
              }
              this.lastX = rW(x)
              return
          }
          this.commands.push(str + rW(x))
          this.lastWasString = true
          this.lastWasStringIndex = this.commands.length - 1
          // this.commands.push([str + r(x)])
          // this.commands.push([str, r(x)])
          // this.commands.push([0, str, r(x)])
      } else {
          this.lastWasString = false
          // this.commands.push([str+r(x), r(y)])
          this.commands.push([str, rW(x), rH(y)])
          // this.commands.push([0, str, r(x), r(y)])
          this.lastY = rH(y)
      }
      this.lastX = rW(x)
    },
}
// var serverViewFeature = true
var serverViewFeature = false
var sendingViewToServer = false
var shouldSendViewToServer = false
var lastViewBodyToSend = ""
// var ws = new WebSocket("wss://" + location.host + "/myws/wsrender")
function sendViewToServer() {
   // ideas for server render
   // 1. call render with a mocked canvas context and store all the commands to send to server
   //    the viewer will just long poll to get the latest view and render
   //    use some sort of compression, but each screen is basically the whole current frame
   //    pro: super simple to implement
   //    con: sending the whole screen every change is heavy.
   // 2. like option 1 but have 3 layers -
   //      current line,
   //     everything but the current line,
   //     the cursor position
   // 3. a light version like #1, but don't worry about snapshotting
   //    the canvas commands, just render straight text of the screen
   //    and cursor position. it won't highlight the search word though.
   //    render it in an actual text area
   //    (hmm maybe you could make the search word blink client side)
   //    pro: super simple to implement
   // 4. save diffs any time document changes and keep a local state of the document
   //    on the screenshare client. See comments around undo.
   //    we could do a diff of the while document every change...
   //    but probably better would be the "setter functions" that make the diffs as you go
   //    (still because we are using an os level input box, we may have to diff the current line.)
   //    pro: likely much more fluid rendering
   //    con: much more complicated?
   //    con: having to not miss any messages on the client.
   //    con: how to handle when screenshare clients refresh page?
   //         would server have to keep track of document state?
   //         ah, maybe every few saves the server has to resnapshot the whole document?
   //         then diffs would be from most recent server snapshot
   //         there's a lot I haven't thought through with this option.
   // 5. like option 3 but just send the diff of the simple rendered screen.
   //    the server will keep the last n number of full screens.
   //    when the client asks for the latest screen (including the version number they are seeing)
   //    the server will do a diff of what they have and what they need.
   //    if the version that the client has is too old, it gets the full text again.
   //    pro: still only dealing with current screen
   //    con: not as fluid as a more advanced solution
   // I am starting to like option 5
   // 6. thinking more about 4.
   if (sendingViewToServer) {
       shouldSendViewToServer = true
       return
   }
   var viewBodyToSend = JSON.stringify(mockCanvasContext.commands)
   if (viewBodyToSend == lastViewBodyToSend) {
       // this optimization might not be as big as I thought
       return
   }

   totalViewBytesSent += viewBodyToSend.length
   totalViewRequests += 1
   // try {
   //     ws.send(viewBodyToSend)
   // // you could wait to make sure you server got it before sending again.
   // } catch (e) {
   // }
   // return

   lastViewBodyToSend = viewBodyToSend
   sendingViewToServer = true
   fetch(proxyPath + "/render", {
        cache: "no-cache",
        method: "POST",
        headers: {
          'Content-Type': 'application/json',
          'X-File': fx.fullPath, // I want to believe
          'X-Search': searchText.value,
          // 'Content-Type': 'application/x-www-form-urlencoded',
        },
        body: viewBodyToSend,
   }).then(r => {
       sendingViewToServer = false
       if (shouldSendViewToServer) {
           shouldSendViewToServer = false
           sendViewToServer()
       }
   }).catch(e => {
       sendingViewToServer = false
       alert("error rendering to server: " + e)
       if (shouldSendViewToServer) {
           shouldSendViewToServer = false
           sendViewToServer()
       }
   })

}
var waitingRender = false
var lastRender = 0
var maxFrameRate = 10
// var maxFrameRate = 0

// TODO: potentially deprecate this

function render() {
    if (preventRender) {
        return
    }

    var timeSinceRender = Date.now() - lastRender
    if (timeSinceRender < maxFrameRate) {
        if (!waitingRender) {
            waitingRender = true
            var localInEdit = inEdit
            setTimeout(function () {
                waitingRender = false
                // doing this inEdit dance was important at least for
                // starting to implement emojis
                // I think it prevents setting the selectionRange to an incorrect index
                // when the unExpandTabIndex didn't fully support emojis
                // resulting in typing 2 red hearts turning into a black heart and a red heart
                var oldInEdit = inEdit
                inEdit = localInEdit
                render()
                inEdit = oldInEdit
            }, maxFrameRate - timeSinceRender)
        }
        return
    }
    lastRender = Date.now()


    var start = Date.now()
    // c.width = c.width // one way to clear
    // renderInternal() where it ised to be  _red
    if (true && inDebugView) {
        s.innerHTML =
            lastWord + " " +
            fx.version + "/" + fx.savedVersion +
            "/" + fx.savingVersion +
            " p:" + cursorX + "," + cursorY +
            " c:" + fx.cursorColIndex + "," + fx.cursorLineIndex
            // theStatus.fileTree = fileTree
        theStatus.lastWord = lastWord
        theStatus.lastCleared = lastCleared
        theStatus.tvr = totalViewRequests
        theStatus.tvbs = (totalViewBytesSent).toLocaleString()
        theStatus.fileErrors = fx.fileErrors
        theStatus.currTime__ = new Date()
        theStatus.lastPolled = lastPolled
        theStatus.lastAborted = lastAborted
        theStatus.lastPollResponse = lastPollResponse
        theStatus.lastPollError = lastPollError
        theStatus.isPollingTerminal = isPollingTerminal
        theStatus.pollInFlight = pollInFlight
        
        
        
        // theStatus.overflowX = overflowX
        // theStatus.overflowY = overflowY
        // theStatus.hasDoneOverflowYAction = hasDoneOverflowYAction
        // theStatus.CB = JSON.stringify(copyBuffer)
        // theStatus.oldCB = JSON.stringify(globalOldCopyBuffer)
        if (fx.iframe) {
            theStatus.iframeCursorX = fx.iframeCursorX
            theStatus.iframeCursorY = fx.iframeCursorY
            theStatus.iframeWLeft = fx.iframeWrapper.scrollLeft
            theStatus.iframeWTop = fx.iframeWrapper.scrollTop
            if (fx.currentElement) {
                theStatus.element = fx.currentElement.toString()
                theStatus.tagName = fx.currentElement.tagName
                theStatus.id = fx.currentElement.id
            } else {
                theStatus.element = ""
                theStatus.tagName = ""
                theStatus.id = ""
            }
        }
        // theStatus.acWord = acWord
        statusEl.innerText = JSON.stringify(theStatus, null, "    ")
    }
    // TODO: check perf on this.
    if (fx.selectedRegions.length) {
        statusBar.innerText = fx.selectedRegions[0].stopY - fx.selectedRegions[0].startY + 1
    } else {
        // if (thumbscript4.outstandingCallbacks > 1)
        statusBar.innerText = "run script"
        // statusBar.innerText = Math.round(verticalTouchSize)
        // statusBar.innerText = searchText.value
        // statusBar.innerText = fx.cursorColIndex + "(" + u(fx.cursorColIndex) + ")"
        // statusBar.innerText = Math.round(verticalTouchSize)
    }
    statusBar2.innerText = fx.cursorColIndex + " os copy"
    if (fx.selectedRegions.length) {
        statusBar3.innerText = (fx.selectedRegions[0].stopY - fx.selectedRegions[0].startY + 1) + " os paste"
    } else {
        statusBar3.innerText = "os paste"
    }
    
    // this is commented out because of iphone 12 mini slowness
    // see renderSaves()
    // if (fx.fileMode == "file")   {
    //     if (fx.savingVersion != -1) {
    //         saveButton.style.backgroundColor = "gray"
    //         saveButton.innerText = "saving"
    //     } else if (fx.version == fx.savedVersion) {
    //         saveButton.style.backgroundColor = ""
    //         saveButton.innerText = "saved"
    //     } else {
    //         saveButton.style.backgroundColor = "red"
    //         saveButton.innerText = "save"
    //     }
    // } else if (fx.fileMode == "shell") {
    //     // TODO: consider not setting this every render
    //     saveButton.innerText = "run"
    // } else if (fx.fileMode == "terminal") {
    //     // TODO: consider not setting this every render
    //     saveButton.innerText = "run"
    // }

    if (!inEdit) {
        // TODO: an idea is to not do this in the render step at all
        // but do it whenever we change cursorLineIndex or cursorColIndex
        // maybe use a setter for that to manage it better
        // this may be more efficient too.

        if (fx.selectedRegions.length) {
            if (agressiveRender || (touchCount == 0)) {
                // we comment this out because on iPad the "lines selected" part can make it in to the actual text of the document
                // renderTheText((fx.selectedRegions[0].stopY - fx.selectedRegions[0].startY + 1) + " lines selected")
            }
        } else {
            // TODO: this if statement only needed on iphone 12 mini!!! ???
            // TODO: check other iphone 12s
            // theText.value = cursorLine
	    	// if (agressiveRender || (touchCount == 0 && document.activeElement == theText)) {
	    	// I think count was an optimization that we no longer need plus touch cause problems when you press and hold to delete the end of the line or to the beggining of the line
	    	if (agressiveRender || (document.activeElement == theText)) {
                renderTheText(cursorLine)
            }
        }

        // I don't think we need to do this part
        // theTextBefore.value = fx.lines[fx.cursorLineIndex - 1] || ""
        // theTextAfter.value = fx.lines[fx.cursorLineIndex + 1] || ""


        // set the selection range back to what it was
        // if it needs to be changed, some functions will change it
        // after the call to render.
        // TODO: have a state variable for what it should be.
        // if this is not here then after tap to erase we loose cursor pos
        // we can maybe come up with a way around it
        // Note this also happens somewhere in onMove
        // TODO: does it need to happen in both places?
    	if (agressiveRender || (touchCount == 0 && document.activeElement == theText)) {
            if (document.activeElement == theText) {
                setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
            }
        }
    }


    c.width = c.width // one way to clear
    renderInternal()
    // try {
    //     addCRT()
    // } catch (e) {
    //     alert(e)
    // }
    
    

    if (serverViewFeature) {
        renderServerView()
    }
}

var waitingServerRender = false
var lastServerRender = 0
var maxServerFrameRate = 50 // millis per render
function renderServerView() {
    // this render bock was recently moved into the serverViewFeature conditional
    var timeSinceServerRender = Date.now() - lastServerRender
    if (timeSinceServerRender < maxServerFrameRate) {
        if (!waitingServerRender) {
            waitingServerRender = true
            setTimeout(function () {
                waitingServerRender = false
                renderServerView()
            }, maxServerFrameRate - timeSinceServerRender)
        }
        return
    }

    // this made it slightly choppy, maybe because of double render?
    lastServerRender = Date.now()

    // server rendering
    var oldOffsetX = fx.offsetX
    var oldMaxCols = maxCols
    var oldMaxLines = maxLines
    var oldT = t // canvas rendering context
    
    var expandScreen = true
    
    if (expandScreen) {
        fx.offsetX = -fx.marginLeft
        if (maxCols < 175) {
            maxCols = 175
        }
        if (maxLines < 32) {
            maxLines = 32
        }
    }

    var oldCanvasHeight = canvasHeight
    // setCanvasHeight(canvasHeightFull)
    maxLines = Math.floor(canvasHeightFull / fontHeight)

    if (expandScreen) {
        var section = Math.floor((fx.cursorColIndex + fx.marginLeft) / maxCols)
        fx.offsetX = (section * maxCols) - fx.marginLeft
    }

    t = mockCanvasContext
    // mockCanvasContext.lastFillStyle = "black",
    // mockCanvasContext.fillStyle = "black",
    mockCanvasContext.lastFillStyle = "/",
    mockCanvasContext.fillStyle = "/",
    mockCanvasContext.lastFont = "",
    mockCanvasContext.font = "",
    mockCanvasContext.lastTextBaseline = "",
    mockCanvasContext.textBaseline = "",
    mockCanvasContext.commands = [[5, fontWidth.toFixed(2)-0, fontHeight.toFixed(2)-0, maxCols, maxLines, isDark ? 1 : 0]]

    // var start = Date.now()
    renderInternal()

    fx.offsetX = oldOffsetX
    maxCols = oldMaxCols
    maxLines = oldMaxLines
    t = oldT
    // setCanvasHeight(oldCanvasHeight)
    canvasHeight = oldCanvasHeight
    sendViewToServer()
}

// this is a workaround for iphone 12 mini issue where dom is slow
// and we can't blindly update it in the render loop
// TODO: you can make shell and terminal faster too.
var renderedSaveRed = false
function renderSaves() {
    if (!fx) {
        return
    }
    if (fx.fileMode == "file")   {
        if (fx.savingVersion != -1) {
            saveButton.style.backgroundColor = "gray"
            saveButton.innerText = "saving"
            renpderedSaveRed = false
        } else if (fx.version == fx.savedVersion) {
            saveButton.style.backgroundColor = ""
            saveButton.innerText = "saved"
            renderedSaveRed = false
        } else if (!renderedSaveRed) {
            saveButton.style.backgroundColor = "red"
            saveButton.innerText = "save"
            renderedSaveRed = true
        }
    } else if (fx.fileMode == "shell") {
        // TODO: consider not setting this every render
        saveButton.innerText = "run"
    } else if (fx.fileMode == "terminal") {
        // TODO: consider not setting this every render
        saveButton.innerText = "run"
    }
}

var theTextValue = ""
function renderTheText(v) {
    // TODO: why when i uncomment the if
    // and i type and hit enter it duplicates the line?
    // if (v != theTextValue) {
        theText.value = v
        theTextValue = v
    // }
}
function toggleCompactRender() {
    compactRender = !compactRender
    globalTabStop = compactRender ? 2 : 4
    render()
}

var noCompactPrevWords = {
    "function": true,
    "func": true,
    "class": true,
    "type": true,
    "var": true,
}
var compactReplace = {
    "if": "if",
    "for": "for",
    "foreach": "frch",
    "function": "fn",
    "func": "fn",
    "range": "rg",
}
function compactWord(word, theLine, startSpacesLength, index, prevWord) {
    if (fx.cursorLineIndex == index && fx.cursorColIndex >= 0) {
        return word
    }
    if (noCompactPrevWords[prevWord]) {
      return word
    }
    if ((theLine.trimStart().length + startSpacesLength + fx.marginLeft) <= maxCols) {
        return word
    }
    var replacement = compactReplace[word]
    if (replacement) {
      return replacement
    }

    if (word - 0 == word) {
        return word
    }

    return word.slice(0,1)
}
function compactSpace(spaces, index) {
    return spaces

    if (fx.cursorLineIndex == index && fx.cursorColIndex >= 0) {
        return spaces
    }
    var numbSpaces = 2*Math.floor(spaces.length / 4)
    var leftover = spaces.length % 4
    return " ".repeat(numbSpaces+leftover)
}
function compactLine(theLine, index) {
    var ret = {
        compactedLine: "",
        fgColors: [],
        bgBoxes: []
    }
    // if (theLine.length + marginLeft <= maxCols) {
    //     ret.compactedLine = theLine
    //     return ret
    // }


    var currentToken = ""
    var state="start"
    var startSpaces = ""
    var prevWord = ""
    for (var i = 0; i < theLine.length; i++) {
        var chr = theLine[i]
        if (state == "start") {
            if (chr == " ") {
                currentToken = chr
                state = "startSpace"
            } else if (isWordyChar(chr)) {
                currentToken = chr
                state = "inWord"
            } else {
                state = "endThing"
                ret.compactedLine += chr
            }
        } else if (state == "startSpace") {
            if (chr == " ") {
                currentToken += chr
            } else if (isWordyChar(chr)) {
                startSpaces = compactSpace(currentToken, index)
                ret.compactedLine += startSpaces
                currentToken = chr
                state = "inWord"
            } else {
                startSpaces = compactSpace(currentToken, index)
                ret.compactedLine += startSpaces
                state = "endThing"
                ret.compactedLine += chr
            }
        } else if (state == "inWord") {
            if (isWordyChar(chr)) {
                currentToken += chr
            } else {
                ret.compactedLine += compactWord(currentToken, theLine, startSpaces.length, index, prevWord)
                prevWord = currentToken
                ret.compactedLine += chr
                state = "endThing"
            }
        } else if (state == "endThing") {
            if (isWordyChar(chr)) {
                state = "inWord"
                currentToken = chr
            } else {
                ret.compactedLine += chr
            }
        }
    }
    if (state == "inWord") {
        ret.compactedLine += compactWord(currentToken, theLine, startSpaces.length, index, prevWord)
        prevWord = currentToken
    }
    return ret
}

var notSpace = /[^\s]/
function skipLeadingSace(line, startX, offsetX, y, file) {
    var adjustedStart = unExpandTabIndex(line, startX, y, file)
    var newStartX = startX
    var match = line.match(notSpace)
    if (match) {
        var letterStart = match.index
        if (adjustedStart < letterStart) {
            newStartX = expandTabIndex(line, letterStart, y)
        }
    }
    return [newStartX-offsetX, newStartX-startX]
}

function drawCircle(color, x, y, r, lineColor, lineWidth) {
    // t.save()
    t.fillStyle = color
    t.strokeStyle = lineColor
    t.lineWidth = lineWidth
    t.beginPath()
    t.arc(x, y, r, 0, 2*Math.PI, false)
    t.fill()
    // t.stroke()
    // t.restore()
}

var headers = []
var headerIndexes = []
var renderDuration = 0
var renderCount = 0
var rendersInLastSecond = 0
function renderInternal() {
    // note: any time we call expandTabIndex (should not use theLine but should  use something like `fx.lines[y + fx.offsetY] || ""`)
    // (the selectedRegions part seems fine)
    
    // todo, how performant is this?
    // better to do this on initial load and then docChanged or something?
    var startRenderTime = Date.now()
    if (fx.iframe) {
        iframeCursor.style.top = (fx.iframeCursorY-5) + "px"
        // iframeCursor.style.left = ((navTouchSize) +fx.iframeCursorX-5) + "px"
        iframeCursor.style.left = (fx.iframeCursorX-5) + "px"
        return
    }
    // if ('filter' in t) {
    //   t.filter = "blur(10px)";
    // } else {
    //   t.shadowColor = "gray";
    //   t.shadowBlur = 15;
    //   t.shadowOffsetX = 0;
    //   t.shadowOffsetY = 0;
    // }
    
    if (false) {
    // if (true) {
        var displaySelectTouchSize = selectTouchSize
        // var displaySelectTouchSize = 10
        t.fillStyle = "rgba(0,0,255, 0.55)"
        t.fillRect((canvasWidth * (1-selectAreaRatio)) - (displaySelectTouchSize*3/2) , 0, displaySelectTouchSize*3, canvasHeight)
        t.fillRect((canvasWidth * selectAreaRatio) - (displaySelectTouchSize*3/2) , 0, displaySelectTouchSize*3, canvasHeight)
    
        t.fillStyle = "rgba(255,0,255, 0.55)"
        t.fillRect(0, 0, navTouchSize*3, canvasHeight)
        t.fillRect(canvasWidth - navTouchSize*3, 0, navTouchSize*3, canvasHeight)
    }
    
    // draw line where your cursor is for help with finding
    var underlineOffset = (fontHeight) - (1/6/2 * fontHeight)
    // var underlineHeight = fontHeight/6
    var underlineHeight = fontHeight/12
    var highlightLine = true
    // var highlightLine = false
    if (highlightLine) {
        // t.fillStyle = "rgba(0, 255, 255, 0.15)"
        // more apparent highlight line
        if (isDark) {
            // temp experiment with darker line
            // t.fillStyle = "rgba(0, 128, 128, 0.55)"
            // t.fillStyle = "rgba(128, 128, 128, 0.55)"
            // t.fillStyle = "rgba(0, 128, 128, 0.55)"
            t.fillStyle = "rgba(0, 128, 128, 0.45)"
        } else {
            // t.fillStyle = "rgba(0, 255, 255, 0.55)"
            // t.fillStyle = "rgba(192, 192, 192, 0.55)"
            t.fillStyle = "rgba(224, 224, 224, 0.55)"
        }
        // go twice as wide as you need, for server rendering purposes
        t.fillRect(0, (fx.cursorLineIndex - fx.offsetY) * fontHeight, c.width*3, fontHeight)

        // var line = (fx.lines[fx.cursorLineIndex] || "")
        // var [newStartX, adjustment] = skipLeadingSace(line, 0, fx.offsetX, y + fx.offsetY, fx)
        // t.fillStyle = "deeppink"
        // t.fillRect(newStartX*fontWidth, (fx.cursorLineIndex - fx.offsetY)*fontHeight + underlineOffset, (expandTabIndex(line, line.length, fx.cursorLineIndex)-adjustment)*fontWidth, underlineHeight)
    }

    // the selected areas
    for (var i=0; i<fx.selectedRegions.length;i++) {
        // todo: normalize region start and stop
        // todo: draw the cursors after the selected regions
        var r = fx.selectedRegions[i]
        // t.fillStyle = "magenta"
        // t.fillStyle = lightFontColor
        if (isDark) {
            // t.fillStyle = "#333"
            // t.fillStyle = "gray"
            // t.fillStyle = "magenta"
            // t.fillStyle = "yellow"
            t.fillStyle = "rgba(0, 128, 255, 0.55)"
        } else {
            // t.fillStyle = "lightgray"
            // t.fillStyle = "white"
            // t.fillStyle = "#ccc"
            t.fillStyle = "rgba(0, 128, 255, 0.55)"
        }
        for (var y=r.startY-fx.offsetY; y<=r.stopY-fx.offsetY; y++) {
            var line = fx.lines[y + fx.offsetY] || ""
            if (r.startY == r.stopY) {
                t.fillRect((r.startX-fx.offsetX)*fontWidth, y*fontHeight, (r.stopX-r.startX)*fontWidth, fontHeight)
            } else if (y==r.startY-fx.offsetY) {
                t.fillRect((r.startX-fx.offsetX)*fontWidth, y*fontHeight, (expandTabIndex(line, line.length, y + fx.offsetY)-r.startX)*fontWidth, fontHeight)
            } else if (y==r.stopY-fx.offsetY) {
                t.fillRect((0-fx.offsetX)*fontWidth, y*fontHeight, r.stopX*fontWidth, fontHeight)
            } else {
                t.fillRect((0-fx.offsetX)*fontWidth  , y*fontHeight, expandTabIndex(line, line.length, y + fx.offsetY)*fontWidth, fontHeight)
            }
        }
    }

    // the highlighted areas
    if (fx.highlightRanges) {
        for (var i=0; i<fx.highlightRanges.length;i++) {
            // TODO: don't highlight leading whitespa e
            // TODO: look into caching emd result of boxes

            // var r = fx.highlightRanges[i]
            // t.fillStyle = r.BackgroundColor
            // for (var y=r.StartY-fx.offsetY; y<=r.StopY-fx.offsetY; y++) {
            //     var line = fx.lines[y + fx.offsetY] || ""
            //     if (r.StartY == r.StopY) {
            //         t.fillRect((r.StartX-fx.offsetX)*fontWidth, y*fontHeight + underlineOffset, (r.StopX-r.StartX)*fontWidth, underlineHeight)
            //     } else if (y==r.StartY-fx.offsetY) {
            //         t.fillRect((r.StartX-fx.offsetX)*fontWidth, y*fontHeight + underlineOffset, (expandTabIndex(line, line.length, y + fx.offsetY)-r.StartX)*fontWidth, underlineHeight)
            //     } else if (y==r.StopY-fx.offsetY) {
            //         t.fillRect((0-fx.offsetX)*fontWidth, y*fontHeight + underlineOffset, r.StopX*fontWidth, underlineHeight)
            //     } else {
            //         t.fillRect((0-fx.offsetX)*fontWidth, y*fontHeight + underlineOffset, expandTabIndex(line, line.length, y + fx.offsetY)*fontWidth, underlineHeight)
            //     }
            // }

            // TODO, we could look into expanding tab indexes in one flow? instead of 2 individually?
            var r = fx.highlightRanges[i]
            t.fillStyle = r.BackgroundColor
            for (var y=r.StartY-fx.offsetY; y<=r.StopY-fx.offsetY; y++) {
                // You could even get more granular
                if (r.StopY < fx.offsetY) {
                    break
                }
                if (r.StartY > (fx.offsetY+maxLines)) {
                    break
                }
                var line = fx.lines[y + fx.offsetY] || ""
                if (r.StartY == r.StopY) {
                    var [newStartX, adjustment] = skipLeadingSace(line, r.StartX, fx.offsetX, y + fx.offsetY, fx)
                    t.fillRect(newStartX*fontWidth, y*fontHeight + underlineOffset, (r.StopX-r.StartX-adjustment)*fontWidth, underlineHeight)
                } else if (y==r.StartY-fx.offsetY) {
                    var [newStartX, adjustment] = skipLeadingSace(line, r.StartX, fx.offsetX, y + fx.offsetY, fx)
                    t.fillRect(newStartX*fontWidth, y*fontHeight + underlineOffset, (expandTabIndex(line, line.length, y + fx.offsetY)-r.StartX-adjustment)*fontWidth, underlineHeight)
                } else if (y==r.StopY-fx.offsetY) {
                    var [newStartX, adjustment] = skipLeadingSace(line, 0, fx.offsetX, y + fx.offsetY, fx)
                    t.fillRect(newStartX*fontWidth, y*fontHeight + underlineOffset, (r.StopX-adjustment)*fontWidth, underlineHeight)
                } else {
                    var [newStartX, adjustment] = skipLeadingSace(line, 0, fx.offsetX, y + fx.offsetY, fx)
                    t.fillRect(newStartX*fontWidth, y*fontHeight + underlineOffset, (expandTabIndex(line, line.length, y + fx.offsetY)-adjustment)*fontWidth, underlineHeight)
                }
            }
        }
    }



    // render autocomplete word
    // the false is to see what it's like not rendering the "acWord"
    // Because it looks like selected text, I confuse the flow with
    // actual selected text
    if (!alternateTap && acWord) {
        t.fillStyle = "orange"
        for (var y=acWord.startY-fx.offsetY; y<=acWord.stopY-fx.offsetY; y++) {
            var line = fx.lines[y + fx.offsetY] || ""
            if (acWord.startY == acWord.stopY) {
                t.fillRect((acWord.startX-fx.offsetX)*fontWidth, y*fontHeight, (acWord.stopX-acWord.startX)*fontWidth, fontHeight)
            } else if (y==acWord.startY-fx.offsetY) {
                t.fillRect((acWord.startX-fx.offsetX)*fontWidth, y*fontHeight, (expandTabIndex(line, line.length, y + fx.offsetY)-acWord.startX)*fontWidth, fontHeight)
            } else if (y==acWord.stopY-fx.offsetY) {
                t.fillRect((0-fx.offsetX)*fontWidth, y*fontHeight, acWord.stopX*fontWidth, fontHeight)
            } else {
                t.fillRect((0-fx.offsetX)*fontWidth  , y*fontHeight, expandTabIndex(line, line.length, y + fx.offsetY)*fontWidth, fontHeight)
            }
        }
    }

    t.font = fontCSS
    t._fontName = currentFont.fontName // hack
    t.textBaseline = "top"
    var r = fx.selectedRegions[0]
    // TODO: this element is hitten
    // consider removing it.


    // row highlight, what is this? remove it
    // t.fillStyle = "rgba(0, 128, 128, 0.5)"
    // t.fillRect(0, yPos, canvasWidth, fontHeight)
    // t.fillStyle = cursorType == "move" ? "cyan" : "yellow"

    // Note, we tried doing an extra loop for line numbers first so we change colors less
    //but didn't seem like it improved things
    var minY = 0
    var maxY = maxLines

    // colors on file
    if (fx.fileMode == "fileList") {
        for (var y=minY; y < maxY; y++) {
            var theLine = fx.lines[y + fx.offsetY] || ""
            var theFileForColor = treeFilesShadow[y + fx.offsetY]
            if (theFileForColor && theFileForColor.color) {
                t.fillStyle = theFileForColor.color
                var startBoxIndex = expandTabIndex(theLine, -1, y + fx.offsetY) - fx.offsetX
                // t.fillText(chr, x*fontWidth, y*fontHeight)
                // t.fillRect(startBoxIndex*fontWidth, y*fontHeight + (fontHeight/4), 2*fontWidth, fontHeight/2)
                t.beginPath()
                t.arc(startBoxIndex*fontWidth + (fontHeight/2), y*fontHeight + (fontHeight/2), fontHeight/3, 0, 2*Math.PI, false)
                t.fill()
            }
        }
    }
    
    var textFillStyleOverride
    var textFillStyleOverride1
    // Highlight search results
    
    headers = []
    headerIndexes = []
    // if (!isMoving && (!document.activeElement || document.activeElement.nodeName != "INPUT")) {
    if (true) {
        // TODO: also not if is typing?
        var indentLength = Infinity
        // for (_y = minY + fx.offsetY - 1; _y > 0; _y--) {
        // for (_y = fx.cursorLineIndex - 1; _y > 0; _y--) {
        // only looks up max 5000 lines for perf reasons
        // TODO; you can cache this and incalidate it.
        for (_y = fx.cursorLineIndex - 1; _y > 0 && _y > (fx.cursorLineIndex - 5000); _y--) {
            var prevLine = fx.lines[_y] || ""
            if (prevLine.trim() == "") {
                continue
            }
            var prevIndentLength = getIndent(prevLine).length
            if (prevIndentLength < indentLength) {
                indentLength = prevIndentLength
                if (_y < fx.offsetY + headers.length) {
                    headers.unshift(prevLine)
                    headerIndexes.unshift(_y)
                }
                if (indentLength == 0) {
                    break
                }
            }
        }
    }
    
    // Y loop #yellow
    // minY isn't really a thing anymore, always 0 I think
    for (var y=minY; y < maxY; y++) {
        // show the end of the document
        // if (theIndex >= fx.lines.length) {
        //   t.fillStyle = "#222"
        //   t.fillRect(0, y*fontHeight, canvasWidth, fontHeight)
        // }

        // highlight search highlightsearch
        var theIndex = y + fx.offsetY
        if (theIndex < 0) {
            continue
        }
        // TODO: use theIndex everywhere below. if we do, we maybe able to uncomment that headers section
        // without that, setting theLine without setting theIndex can cause caching issue and wrong lines to be changed
        var theLine = fx.lines[theIndex] || ""
        var trimmedLine = getCachedTrimmedLine(theLine, theIndex)
        
        if (y < headers.length && y < fx.cursorLineIndex - fx.offsetY) {
            // Warning! setting these values bad! (somehow it can update the actual line! because of caching or something)
            theLine = headers[y]
            trimmedLine = theLine.trim()
            theIndex = headerIndexes[y]
            if (isDark) {
                t.fillStyle = "#222"
                textFillStyleOverride = "#aaa"
            } else {
                t.fillStyle = "white"
                textFillStyleOverride = "#222"
            }

            t.fillRect(0, y * fontHeight, c.width*3, fontHeight)
        } else {
            textFillStyleOverride = ""
        }
        
        // no longer doing this block of color feature
        // if (trimmedLine.endsWith("#color")) {
        //     let parts = theLine.split(" ")
        //     let color = parts[parts.length - 2]
        //     if (color != "end") {
        //         textFillStyleOverride = color
        //     } else {
        //         textFillStyleOverride = ""
        //     }
        // }
        
        var extras = true // _lime
        // var extras = false // _lime
        
        // syntax for coloring a line #cyan
        if (extras) {
            var matches = trimmedLine.match(/#[a-z]+\b/)
            if (matches) {
                let color = matches[0].slice(1)
                if (CSS.supports("color", color)) {
                    textFillStyleOverride1 = color
                }
            }
        }

        var highlightStartSearch = 0
        var matchLength = 0
        // search #deepskyblue
        if (true && theLine && searchText.value.length) {
            // max 20 highlights per line
            for (var _i=0; _i<20; _i++) {
                if (false && fx.fileMode == "directory") {
                    var pos = theLine.toLowerCase().indexOf(searchText.value.toLowerCase(), highlightStartSearch)
                    if (pos == -1) {
                        break
                    }
                    matchLength = searchText.value.length
                    highlightStartSearch = pos + matchLength
                } else {
                    if (useRegexSearch) {
                        var theMatch = theLine.substr(highlightStartSearch).match(cachedSearchRegexp(searchText.value))
                        if (theMatch == null) {
                            break
                        }
                        matchLength = theMatch[0].length
                        pos = highlightStartSearch + theMatch.index
                        highlightStartSearch = pos + matchLength
                    } else {
                        var pos = theLine.indexOf(searchText.value, highlightStartSearch)
                        if (pos == -1) {
                            break
                        }
                        matchLength = searchText.value.length
                        highlightStartSearch = pos + matchLength
                    }
                }
                // lime
                if (isDark) {
                    // t.fillStyle = "blue"
                    t.fillStyle = "rgba(0,0,255,0.7)"
                } else {
                    // t.fillStyle = "yellow"
                    t.fillStyle = "rgba(255,255,0,0.7)"
                }

                // using `fx.lines[theIndex] || ""` instead of theLine
                // because it gets replaced with a String object with cached peoperites.
                // var startHighlightPos = expandTabIndex(theLine, pos, theIndex)
                var startHighlightPos = expandTabIndex(fx.lines[theIndex] || "", pos, theIndex)
                var startFillHighlight = (startHighlightPos - fx.offsetX) * fontWidth
                // var highlightLength = (expandTabIndex(theLine, pos+matchLength, theIndex)-startHighlightPos) * fontWidth
                var highlightLength = (expandTabIndex(fx.lines[theIndex] || "", pos+matchLength, theIndex)-startHighlightPos) * fontWidth
                t.fillRect(
                    startFillHighlight,
                    y * fontHeight,
                    highlightLength,
                    fontHeight
                )
            }
        }
        
        // gray underline word at cursor #yellow
        if (extras && theLine && wordAtCursorRegexp) {
            // TODO: regular search can benefit from this matchAll business
            // TODO: you can cache the line and the end result of the matches!
            var matches = theLine.matchAll(wordAtCursorRegexp)
            // log(matches)
            let matchI = 0
            for (let match of matches) {
               matchI++
               if (matchI == 20) {
                   break
               }
                
                // first non null index - 1 (first index is total match)
                var _regI
                var _regLen
                for (_regI=1; _regI < match.length; _regI++) {
                    var captureItem = match[_regI]
                    if (captureItem) {
                        _regLen = captureItem.length
                        break
                    }
                }
                _regI -= 1 // because first item is full match then capture groups

                // using `fx.lines[theIndex] || ""` instead of theLine
                // because it gets replaced with a String object with cached peoperites.
                // var startHighlightPos = expandTabIndex(theLine, match.index, theIndex)
                var startHighlightPos = expandTabIndex(fx.lines[theIndex] || "", match.index, theIndex)
                // continue
                var startFillHighlight = (startHighlightPos - fx.offsetX) * fontWidth
                // var highlightLengthChars = (expandTabIndex(theLine, match.index+_regLen, theIndex)-startHighlightPos)
                var highlightLengthChars = (expandTabIndex(fx.lines[theIndex] || "", match.index+_regLen, theIndex)-startHighlightPos)
                var highlightLength = highlightLengthChars * fontWidth
                // this is copied from highlightmatches but there is only one
                if (_regI >= 1) {
                    continue 
                }
                t.fillStyle = "gray"
                t.fillRect(
                    startFillHighlight,
                    // (y * fontHeight) + (5/6 * fontHeight),
                    (y * fontHeight) + (fontHeight) - (1/6/2 * fontHeight),
                    highlightLength,
                    underlineHeight
                )
            }
        }

        if (extras && theLine && theLine.length < 5000 && highlightMatchesSingleRegExp) {
            // TODO: regular search can benefit from this matchAll business
            // TODO: you can cache the line and the end result of the matches!
            var matches = theLine.matchAll(highlightMatchesSingleRegExp)
            for (const match of matches) {
                // first non null index - 1 (first index is total match)
                var _regI
                var _regLen
                for (_regI=1; _regI < match.length; _regI++) {
                    var captureItem = match[_regI]
                    if (captureItem) {
                        _regLen = captureItem.length
                        break
                    }
                }
                _regI -= 1 // because first item is full match then capture groups


                // using `fx.lines[theIndex] || ""` instead of theLine
                // because it gets replaced with a String object with cached peoperites.
                // var startHighlightPos = expandTabIndex(theLine, match.index, theIndex)
                var startHighlightPos = expandTabIndex(fx.lines[theIndex] || "", match.index, theIndex)
                var startFillHighlight = (startHighlightPos - fx.offsetX) * fontWidth
                // var highlightLengthChars = (expandTabIndex(theLine, match.index+_regLen, theIndex)-startHighlightPos)
                var highlightLengthChars = (expandTabIndex(fx.lines[theIndex] || "", match.index+_regLen, theIndex)-startHighlightPos)
                var highlightLength = highlightLengthChars * fontWidth

                if (_regI >= highlightMatches.length) {
                    continue 
                }
                t.fillStyle = highlightMatches[_regI].BackgroundColor
                // t.fillRect(
                //     startFillHighlight,
                //     y * fontHeight,
                //     highlightLength,
                //     fontHeight
                // )
                t.fillRect(
                    startFillHighlight,
                    // (y * fontHeight) + (5/6 * fontHeight),
                    (y * fontHeight) + (fontHeight) - (1/6/2 * fontHeight),
                    highlightLength,
                    underlineHeight
                )
            }
        }
        

        // Trailing whitespace    
        if (extras) {
            var highlightStartSearch = 0
            var matchLength = 0
            if (fx.fileMode == "file" && theLine) {
                for (var _i=0; _i<1; _i++) { // Loop so we can break
                    var theMatch = theLine.match(trailingWhitespaceRegexp)
                    if (theMatch == null) {
                        break
                    }
                    matchLength = theMatch[0].length
                    pos = highlightStartSearch + theMatch.index
                    // lime
                    if (theMatch[0] == "\r") {
                        t.fillStyle = "rgba(255,0,0,.05)"
                    } else if (isDark) {
                        // t.fillStyle = "salmon"
                        t.fillStyle = "rgb(255, 140, 105, 0.25)"
                    } else {
                        // t.fillStyle = "salmon"
                        t.fillStyle = "rgb(255, 140, 105, 0.25)"
                    }
    
                    // using `fx.lines[theIndex] || ""` instead of theLine
                    // because it gets replaced with a String object with cached peoperites.
                    // if (!theLine)
                    // var startHighlightPos = expandTabIndex(theLine, pos, theIndex)
                    var startHighlightPos = expandTabIndex(fx.lines[theIndex] || "", pos, theIndex)
                    var startFillHighlight = (startHighlightPos - fx.offsetX) * fontWidth
                    // var highlightLengthChars = (expandTabIndex(theLine, pos+matchLength, theIndex)-startHighlightPos)
                    var highlightLengthChars = (expandTabIndex(fx.lines[theIndex] || "", pos+matchLength, theIndex)-startHighlightPos)
                    var highlightLength = highlightLengthChars * fontWidth
                    if ((theIndex == fx.cursorLineIndex) && (startHighlightPos + highlightLengthChars == fx.cursorColIndex)) {
                        // Don't annoy with warning when they are typing
                    } else {
                        t.fillRect(
                            startFillHighlight,
                            y * fontHeight,
                            highlightLength,
                            fontHeight
                        )
                    }
                }
            }
        }

        if (true) {
            if (theIndex < fx.lines.length) {
                var lineNumber = (theIndex+1).toString().padStart(fx.marginLeft-1, " ")
                if (fx.offsetX < -1) {
                    // Line numbers
                    if (extras) {
                        var stringedLine = (fx.lines[theIndex] || "").toString()
                        var stringedLinePrev = (fx.lines[theIndex - 1] || "").toString()
                        // we use toString because of the new String() hack
                        if (fx.fileErrors && fx.fileErrors[theIndex+1]) {
                            t.fillStyle = "white"
                        } else if (stringedLine != "" && stringedLinePrev == stringedLine) {
                            // handy feature to see if lines are same
                            t.fillStyle = "lime"
                        } else {
                            t.fillStyle = lineNumberColor
                        }
                    } else {
                        t.fillStyle = lineNumberColor
                    }
                    for (var i=0; i<-fx.offsetX-1; i++) {
                        var lineNumberIndex = fx.offsetX + fx.marginLeft + i
                        var lineNoChr = lineNumber.charAt(lineNumberIndex)
                        if (lineNoChr != " ") {
                            t.fillText(lineNoChr, i*fontWidth, y*fontHeight + fontOffsetY)
                        }
                    }
                }
            }
        }
        var textFillStyle
        // the actual text
        var commentLine = false
        // TODO: maybe pull some of this out of the loop
        // if (fx.fileMode != "terminal") {
        if (extras && (!syntaxHighlight || fx.fileMode != "file")) {
            // the mini highlighting we do, not the full fledged highlighting
            // theLine vs TrimmedLine
            if (trimmedLine.startsWith("+")) {
                textFillStyle = isDark ? "lime" : "green"
            } else if (trimmedLine.startsWith("-")){
                textFillStyle = "orangered"
            } else if (trimmedLine.startsWith("//") || trimmedLine.startsWith("#")) {
                commentLine = true
                // comments are gray
                textFillStyle = lightFontColor
            } else if (trimmedLine.startsWith("@")) {
                textFillStyle = isDark ? "deepskyblue" : "blue"
            } else if (trimmedLine.startsWith("%")) {
                textFillStyle = isDark ? "yellow" : "saddlebrown"
            } else if (trimmedLine.startsWith("*")) {
                textFillStyle = isDark ? "thistle" : "violet"
            } else {
                // feature to gray out lines before where you are scrolled to
                // var spaceCount = getSpaceCount(theLine)
                // if (spaceCount < fx.offsetX && (theIndex) != fx.cursorLineIndex) {
                //     t.fillStyle = lightFontColor
                // } else {
                //     t.fillStyle = fontColor
                // }
                textFillStyle = fontColor
            }
        } else {
            textFillStyle = fontColor
        }
        
        // Todo, remove in favor of _red
        // if (trimmedLine.endsWith("mar"+"ker")) {
        //     // do a fill rect of the color that comes after
        //     // Not using save and restore because my mock canvas doesn't support it
        //     var oldFillStyle = t.fillStyle
        //     // TODO: faster snagging of the color.
        //     var theParts = trimmedLine.split(" ")
        //     theFillStyle = theParts[theParts.length - 2]
        //     t.fillStyle = theFillStyle
        //     var [newStartX, adjustment] = skipLeadingSace(theLine, 0, fx.offsetX, theIndex, fx) // red marker
        //     t.fillRect(newStartX*fontWidth, y*fontHeight + underlineOffset, (expandTabIndex(theLine, -1, theIndex)-adjustment)*fontWidth, underlineHeight) // red marker
        //     t.fillStyle = oldFillStyle
        // }

        // syntax for underline _green
        if (extras) {
            var matches = trimmedLine.match(/\b_[a-z]+\b/)
            if (matches) {
                let color = matches[0].slice(1)
                if (CSS.supports("color", color)) {
                    var oldFillStyle = t.fillStyle
                    t.fillStyle = color
                    var [newStartX, adjustment] = skipLeadingSace(theLine, 0, fx.offsetX, theIndex, fx) // _red
                    // using `fx.lines[theIndex] || ""` instead of theLine
                    // because it gets replaced with a String object with cached peoperites.
                    t.fillRect(newStartX*fontWidth, y*fontHeight + underlineOffset, (expandTabIndex(fx.lines[theIndex] || "", -1, y+fx.offsetY)-adjustment)*fontWidth, underlineHeight) // _red
                    t.fillStyle = oldFillStyle
                }
            }
        }

        if (compactRender && !commentLine) {
            var lineAndInfo = compactLine(theLine, theIndex)
            theNewLine = lineAndInfo.compactedLine
    
            if (theNewLine != theLine) {
                textFillStyle = isDark ? "lime" : "green"
            }
    
            theLine = theNewLine
        }

        theLine = theLine || ""
        var expandedLine = expandLine(theLine, theIndex)
        var syntaxColors
        if (syntaxHighlight && fx.fileMode == "file") {
        // if (syntaxHighlight) {
            var prevExpandedLine = null
            if (theIndex > 0) {
                prevExpandedLine = expandLine(fx.lines[theIndex-1] || "", theIndex-1)
            }
            syntaxColors = getSyntaxHighlight(expandedLine, prevExpandedLine)
        }

        // one option is to draw the whole line in one go
        // likely more optimal, wouln't have to do the unicode stuff
        // but harder to know wrangle width of the font?
        if (fx.seeOnly && theLine.indexOf(fx.seeOnly) == -1) {
            continue
        }
        var extraY = 0
        for (var x=0; x < maxCols; x++) {
            let expLine = expandedLine
            // if (syntaxHighlight && fx.fileMode == "file") {
            //     expLine = expLine.concat((" " + expandedLine.endState).split(""))
            // }
            if (fx.fileErrors && fx.fileErrors[theIndex+1]) {
                // not cached
                var errorMessage = fx.fileErrors[theIndex+1].Message
                expLine = expLine.concat((" " + errorMessage).split(""))
            }
            
            if ((x+fx.offsetX) >= expLine.length) {
                break
            }
            if ((x+fx.offsetX) >= expandedLine.length) {
                // fileError Color
                textFillStyle = "rgba(255, 200, 200)"
            }
            var chr = expLine[x+fx.offsetX] || ""
            if (chr == "\t") {
                if (shouldSeeTabs) {
                    t.fillStyle = veryLightFontColor
                    t.fillText("‚Ä¢", x*fontWidth, y*fontHeight + fontOffsetY)
                }
            } else if (chr == "\r") {
                t.fillStyle = "orangered"
                t.fillText("‚Ä¢", x*fontWidth, y*fontHeight + fontOffsetY)


            // } else if (chr == "\342") {
            //     t.fillStyle = "skyblue"
            //     t.fillText("‚Ä¢", x*fontWidth, y*fontHeight + fontOffsetY)
            // } else if (chr == "\200") {
            //     t.fillStyle = "white"
            //     t.fillText("‚Ä¢", x*fontWidth, y*fontHeight + fontOffsetY)
            // } else if (chr == "\203") {
            //     t.fillStyle = "orange"
            //     t.fillText("‚Ä¢", x*fontWidth, y*fontHeight + fontOffsetY)
            } else if (chr == "\u2003") {
                t.fillStyle = "teal"
                t.fillText("‚Ä¢", x*fontWidth, y*fontHeight + fontOffsetY)
            } else if (chr > "\xff") {
                t.fillStyle = "deepskyblue"
                t.fillText(chr, x*fontWidth, y*fontHeight + fontOffsetY)
            } else if (chr > "\x7f") {
                t.fillStyle = "lawngreen"
                t.fillText(chr, x*fontWidth, y*fontHeight + fontOffsetY)

            } else if (chr != "" && chr != " ") {
                // TODO: do we need to assign every time?
                // red #color
                if (textFillStyleOverride) {
                    t.fillStyle = textFillStyleOverride
                } else if (textFillStyleOverride1) {
                    t.fillStyle = textFillStyleOverride1
                } else {
                    t.fillStyle = textFillStyle
                }
                // end #color

                if (fauxMono) {
                    var charCode = chr.charCodeAt(0)
                    if (charCode >= 65 && charCode <= 90) {
                        chr = String.fromCodePoint(0x1d670 + (charCode - 65))
                    } else if (charCode >= 97 && charCode <= 122) {
                        chr = String.fromCodePoint(0x1d68a + (charCode - 97))
                    } else if (charCode >= 48 && charCode <= 57) {
                        chr = String.fromCodePoint(0x1d7f6 + (charCode - 48))
                    }
                } else if (fraktur) {
                    var charCode = chr.charCodeAt(0)
                    if (charCode >= 65 && charCode <= 90) {
                        chr = String.fromCodePoint(0x1d504 + (charCode - 65))
                    } else if (charCode >= 97 && charCode <= 122) {
                        chr = String.fromCodePoint(0x1d586 + (charCode - 97))
                    }
                }
                if (useUnicode) {
                    // if (chr.length > 1) {
                    if (isEmoji(chr)) {
                        t.font = fontCSSEmoji
                        extraY = extraYEmoji
                        // chr = "?"
                    } else {
                        var charCode = chr.charCodeAt(0)
                        // if (charCode >= 44 && charCode <= 46 || charCode == 95 || charCode >= 58 && charCode <= 62) {
                        // if (!(charCode >= 97 && charCode <= 122 || charCode >= 48 && charCode <= 57 || charCode >= 65 && charCode <= 90)) {
                        if (false) {
                            t.font = fontCSSPunctuation
                        } else {
                            t.font = fontCSS
                        }
                        extraY = 0
                    }
                    // if (syntaxHighlight) {
                    if (syntaxHighlight && fx.fileMode == "file") {
                        let f = syntaxColorMap[isDark-0][syntaxColors[x+fx.offsetX]]
                        if (f) {
                            t.fillStyle = f
                        }
                    }
                    if (currentFont.fontName == "BerkeleyMono") {
                        if (chr == "/") {
                            chr = "\\"
                        } else if (chr == "\\") {
                            chr = "/"
                        } else if (chr == "*") {
                            chr = "#"
                        } else if (chr == "#") {
                            chr = "*"
                        }
                    }
                    t.fillText(chr, x*fontWidth, y*fontHeight + extraY + fontOffsetY)
                } else {
                    t.fillText(chr, x*fontWidth, y*fontHeight + fontOffsetY)
                }
            }
            if (useUnicode) {
                // revert back
                t.font = fontCSS
            }
        }
        textFillStyleOverride1 = ""
        
        // if (expandedLine.length > maxCols) {
        //     t.save()
        //     t.font = fontCSSTiny
        //     t.fillText(trimmedLine, marginLeft*fontWidth, (y+1)*fontHeight - (0.2*fontHeight))
        //     t.restore()
        // }
    }
    
    // if (headers.length) {
    //     // headers = headers.slice(0, 3)
    //     for (let headerI = 0; headerI < headers.length; headerI++) {
    //         if (fx.cursorLineIndex - fx.offsetY <= headerI) {
    //             continue
    //         }
    //         let header = headers[headerI]
    //         let headerIndex = headerIndexes[headerI]
//             
    //         theLine = theLine || ""
    //         let expandedLine = expandLine(header, headerIndex)
    //         let syntaxColors
    //         if (syntaxHighlight) {
    //             syntaxColors = getSyntaxHighlight(expandedLine)
    //         }
//             
    //         t.fillStyle = "#222"
    //         t.fillRect(0, headerI * fontHeight, c.width*3, Math.ceil(fontHeight))
    //         // t.fillText(header, 0, headerI*fontHeight + fontOffsetY)
    //         let textFillStyleOverride = "#aaa"
    //         for (let x=0; x < maxCols; x++) {
    //             if ((x+fx.offsetX) >= expandedLine.length) {
    //                 break
    //             }
    //             let chr = expandedLine[x+fx.offsetX] || ""
    //             if (chr == "\t") {
    //                 if (shouldSeeTabs) {
    //                     t.fillStyle = veryLightFontColor
    //                     t.fillText("‚Ä¢", x*fontWidth, headerI*fontHeight + fontOffsetY)
    //                 }
    //             } else if (chr != "" && chr != " ") {
    //                 // TODO: do we need to assign every time?
    //                 // red #color
    //                 if (textFillStyleOverride) {
    //                     t.fillStyle = textFillStyleOverride
    //                 } else if (textFillStyleOverride1) {
    //                     t.fillStyle = textFillStyleOverride1
    //                 } else {
    //                     t.fillStyle = textFillStyle
    //                 }
    //                 // end #color
//     
    //                 if (useUnicode) {
    //                     // if (chr.length > 1) {
    //                     if (isEmoji(chr)) {
    //                         t.font = fontCSSEmoji
    //                         extraY = extraYEmoji
    //                         // chr = "?"
    //                     } else {
    //                         t.font = fontCSS
    //                         extraY = 0
    //                     }
    //                     if (syntaxHighlight) {
    //                         // t.fillStyle = syntaxColorMap[isDark-0][syntaxColors[x+fx.offsetX]]
    //                         let f = syntaxColorMap[isDark-0][syntaxColors[x+fx.offsetX]]
    //                         if (f) {
    //                             t.fillStyle = f
    //                         }
    //                     }
    //                     t.fillText(chr, x*fontWidth, headerI*fontHeight + extraY + fontOffsetY)
    //                 } else {
    //                     t.fillText(chr, x*fontWidth, headerI*fontHeight + fontOffsetY)
    //                 }
    //             }
    //             if (useUnicode) {
    //                 // revert back
    //                 t.font = fontCSS
    //             }
    //         }
    //     }
    // }

    // red ghost cursor
    t.fillStyle = "rgba(255, 0, 0, 0.5)"
    t.fillRect(cursorX, cursorY, 4, fontHeight)

    // cursor
    if (fx.selectedRegions.length) {
        t.fillStyle = "olive"
    } else if (touchCount == 0) {
        t.fillStyle = "orange"
    } else {
        t.fillStyle = "pink"
    }
    var yPos = (fx.cursorLineIndex - fx.offsetY) * fontHeight
    var xPos = (fx.cursorColIndex - fx.offsetX) * fontWidth
    t.fillRect(xPos, yPos, 4, fontHeight)
    cursorLine = fx.lines[fx.cursorLineIndex] || ""
    
    
    var vtsThrice = verticalTouchSize*3
    var halfVTSThrice = vtsThrice/2
    // var dotIndent = 30
    var dotIndent = navTouchSize*3 / 2
    var dotSize = 10
    if (!t.mockCanvasContext) {
        // drawCircle(lightFontColor, dotIndent, canvasHeight-(4*vtsThrice)-halfVTSThrice, dotSize, theBackgroundColor, 5)
        // drawCircle(lightFontColor, canvasWidth - dotIndent, canvasHeight-(4*vtsThrice)-halfVTSThrice, dotSize, theBackgroundColor, 5)
        // drawCircle(lightFontColor, dotIndent, canvasHeight-(3*vtsThrice)-halfVTSThrice, dotSize, theBackgroundColor, 5)
        // drawCircle(lightFontColor, canvasWidth - dotIndent, canvasHeight-(3*vtsThrice)-halfVTSThrice, dotSize, theBackgroundColor, 5)
        // 
        // let middleCircleColor = "red"
        // if (searchText.value) {
        //     middleCircleColor = "blue"
        // }
        // drawCircle(middleCircleColor, dotIndent, canvasHeight-(2*vtsThrice)-halfVTSThrice, dotSize, theBackgroundColor, 5)
        // drawCircle(middleCircleColor, canvasWidth - dotIndent, canvasHeight-(2*vtsThrice)-halfVTSThrice, dotSize, theBackgroundColor, 5)
        // drawCircle(lightFontColor, dotIndent, canvasHeight-(1*vtsThrice)-halfVTSThrice, dotSize, theBackgroundColor, 5)
        // drawCircle(lightFontColor, canvasWidth - dotIndent, canvasHeight-(1*vtsThrice)-halfVTSThrice, dotSize, theBackgroundColor, 5)
        // drawCircle(lightFontColor, dotIndent, canvasHeight-(0*vtsThrice)-halfVTSThrice, dotSize, theBackgroundColor, 5)
        // drawCircle(lightFontColor, canvasWidth - dotIndent, canvasHeight-(0*vtsThrice)-halfVTSThrice, dotSize, theBackgroundColor, 5)


        // drawCircle("royalblue", canvasWidth * selectAreaRatio, canvasHeight-(1*vtsThrice)-halfVTSThrice, dotSize/2, theBackgroundColor, 5)
        // drawCircle("royalblue", canvasWidth * (1-selectAreaRatio), canvasHeight-(1*vtsThrice)-halfVTSThrice, dotSize/2, theBackgroundColor, 5)
        // drawCircle("royalblue", canvasWidth * selectAreaRatio, canvasHeight-(2*vtsThrice)-halfVTSThrice, dotSize/2, theBackgroundColor, 5)
        // drawCircle("royalblue", canvasWidth * (1-selectAreaRatio), canvasHeight-(2*vtsThrice)-halfVTSThrice, dotSize/2, theBackgroundColor, 5)
        
        // for (y=0; y<6; y++) {
        for (let y=0; y<5; y++) {
            var prevRatio = 0
            for (var i=0; i<touchRatios.length; i++) {
                var ratio = touchRatios[i]
                // if (y > 0) {
                //     if (i > 0 && i < touchRatios.length -1) {
                //         prevRatio = ratio
                //         continue
                //     }
                // }
                if (i > 0 && i < touchRatios.length -1 && document.activeElement == theText) {
                    prevRatio = ratio
                    continue
                }
                var x = (canvasWidth * ratio) - (canvasWidth * (ratio-prevRatio) / 2)
                // drawCircle("coral", x, canvasHeight-(0*vtsThrice)-halfVTSThrice, dotSize/2, theBackgroundColor, 5)
                // drawCircle(colors[i], x, canvasHeight-(y*vtsThrice)-halfVTSThrice, dotSize/2, theBackgroundColor, 5)
                var mappingKey = (y+1) + mappingPositions[i]
                var usedDotSize = dotSize
                var color = circleColors[mappingKey]
                if (color) {
                    if (color == "royalblue" || color == "__") {
                        usedDotSize = usedDotSize/2
                    }
                    if (color == "_") {
                        color = lightFontColor
                    } else if (color == "__") {
                        color = lightFontColor
                    } else if (color == "?") {
                        if (searchText.value) {
                            color = "blue"
                        } else {
                            color = "red"
                        }
                    }
                    drawCircle(color, x, canvasHeight-(y*vtsThrice)-halfVTSThrice, usedDotSize, theBackgroundColor, 5)
                }
                prevRatio = ratio
            }
        }
    }

    var duration = Date.now() - startRenderTime
    // TODO: audit render for performance
    // also, we are calling it too much, cut down on number of times we call it

    renderCount += 1
    renderDuration += duration
    rendersInLastSecond += 1
    if (renderCount == 50) {
        renderCount = 0
        renderDuration = 0
    }
}
var rainbowColors = ["white"]

var circleColors = {
     "1farLeft": "_",
     "1sliceLeft": "royalblue",
     "1left": "limegreen",
     "1midLeft": "__",
     "1middle": "_",
     "1midRight": "__",
     "1right": "limegreen",
     "1sliceRight": "royalblue",
     "1farRight": "_",

     "2farLeft": "_",
     "2sliceLeft": "royalblue",
     "2left": "_",
     "2midLeft": "__",
     "2middle": "__",
     "2midRight": "__",
     "2right": "_",
     "2sliceRight": "royalblue",
     "2farRight": "_",
     
     // "2farLeft": "_",
     // "2sliceLeft": "royalblue",
     // "2sliceRight": "royalblue",
     // "2farRight": "_",
     
     "3farLeft": "?",
     "3sliceLeft": "royalblue",
     "3left": "__",
     // "3midLeft": "red",
     // "3middle": "",
     // "3midRight": "red",
     "3right": "__",
     "3sliceRight": "royalblue",
     "3farRight": "?",
     

     "4farLeft": "_",
     // "4sliceLeft": "royalblue",
     // "4left": "_",
     // "4midLeft": "red",
     // "4middle": "",
     // "4midRight": "red",
     // "4right": "_",
     // "4sliceRight": "royalblue",
     "4farRight": "_",
     
     "5farLeft": "_",
     // "5sliceLeft": "royalblue",
     // "5left": "_",
     // "5midLeft": "red",
     // "5middle": "",
     // "5midRight": "red",
     // "5right": "_",
     // "5sliceRight": "royalblue",
     "5farRight": "_",
     
     
     "6farLeft": "_",
     "6farRight": "_",
}

var trailingWhitespaceRegexp = /\s+$/

false && setInterval(function() {
    if (rendersInLastSecond > 0) {
        log("rendersInLastSecond: " + rendersInLastSecond)
    }
    rendersInLastSecond = 0
}, 1000)

// simple cache for regexp so we don't need to recompile in render loop
// also so I don't have to keep track of whenever searchText.value is set (although maybe consider doing it that way in another pass)
var lastSearchRegexpText = ""
var lastSearchRegexp = null
var lastCaseSensitiveSearch = -1
function cachedSearchRegexp(str) {
    if (str == lastSearchRegexpText && caseSensitiveSearch == lastCaseSensitiveSearch) {
        return lastSearchRegexp
    }
    lastSearchRegexpText = str
    lastCaseSensitiveSearch = caseSensitiveSearch
    try {
        // Case insensitive
        if (caseSensitiveSearch) {
            lastSearchRegexp = new RegExp(lastSearchRegexpText) 
        } else {
            lastSearchRegexp = new RegExp(lastSearchRegexpText, 'i')
        }

    } catch (e) {
        lastSearchRegexpText = ""
        lastSearchRegexp = null
    }
    return lastSearchRegexp
}

// just like cachedSearchRegexp but a global regexp for searching backwards
var lastSearchRegexpGlobalText = ""
var lastSearchRegexpGlobal = null
var lastCaseSensitiveSearchGlobal = -1
function cachedSearchRegexpGlobal(str) {
    if (str == lastSearchRegexpGlobalText && caseSensitiveSearch == lastCaseSensitiveSearchGlobal) {
        return lastSearchRegexpGlobal
    }
    lastSearchRegexpGlobalText = str
    lastCaseSensitiveSearchGlobal = caseSensitiveSearch
    try {
        if (caseSensitiveSearch) {
            lastSearchRegexpGlobal = new RegExp(lastSearchRegexpGlobalText, 'g')
        } else {
            lastSearchRegexpGlobal = new RegExp(lastSearchRegexpGlobalText, 'gi')
        }
    } catch (e) {
        lastSearchRegexpGlobalText = ""
        lastSearchRegexpGlobal = null
    }
    return lastSearchRegexpGlobal
}

function ensureSign(sign, v) {
    if (sign < 0 && v > 0) return -v
    if (sign > 0 && v < 0) return -v
    return v
}

// todo: use min, max in some places where you used bind
function min(a, b) {
    return a < b ? a : b
}

function max(a, b) {
    return a > b ? a : b
}

function moveHomeEndAction() {
    var theLine = fx.lines[fx.cursorLineIndex] || ""
    switch (moveHomeEndDirection) {
       case "up":
           // TODO: jump to markers once you add that feature?
           // make an implicit marker of where you last were?
           // var oldSearchText = searchText.value
           // searchText.value = "// mar"+"ker "
           // var found = findUp()
           // searchText.value = oldSearchText
           // if (!found) {
               fx.cursorLineIndex = 0
           // }
           break;
       case "down":
           // TODO: jump to markers
           // var oldSearchText = searchText.value
           // searchText.value = "// mar"+"ker "
           // var found = findDown()
           // searchText.value = oldSearchText
           // if (!found) {
               fx.cursorLineIndex = fx.lines.length - 1
           // }
           break;
       case "left":
           var theIndent = getIndent(theLine)
           fx.cursorColIndex = expandTabIndex(theLine, theIndent.length)
           break;
       case "right":
           fx.cursorColIndex = expandTabIndex(theLine, theLine.length)
           break;
   }
   if (document.activeElement == theText) {
       //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
       setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
   }
   ensureCursorInScreen()
   render()
}

function getQuoteRanges(expandedLine) {
    // find all the quote ranges.
    // if our cursor is in a quote range selext that first.
    var quoties = "\"'`"
    var backslash = "\\"
    var quoteState = "out"
    var quoteType = ""
    var quoteRanges = []
    for (var i=0; i<expandedLine.length; i++) {
        var chr = expandedLine[i]
        if (quoteState == "out") {
            var theIndex = quoties.indexOf(chr)
            if (theIndex != -1) {
                quoteState = "in"
                quoteType = quoties[theIndex]
                quoteRanges.push(quoteType)
                quoteRanges.push(i+1)
            }
        } else if (quoteState == "in") {
            if (chr == backslash) {
                quoteState = "backslash"
            } else if (chr == quoteType) {
                quoteState = "out"
                quoteType = ""
                quoteRanges.push(i) // exclusive end
            }
        } else if (quoteState == "backslash") {
            quoteState = "in"
        }
    }
    if (quoteRanges.length % 2 != 0) {
        quoteRanges.push(expandedLine.length)
    }
    return quoteRanges
}

var keywords = {
    "function": true,
    "async": true,
    "await": true,
    "of": true,
    "in": true,
    "class": true,
    "if": true,
    "else": true,
    "elif": true,
    "elsif": true,
    "elseif": true,
    "for": true,
    "var": true,
    "break": true,
    "continue": true,
    "return": true,
    "const": true,
    "let": true,
    "switch": true,
    "case": true,
    "default": true,
    "new": true,

    "func": true,
    "def": true,
    "end": true,
    "loop": true,
    "local": true,
    "each": true,
    "go": true,
    "range": true,
    "len": true,
    "make": true,
    "type": true,
    "struct": true,
    "defer": true,
    "bool": true,
    "package": true,
    "import": true,
    "fallthrough": true,
    
    
    "final": true,
    "static": true,
    "public": true,
    "protected": true,
    "use": true,
    "include": true,
    "include_once": true,
    "abstract": true,
    "CONST": true,
    "throw": true,
}

var keywords2 = {
    "nil": true,
    "null": true,
    "true": true,
    "false": true,
    "this": true,
    "self": true,
}
var keywords3 = {
    "error": true,
    "map": true,
    "any": true,
    "string": true,
    "int": true,
    "int64": true,
    "float64": true,
    "interface": true,
    "byte": true,
}
// kind of like getQuoteRanges
var syntaxColorMap = [
    {
        // lightmode
        quote: "red",
        keyword: "blue",
        symbol: "slateblue",
        key: "dodgerblue",
        comment: "rgba(0, 0, 0, 0.5)",
        dotword: "dodgerblue",
        // call: "forestgreen",
        call: "teal",
        dollarword: "brown",
        uppercasefirst: "brown",
        uppercase: "brown",
        keyword2: "magenta",
        keyword3: "brown", 
        number: "coral",
        diffAdd: "green",
        diffSub: "orangered",
    },
    {
        // darkmode
        quote: "thistle",
        keyword: "deepskyblue",
        symbol: "tan",
        key: "cyan",
        comment: "rgba(255, 255, 255, 0.5)",
        dotword: "aquamarine",
        call: "lightgreen",
        dollarword: "khaki",
        uppercasefirst: "darkkhaki",
        uppercase: "lightskyblue",
        keyword2: "lightpink",
        keyword3: "yellowgreen",
        number: "yellow",
    },
    // {
    //     // darkmode
    //     quote: "lightgreen",
    //     comment: "rgba(255, 255, 255, 0.5)",
    //     diffAdd: "lime",
    //     diffSub: "orangered",
    // },
]
function getSyntaxHighlight(expandedLine, prevExpandedLine) {
    var quoties = "\"'`"
    var backslash = "\\"
    var state = "out"
    var quoteType = ""
    if (prevExpandedLine && prevExpandedLine.endState) {
        state = prevExpandedLine.endState
        quoteType = prevExpandedLine.endQuoteType
    }
    var syntaxColors = []
    var curWord = ""
    var quoteStart = -1
    if (expandedLine.syntaxColors) {
        return expandedLine.syntaxColors
    }
    for (var i=0; i<expandedLine.length; i++) {
        var chr = expandedLine[i]
        if (state == "out") {
            var theIndex = quoties.indexOf(chr)
            if (theIndex != -1) {
                state = "inQuote"
                quoteType = quoties[theIndex]
                syntaxColors.push("quote")
                quoteStart = i
            } else if (" \t\r\n".indexOf(chr) != -1) {
                syntaxColors.push("space")
            } else if (isWordyChar(chr, true)) {
                state = "inWord"
                curWord = chr
                syntaxColors.push("word")
            } else if ("/".indexOf(chr) != -1) {
                state = "inFirstForwardSlash"
                syntaxColors.push("symbol")
            } else if ("<".indexOf(chr) != -1) {
                state = "inLessThan"
                syntaxColors.push("symbol")
            } else if ("#".indexOf(chr) != -1) {
                state = "inComment"
                syntaxColors.push("comment")
            } else if ("*".indexOf(chr) != -1 && i == 5) {
                state = "inComment"
                syntaxColors.push("comment")
            } else if ("+".indexOf(chr) != -1 && i == 0) {
                state = "inDiffAdd"
                syntaxColors.push("diffAdd")
            } else if ("-".indexOf(chr) != -1 && i == 0) {
                state = "inDiffSub"
                syntaxColors.push("diffSub")
            } else {
                state = "inSymbol"
                syntaxColors.push("symbol")
            }
        } else if (state == "inWord") {
            if (isWordyChar(chr, true)) {
                curWord += chr
                syntaxColors.push("word")
            } else if (":".indexOf(chr) != -1) {
                syntaxColors.push("symbol")
                for (let j = i-1; j >= i - curWord.length; j--) {
                    syntaxColors[j] = "key"
                }
                state = "out"
                curWord = ""
            } else if ("(".indexOf(chr) != -1) {
                syntaxColors.push("symbol")
                for (let j = i-1; j >= i - curWord.length; j--) {
                    syntaxColors[j] = "call"
                }
                state = "out"
                curWord = ""
            } else if (".".indexOf(chr) != -1 || (chr == "-" && expandedLine[i+1] == ">")) {
                if (curWord in keywords || curWord.toUpperCase() == curWord) {
                    // as if abc
                    // 0123456789
                    for (let j = i-1; j >= i - curWord.length; j--) {
                        syntaxColors[j] = "keyword"
                    }
                }
                syntaxColors.push("symbol")
                state = "inDotWord"
                curWord = ""
                
                if (chr == "-") {
                    syntaxColors.push("symbol")
                    i++
                }
            } else {
                other = true
                if (curWord in keywords) {
                    // as if abc
                    // 0123456789
                    for (let j = i-1; j >= i - curWord.length; j--) {
                        syntaxColors[j] = "keyword"
                    }
                } else if (curWord in keywords2) {
                    for (let j = i-1; j >= i - curWord.length; j--) {
                        syntaxColors[j] = "keyword2"
                    }
                } else if (curWord in keywords3) {
                    for (let j = i-1; j >= i - curWord.length; j--) {
                        syntaxColors[j] = "keyword3"
                    }
                } else if (curWord.replaceAll("_", "") - 0 == curWord) {
                    for (let j = i-1; j >= i - curWord.length; j--) {
                        syntaxColors[j] = "number"
                    }
                } else if (curWord.toUpperCase() == curWord) {
                    for (let j = i-1; j >= i - curWord.length; j--) {
                        syntaxColors[j] = "uppercase"
                    }
                } else if (curWord[0].toUpperCase() == curWord[0]) {
                    for (let j = i-1; j >= i - curWord.length; j--) {
                        syntaxColors[j] = "uppercasefirst"
                    }
                }
                curWord = ""
                i--
                state = "out"
            }
            if (i == expandedLine.length - 1) {
                if (curWord in keywords) {
                    // as if
                    // 0123456789
                    for (let j = i; j >= i - curWord.length+1; j--) {
                        syntaxColors[j] = "keyword"
                    }
                } else if (curWord in keywords2) {
                    for (let j = i; j >= i - curWord.length+1; j--) {
                        syntaxColors[j] = "keyword2"
                    }
                } else if (curWord in keywords3) {
                    for (let j = i; j >= i - curWord.length+1; j--) {
                        syntaxColors[j] = "keyword3"
                    }
                } else if (curWord.replaceAll("_", "") - 0 == curWord) {
                    for (let j = i; j >= i - curWord.length+1; j--) {
                        syntaxColors[j] = "number"
                    }
                } else if (curWord.toUpperCase() == curWord) {
                    for (let j = i; j >= i - curWord.length+1; j--) {
                        syntaxColors[j] = "uppercase"
                    }
                } else if (curWord[0].toUpperCase() == curWord[0]) {
                    for (let j = i; j >= i - curWord.length+1; j--) {
                        syntaxColors[j] = "uppercasefirst"
                    }
                }
            }
        } else if (state == "inDotWord") {
            if (isWordyChar(chr, true)) {
                curWord += chr
                syntaxColors.push("dotword")
            } else if (".".indexOf(chr) != -1 || (chr == "-" && expandedLine[i+1] == ">")) {
                syntaxColors.push("symbol")
                state = "inDotWord"
                curWord = ""
                if (chr == "-") {
                    syntaxColors.push("symbol")
                    i++
                }
            } else if ("(".indexOf(chr) != -1) {
                syntaxColors.push("symbol")
                for (let j = i-1; j >= i - curWord.length; j--) {
                    syntaxColors[j] = "call"
                }
                curWord = ""
                state = "out"
            } else {
                i--
                state = "out"
                curWord = ""
            }
        } else if (state == "inDollarWord") {
            if (isWordyChar(chr, true)) {
                curWord += chr
                syntaxColors.push("dollarword")
            } else if (".".indexOf(chr) != -1 || (chr == "-" && expandedLine[i+1] == ">")) {
                syntaxColors.push("symbol")
                state = "inDotWord"
                curWord = ""
                if (chr == "-") {
                    syntaxColors.push("symbol")
                    i++
                }
            } else if ("(".indexOf(chr) != -1) {
                syntaxColors.push("symbol")
                for (let j = i-1; j >= i - curWord.length; j--) {
                    syntaxColors[j] = "call"
                }
                curWord = ""
                state = "out"
            } else {
                i--
                state = "out"
                curWord = ""
            }
        } else if (state == "inFirstForwardSlash") {
            if ("/".indexOf(chr) != -1) {
                state = "inComment"
                syntaxColors[i-1] = "comment"
                syntaxColors.push("comment")
            } else if ("*".indexOf(chr) != -1) {
                state = "inOtherComment"
                syntaxColors[i-1] = "comment"
                syntaxColors.push("comment")
            } else {
                state = "inSymbol"
                i--
            }
        } else if (state == "inLessThan") {
            if ("!".indexOf(chr) != -1) {
                state = "maybeInHtmlComment1"
                syntaxColors.push("symbol")
            } else {
                state = "inSymbol"
                i--
            }
        } else if (state == "maybeInHtmlComment1") {
            if ("-".indexOf(chr) != -1) {
                state = "maybeInHtmlComment2"
                syntaxColors.push("symbol")
            } else {
                state = "inSymbol"
                i--
            }
        } else if (state == "maybeInHtmlComment2") {
            if ("-".indexOf(chr) != -1) {
                state = "inHtmlComment"
                syntaxColors[i-1] = "comment" // -
                syntaxColors[i-2] = "comment"// !
                syntaxColors[i-3] = "comment" // <
                syntaxColors.push("comment")
            } else {
                state = "inSymbol"
                i--
            }
        } else if (state == "inSymbol") {
            // we aren't keeping track of symbols for now so
            if (expandedLine[i -1] == "$" && isWordyChar(chr, true)) {
                state = "inDollarWord"
                curWord = chr
                syntaxColors.push("dollarword")
            } else {
                i--
                state = "out"
            }
        } else if (state == "inComment") {
            syntaxColors.push("comment")
        } else if (state == "inOtherComment") {
            if ("*".indexOf(chr) != -1) {
                state = "maybeEndOtherComment"
            }
            syntaxColors.push("comment")
        } else if (state == "maybeEndOtherComment") {
            if ("/".indexOf(chr) != -1) {
                state = "out"
            }
            syntaxColors.push("comment")
        } else if (state == "inHtmlComment") {
            if ("-".indexOf(chr) != -1) {
                state = "maybeEndHtmlComment1"
            }
            syntaxColors.push("comment")
        } else if (state == "maybeEndHtmlComment1") {
            if ("-".indexOf(chr) != -1) {
                state = "maybeEndHtmlComment2"
            } else {
                state = "inHtmlComment"
            }
            syntaxColors.push("comment")
        } else if (state == "maybeEndHtmlComment2") {
            if (">".indexOf(chr) != -1) {
                state = "out"
            } else {
                state = "inHtmlComment"
            }
            syntaxColors.push("comment")
        } else if (state == "inDiffAdd") {
            syntaxColors.push("diffAdd")
        } else if (state == "inDiffSub") {
            syntaxColors.push("diffSub")
        } else if (state == "inQuote") {
            if (chr == backslash) {
                state = "backslashInQuote"
                syntaxColors.push("quote")
            } else if (chr == quoteType) {
                state = "out"
                quoteType = ""
                syntaxColors.push("quote")
                // peek ahead
                if (":".indexOf(expandedLine[i+1]) != -1) {
                    for (let j = quoteStart; j <= i; j++) {
                        syntaxColors[j] = "key"
                    }
                }
            } else {
                syntaxColors.push("quote")
            }
        } else if (state == "backslashInQuote") {
            syntaxColors.push("quote")
            state = "inQuote"
        }
    }
    expandedLine.syntaxColors = syntaxColors
    if (state == "inOtherComment" || state == "inHtmlComment" || state == "inQuote") {
        expandedLine.endState = state
        if (state == "inQuote") {
            expandedLine.endQuoteType = quoteType
        }
    } else {
        expandedLine.endState = ""
    }
    return syntaxColors
}

var overflowX = 0
var overflowY = 0
var iframeOverflowX = 0
var isDragKeyboard = false
var touchCount = 0
var isSelectedFromTopThird = false
var isLongPress = false
var shouldOpenEditorCommand = false
var minSpaceForHeader = 2

function onStart(e) {
    isMoving = true
    touchCount = e.touches.length
    e.preventDefault()
    // this handles all the touch interactions
    // first define the closuure functions
    isSelectedFromTopThird = false
    // this is global
    isLongPress = false
    shouldOpenEditorCommand = false
    
    if (e.touches.length == 1) {
        longPressAction = function() {
            isLongPress = true // prevents regular onEnd handling from happening.
            touchAreasLongPress(e, {onMove:onMove, selectAction: selectAction})
        }
        selectAction = function(forceLines = false, leftSideFeature = false) {
            // return early in case we are already selecting
            if (cursorType == "select") {
                // TODO: I think we can get rid of cursorType ans just use selectedRegions.length
                return
            }
            fx.selectedRegions = []
            cursorType = "select"
            var line = fx.lines[fx.cursorLineIndex] || ""
            

            // Note how the stopY is inclusive
            // But the stopX is exclusive.
            // for some reason seemed natural to do it like that
            if (forceLines || fx.cursorColIndex < 0) {
                selectedRegion.startX = 0
                selectedRegion.startY = bind(fx.cursorLineIndex, 0, fx.lines.length-1)
                selectedRegion.stopX = expandTabIndex(line, line.length)
                selectedRegion.stopY = bind(fx.cursorLineIndex, 0, fx.lines.length - 1)
                selectedRegion.stopped = true
                selectMode = "line"
            } else if (leftSideFeature) {
                selectedRegion.startY = fx.cursorLineIndex
                selectedRegion.startX = fx.cursorColIndex
                selectedRegion.stopY = fx.cursorLineIndex
                selectedRegion.stopX = fx.cursorColIndex + 1
                selectedRegion.stopped = true
                // TODO: selectMode should go on fx
                selectMode = "char"
            } else {
                var w = getWordAtCursor()
                if (w.word != "") {
                    // #selectword
                    selectedRegion.startY = fx.cursorLineIndex
                    selectedRegion.startX = expandTabIndex(line, w.start)
                    selectedRegion.stopY = fx.cursorLineIndex
                    selectedRegion.stopX = expandTabIndex(line, w.end)
                    selectedRegion.stopped = true
                    //  setting this causes it to unselect on mouse up
                    selectedRegion.selectedWord = true
                    selectedRegion.origStartX = bind(fx.cursorColIndex, 0, expandTabIndex(line, line.length))
                    // selectedRegion.origStopX = bind(fx.cursorColIndex, 0, expandTabIndex(line, line.length))
                    // fx.cursorColIndex = w.end
                    // updateCursorXY()
                    // ensureCursorInScreen()
                } else {
                    selectedRegion.startX = bind(fx.cursorColIndex, 0, expandTabIndex(line, line.length))
                    selectedRegion.startY = bind(fx.cursorLineIndex, 0, fx.lines.length-1)
                    selectedRegion.stopX = bind(fx.cursorColIndex, 0, expandTabIndex(line, line.length))
                    selectedRegion.stopY = bind(fx.cursorLineIndex, 0, fx.lines.length - 1)
                }
                // expandSelectTimeout = setTimeout(expandSelection, expandSelectTimeoutMillis)
                expandSelectTimeout = setTimeout(function () {
                    //  un setting this causes it to not unselect on mouse up
                    selectedRegion.selectedWord = false
                }, expandSelectTimeoutMillis)
                selectMode = "char"
            }
            fx.selectedRegions.push(selectedRegion)
            render()
        }
    }

    var hasDoneOverflowXAction = false
    hasDoneOverflowYAction = false
    var hasNavedBack = false
    var startCursorColIndex = fx.cursorColIndex
    var startCursorLineIndex = fx.cursorLineIndex

    var onMove = function(e) {
        isMoving = true
        lastFindWasHighlightText = false
        lastAction = "move"
        lastSearchDirForSameTerm = ""
        shouldAutocompleteLine = false
        hasMovedSinceNewLine = true
        hasMovedSinceCut = true
        ghostSelection = null
        ghostSelectionComment = null
        wasDelete = false // so a previous delete doesn't cause split line when you don't want
        acWord = null
        aclV2 = null
        // log("moved: " + Date.now()) // red marker
        clearTimeout(selectTimeout)
        clearTimeout(expandSelectTimeout)
        if (e.touches.length > 1) {
            return
        }
        if (cursorType != "select") {
            selectTimeout = setTimeout(selectAction, selectTimeoutMillisMove)
            
            // yay selectRegion selectArea // yellow marker
            if (false) { // see the other selectRegion
                var bbox = c.getBoundingClientRect()
                // if (startTouchX > (bbox.width * 2 / 3)) {
                // if (startTouchX > (bbox.width * 4 / 5)) {
                // XXXXXXXXXXXX...
                // XXXXXXXXXX.....
                if (startTouchX > (bbox.width * 4 / 5)) {
                    selectAction(true)
                    // bad name now
                    // if (touchTopTopTopTopMiddle_Right()) {
                    //     return
                    // }
                } else if (startTouchX < (bbox.width * 1 / 5)) {
                    selectAction(false)
                }
            }
        }
        
        var diffTouchX = e.touches[0].pageX - startTouchX
        var diffTouchY = e.touches[0].pageY - startTouchY
        //cursorX = bind(startX + diffTouchX*touchScale, 0, canvasWidth)
        //cursorY = bind(startY + diffTouchY*touchScale, 0, canvasHeight)

        moved = true
        if (diffTouchX > 10 || diffTouchY > 10) {
            movedWithBuffer = true
        }
        var diffLastTouchX = e.touches[0].pageX - lastTouchX
        var diffLastTouchY = e.touches[0].pageY - lastTouchY
        var signX = diffLastTouchX < 0 ? -1: 1
        var signY = diffLastTouchY < 0 ? -1 : 1
        thePow = firstMove ? 1 : 2

        // other attempt at #snappingCursor
        // var charBefore = fx.lines[fx.cursorLineIndex][u(fx.cursorColIndex)-1] || ""
        // var charAfter = fx.lines[fx.cursorLineIndex][u(fx.cursorColIndex)]  || ""
        // var oldTouchScaleX = touchScaleX
        // // if (((charBefore != charAfter) && (!isWordy(charBefore.charAt(0))) || !isWordy(charAfter.charAt(0))) || fx.cursorColIndex == 0 || fx.cursorColIndex == expandTabIndex(fx.lines[fx.cursorLineIndex], -1)) {
        // if ((charBefore != charAfter) && (!isWordy(charBefore.charCodeAt(0)) || !isWordy(charAfter.charCodeAt(0))) ) {
        //     touchScaleX = touchScaleX / 10
        // }
        if (!lockX) {
            var toAddX = ensureSign(signX, Math.round(Math.pow(diffLastTouchX, thePow)*touchScaleX))
            cursorX = cursorX + toAddX
            if (fx.iframe) {
                fx.iframeCursorX += toAddX/3
            }
        }
        // touchScaleX = oldTouchScaleX

        var toAddY = ensureSign(signY, Math.round(Math.pow(diffLastTouchY, thePow)*touchScaleY))
        if (!hasDoneOverflowYAction) {
            cursorY = cursorY + toAddY
        }
        if (fx.iframe) {
            fx.iframeCursorY += toAddY/3
        }
        
        
        lastTouchX = e.touches[0].pageX
        lastTouchY = e.touches[0].pageY
        if (fx.iframe) {
            // TODO! cache the clientHeights? like globally even?
            var iframeChangedY = false
            if (fx.iframeCursorY > fx.iframeWrapper.clientHeight) {
                var extendY = fx.iframeCursorY - fx.iframeWrapper.clientHeight
                fx.iframeCursorY = fx.iframeWrapper.clientHeight
                var wantScrollTop = fx.iframeWrapper.scrollTop + extendY
                if (wantScrollTop > fx.iframe.clientHeight*iframeScale - fx.iframeWrapper.clientHeight) {
                    var oldScrollTop = fx.iframeWrapper.scrollTop
                    fx.iframeWrapper.scrollTop = fx.iframe.clientHeight*iframeScale - fx.iframeWrapper.clientHeight
                    // fx.iframe.contentWindow.scrollY += wantScrollTop - (oldScrollTop - fx.iframeWrapper.scrollTop)
                    // var n
                    // subtract one because at the edge it doesn't get an element?
                    var el = fx.iframe.contentWindow.document.elementFromPoint(fx.iframeCursorX + fx.iframeWrapper.scrollLeft, fx.iframeCursorY + fx.iframeWrapper.scrollTop - 1);
                    var nextScrollableElement = getNextScrollableElement(el, fx.iframe.contentWindow.document.body)
                    if (nextScrollableElement == fx.iframe.contentWindow.document.body) {
                        fx.iframe.contentWindow.scrollTo(fx.iframe.contentWindow.scrollX, fx.iframe.contentWindow.scrollY + wantScrollTop - (oldScrollTop - fx.iframeWrapper.scrollTop) - oldScrollTop)
                    } else {
                        nextScrollableElement.scrollTop = nextScrollableElement.scrollTop + wantScrollTop - (oldScrollTop - fx.iframeWrapper.scrollTop) - oldScrollTop
                    }
                } else {
                    fx.iframeWrapper.scrollTop = wantScrollTop
                }
                iframeChangedY = true
            } else if (fx.iframeCursorY < 0) {
                var extendY = fx.iframeCursorY
                fx.iframeCursorY = 0
                var wantScrollTop = fx.iframeWrapper.scrollTop + extendY
                if (wantScrollTop < 0) {
                    var oldScrollTop = fx.iframeWrapper.scrollTop
                    fx.iframeWrapper.scrollTop = 0
                    var el = fx.iframe.contentWindow.document.elementFromPoint(fx.iframeCursorX + fx.iframeWrapper.scrollLeft, fx.iframeCursorY + fx.iframeWrapper.scrollTop + 1);
                    var nextScrollableElement = getNextScrollableElementUp(el, fx.iframe.contentWindow.document.body)
                    if (nextScrollableElement == fx.iframe.contentWindow.document.body) {
                        fx.iframe.contentWindow.scrollTo(fx.iframe.contentWindow.scrollX, fx.iframe.contentWindow.scrollY + wantScrollTop - (oldScrollTop - 0) - oldScrollTop)
                    } else {
                        nextScrollableElement.scrollTop = nextScrollableElement.scrollTop + wantScrollTop - (oldScrollTop - 0) - oldScrollTop
                    }
                } else {
                    fx.iframeWrapper.scrollTop = wantScrollTop
                }
                iframeChangedY = true
            }

            if (fx.iframeCursorX > fx.iframeWrapper.clientWidth) {
                var extendX = fx.iframeCursorX - fx.iframeWrapper.clientWidth
                fx.iframeCursorX = fx.iframeWrapper.clientWidth
                if (!iframeChangedY) {
                    var wantScrollLeft = fx.iframeWrapper.scrollLeft + extendX
                    if (wantScrollLeft > fx.iframe.clientWidth*iframeScale - fx.iframeWrapper.clientWidth) {
                        var oldScrollLeft = fx.iframeWrapper.scrollLeft
                        fx.iframeWrapper.scrollLeft = fx.iframe.clientWidth*iframeScale - fx.iframeWrapper.clientWidth
                        // nextScrollableElement for x direction not yet implemented
                        var nextScrollableElement = fx.iframe.contentWindow.document.body
                        if (nextScrollableElement == fx.iframe.contentWindow.document.body) {
                            fx.iframe.contentWindow.scrollTo(fx.iframe.contentWindow.scrollX + wantScrollLeft - (oldScrollLeft - fx.iframeWrapper.scrollLeft) - oldScrollLeft, fx.iframe.contentWindow.scrollY)
                        } else {
                            nextScrollableElement.scrollLeft = nextScrollableElement.scrollLeft + wantScrollLeft - (oldScrollLeft - fx.iframeWrapper.scrollLeft) - oldScrollLeft
                        }
                    } else {
                        fx.iframeWrapper.scrollLeft = wantScrollLeft
                    }
                }
            } else if (fx.iframeCursorX < 0) {
                var extendX = fx.iframeCursorX
                fx.iframeCursorX = 0
                if (!iframeChangedY) fx.iframeWrapper.scrollLeft += extendX

                // if (fx.iframeWrapper.scrollLeft < 0) {
                //     iframeOverflowX += -marginLeft - fx.iframeWrapper.scrollLeft
                //     fx.iframeWrapper.scrollLeft = -marginLeft
                // }
                // // TODO: come back to startcursorcolindex
                // if (iframeOverflowX > 75 && !hasNavedBack && startCursorColIndex == -marginLeft) {
                //     hasNavedBack = true
                //     fx.iframe.contentWindow.history.back()
                //     saveWorkspace()
                //     iframeOverflowX = 0
                // }
            }

            // show element?
            // fx.currentElement = fx.iframe.contentWindow.document.elementFromPoint(Math.round(fx.iframeCursorX + fx.iframeWrapper.scrollLeft), Math.round(fx.iframeCursorY + fx.iframeWrapper.scrollTop));
            var el = fx.iframe.contentWindow.document.elementFromPoint((fx.iframeCursorX + fx.iframeWrapper.scrollLeft), (fx.iframeCursorY + fx.iframeWrapper.scrollTop));
            if (el) {
                fx.currentElement = el
            }
        }

        var changedY = false
        //var maxHeight = canvasHeight
        var maxHeight = (maxLines -1 ) * fontHeight

        // var minAllowedY = headers.length * fontHeight
        var minAllowedY = minSpaceForHeader * fontHeight
        if (fx.offsetY <= minSpaceForHeader) {
            minAllowedY = 0
        }
        // var minAllowedY = 0

        if (cursorY > maxHeight) {
            var extendY = cursorY - maxHeight
            cursorY = maxHeight
            fx.offsetY += Math.ceil(extendY/fontHeight)
            changedY = true
            // maxOffsetY = max(0, fx.lines.length)
            // var maxOffsetY = max(0, fx.lines.length - maxLines)
            var maxOffsetY = max(0, fx.lines.length - 10)
            if (fx.offsetY > maxOffsetY) {
                overflowY += (fx.offsetY - maxOffsetY)
                fx.offsetY = maxOffsetY
            }
            if (overflowY > 50 && !hasDoneOverflowYAction && startCursorLineIndex >= fx.lines.length-1) {
                clearLog()
                hasDoneOverflowYAction = true
                overflowY = 0
            }
        // } else if (cursorY < 0) {
        } else if (cursorY < minAllowedY) {
            var extendY = cursorY - minAllowedY
            cursorY = minAllowedY
            fx.offsetY += Math.floor(extendY/fontHeight)
            changedY = true
            // if (fx.offsetY < -minSpaceForHeader) {
            //     overflowY += fx.offsetY
            //     fx.offsetY = -minSpaceForHeader
            // }
            if (fx.offsetY < 0) {
                overflowY += fx.offsetY
                fx.offsetY = 0
            }
            if (overflowY < -50 && !hasDoneOverflowYAction && startCursorLineIndex == 0) {
                if (fx.fileMode == "shell") {
                    runShellCommand("cd ..")
                } else {
                    // removing this feature
                    // reloadFile()
                }
                hasDoneOverflowYAction = true
                overflowY = 0
            }
        }

        var maxWidth = (maxCols -1) * fontWidth
        //var maxWidth = canvasWidth
        if (cursorX > maxWidth) {
            var extendX = cursorX - maxWidth
            cursorX = maxWidth
            // if (!changedY) fx.offsetX += Math.round(extendX/fontWidth)
            if (!changedY) fx.offsetX += Math.ceil(extendX/fontWidth)
        } else if (cursorX < 0) {
            var extendX = cursorX
            cursorX = 0
            // if (!changedY) fx.offsetX += Math.round(extendX/fontWidth)
            if (!changedY) fx.offsetX += Math.floor(extendX/fontWidth)

            var prevOffsetX = fx.offsetX
            if (fx.offsetX < -fx.marginLeft) {
                // Sign is inconsistent
                overflowX += -fx.marginLeft - fx.offsetX
                fx.offsetX = -fx.marginLeft
            }

            // attempt 1 at swiping left to do an action
            // if (!hasSwitchedFile && !changedY && startCursorColIndex == -marginLeft && prevOffsetX < -20) {
            //     hasSwitchedFile = true
            //     seeFiles()
            //     // moveFileAllTheWayLeft()
            //     // saveWorkspace()
            // }

            // attempt 2 at swiping left to do an action
            if (overflowX > 75 && !hasDoneOverflowXAction && startCursorColIndex == -fx.marginLeft) {
                hasDoneOverflowXAction = true
                // seeFiles()
                moveFileAllTheWayLeft()
                saveWorkspace()
                overflowX = 0
            }
        }
        var oldCursorLineIndex = fx.cursorLineIndex
        // maybe have a setter for this?
        fx.cursorLineIndex = Math.round(cursorY/fontHeight) + fx.offsetY
        if (oldCursorLineIndex != fx.cursorLineIndex && dirtyInput) {
            saveUndo()
            dirtyInput = false
        }

        // TODO: this so we can get into full line autocomplete mode
        // by scrolling into an empty line and starting to type
        // wondering if this is optimal enough.
        var _line = fx.lines[fx.cursorLineIndex] || ""
        if (_line.trim() == "") {
            hasMovedSinceNewLine = false
        }
        var oldCursorColIndex = fx.cursorColIndex
        fx.cursorColIndex = Math.round(cursorX/fontWidth) + fx.offsetX

        // #snappingCursor try 3
        // this was the best of the 3
        if (false && oldCursorColIndex != fx.cursorColIndex) {
            var theIndex =  u(oldCursorColIndex)
            var theLine = fx.lines[fx.cursorLineIndex] || ""
            // var theChar = theLine.charCodeAt(theIndex)
            if (signX == -1 && theIndex > 0 && theIndex < theLine.length) {
                fx.cursorColIndex = expandTabIndex(theLine, findPrevCharClass(theLine, theIndex-1))
                updateCursorXY()
            } else if (signX == 1 && theIndex > 0 && theIndex < theLine.length) {
                fx.cursorColIndex = expandTabIndex(theLine, findNextCharClass(theLine, theIndex))
                updateCursorXY()
            }
        }

        firstMove = false
        // log(cursorType + (Date.now()))
        // log(selectedRegion)
        // selectamundo
        if (cursorType == "select") {
            overflowX = 0
            overflowY = 0
            moveSelectionToCursor(selectedRegion)
        }
        // attempt at #snappingCursor
        // TODO: also look at snapping away whitespace
        // var w = getWordAtCursor()
        // if (w.word != "") {
        //     var theLine = fx.lines[fx.cursorLineIndex] || ""
        //     var wordStartX = expandTabIndex(theLine, w.start)
        //     var wordEndX = expandTabIndex(theLine, w.end)
        //     var percentInWord = (fx.cursorColIndex - wordStartX) / (wordEndX - wordStartX)
        //     if (signX == 1 && percentInWord >= .5 && fx.cursorColIndex != wordEndX) { // movedRight
        //         fx.cursorColIndex = wordEndX
        //         updateCursorXY()
        //     } else if (signX == -1 && percentInWord <= .5 && fx.cursorColIndex != wordStartX) { // movedLeft
        //         fx.cursorColIndex = wordStartX
        //         updateCursorXY()
        //     }
        // }


        var w = getWordAtCursor()
        if (w.word) {
            wordAtCursor = w.word
            wordAtCursorRegexp = new RegExp("(\\b" + wordAtCursor + "\\b)", "g")
        } else {
            wordAtCursor = ""
            wordAtCursorRegexp = null
        }
        render()
        // See comment in render asking if we need to do this here too
        // this optimization was for Nokia 1.4,
    	if (agressiveRender || (touchCount == 0 && document.activeElement == theText)) {
            if (document.activeElement == theText) {
                setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
            }
        }

        return false
    }
    var onEnd = function(e) {
        isMoving = false
        overflowX = 0
        overflowY = 0
        touchCount = e.touches.length
        var touchType = e.changedTouches[0].touchType
        clearTimeout(selectTimeout)
        clearTimeout(expandSelectTimeout)
        if (e.touches.length != 0) {
            return
        }
        
        var absMoveX = Math.abs(startX - cursorX)
        var absMoveY = Math.abs(startY - cursorY)
        if (absMoveY > (2 * absMoveX)) {
            lastDirection = "vertical"
        } else if (absMoveX > (2 * absMoveY)) {
            lastDirection = "horizontal"
        }

         //         fx.cursorColIndex = wordEndX
        // Testing isDragKeyboard feature red marker
        var sr = fx.selectedRegions[0]
        if (sr) { 
            if (sr.selectedWord) {
                copy()
                fx.selectedRegions = []
                cursorType = "move"
            }
            if (sr.selectedLine) {
                copy()
                fx.selectedRegions = []
                cursorType = "move"
            }
            // for now you can only select down right
            if (sr.startY > sr.stopY) {
                fx.selectedRegions = []
                cursorType = "move"
            } else if (sr.startY == sr.stopY && sr.startX > sr.stopX && selectMode == "char") {
                fx.selectedRegions = []
                cursorType = "move"
            } else if (sr.startX == sr.stopX && sr.startY == sr.stopY && selectMode == "char") {
                // testing selectMode is char, meaning they didnt select in the margin
                fx.selectedRegions = []
                cursorType = "move"
                // New mode
                // isDragKeyboard = true
                // fx.selectedRegions = []
                // should we return early here?
                // # selectWord, selectWord is done by holding down now
                
                // var w = getWordAtCursor()
                // if (w.word != "") {
                //     var theLine = fx.lines[fx.cursorLineIndex] || ""
                //     sr.startY = fx.cursorLineIndex
                //     sr.startX = expandTabIndex(theLine, w.start)
                //     sr.stopY = fx.cursorLineIndex
                //     sr.stopX = expandTabIndex(theLine, w.end)
                // } else {
                //     fx.selectedRegions = []
                // }
            }
        }

        document.body.removeEventListener("touchmove", onMove)
        moveListenerCount = max(moveListenerCount-1, 0)
        document.body.removeEventListener("touchend", onEnd)
        endListenerCount = max(endListenerCount-1, 0)
        
        if (isLongPress) {
            return
        }

        // it's not straightforward to do a setTimeout
        // here because iOS Safari doesn't like to focus
        // text elements when not responding to user action
        // maybe there are workarounds.
        var countedAsMoved = moved
        if (touchType == "stylus") {
            countedAsMoved = movedWithBuffer
        }
        
        // TODO: Should we get rid of cursorType variable and just use fx.selectedRegions?
        // did if false here because decided against tap top to aauto
        if (false && !countedAsMoved && cursorType == "select") {
            if (isSelectedFromTopThird) {
                isSelectedFromTopThird = false
                cursorType = "move"
                // #duplicateline
                copy()
                paste()
                fx.selectedRegions = []
                cursorType = "move"
                render()
                return
            }
        } else if (!countedAsMoved && cursorType == "move") {
            // balooga coral marker
            touchAreasPress(e, {onMove:onMove, selectAction: selectAction})
            // the fallthrough
        }

        cursorType = "move"
        render()
    }

    var onMoveWhileSelected = function(e) {
        moved = true
        var diffStartTouchX = e.touches[0].pageX - startTouchX
        var diffStartTouchY = e.touches[0].pageY - startTouchY
        lastTouchX = e.touches[0].pageX
        lastTouchY = e.touches[0].pageY
        clearTimeout(selectTimeout)
        if (Math.abs(diffStartTouchX) < 5 && Math.abs(diffStartTouchY) < 5) {
            return
        }
        if (Math.abs(diffStartTouchX) > Math.abs(diffStartTouchY)) {
            if (diffStartTouchX < 0) {
                dedent()
            } else {
                indent()
            }
        } else {
            if (diffStartTouchY < 0) {
                del()
            } else {
                copy()
            }
        }
        // stop handling it once it's handled
        document.body.removeEventListener("touchmove", onMoveWhileSelected)
        moveListenerCount = max(moveListenerCount-1, 0)
    }
    var onEndWhileSelected = function(e) {
        overflowX = 0
        overflowY = 0
        touchCount = e.touches.length
        clearTimeout(selectTimeout)

        document.body.removeEventListener("touchmove", onMoveWhileSelected)
        document.body.removeEventListener("touchmove", onMove) // because it sometimes can be like this
        moveListenerCount = max(moveListenerCount-1, 0)
        document.body.removeEventListener("touchend", onEndWhileSelected)
        endListenerCount = max(endListenerCount-1, 0)
        if (isLongPress) {
            // log("longPress so skipping default action")
            return
        }

        var sr = fx.selectedRegions[0]
        // log("on end while selected")
        if (!moved && sr) {
            // Note: add more actions, and try to be consistent-ish
            // note there is no long press here. should I add?
            // ideas:
            //    run script
            //    chat gpt

            touchAreasPressWhileSelected(e)
        }
        render()
    }

    var onEndForEdges = function(e) {
        overflowX = 0
        overflowY = 0
        touchCount = e.touches.length
        document.body.removeEventListener("touchend", onEndForEdges)
        clearTimeout(moveHomeEndTimeout)
        clearTimeout(cleanUpFilesTimeout)
        render()
    }

    var startTouchX = e.touches[0].pageX
    var startTouchY = e.touches[0].pageY
    var startX = cursorX
    var startY = cursorY
    var lastTouchX = startTouchX
    var lastTouchY = startTouchY
    var lastTime = Date.now()
    var firstMove = true
    var moved = false
    var movedLong = false
    var prevCopyBufferForTouch = null
    var movedWithBuffer = false
    selectedRegion = {}
    if (fx.selectedRegions.length) {
        // for select, lift finger, move on right side
        selectedRegion = fx.selectedRegions[0]
    }

    var touchTopTopTopTopMiddle_Left = function() {
        var startFontScale = fontScale
        var onMoveForZoom = function (e) {
            var diffTouchX = e.touches[0].pageX - startTouchX
            var diffTouchY = e.touches[0].pageY - startTouchY
            fontScale = startFontScale * (1 + (diffTouchY/100))
            updateFontScale()
            ensureCursorInScreen()
            updateCursorXY()
        }
        var onEndForZoom = function (e) {
            document.body.removeEventListener("touchmove", onMoveForZoom)
            document.body.removeEventListener("touchmove", onEndForZoom)
        }
        document.body.addEventListener("touchmove", onMoveForZoom)
        document.body.addEventListener("touchend", onEndForZoom)
        return true
    }
    var touchTopTopTopTopMiddle_Right = function() {
        if (fx.selectedRegions.length == 0) {
            isSelectedFromTopThird = true
            // see onEndWhileSelected for one way to duplicate line (#duplicateline)
            selectAction(true)
    
            // TODO: maybe figure out how to not copy paste this?
            // See where this is called for an idea
            document.body.addEventListener("touchmove", onMove)
            moveListenerCount += 1
            document.body.addEventListener("touchend", onEnd)
            endListenerCount += 1
            return true
        } else {
            selectBlock()
            // there are other ways to duplicate the line and tapping here while selected
            // # duplicateline #duplicatelinefromtop
            // #duplicateselection
            // var oldSelectedRegions = fx.selectedRegions
            // copy()
            // paste(true) // true here means unselect
            // fx.selectedRegions = oldSelectedRegions
            // render()
            // return
        }
        return false
    }
    
    
    // alert("yay edges") white marker
    // #clickedges #touchedges #tapedges // lime marker
    // scroll right and left and move cursor right and left or up and down
    // TODO: remove some duplication here. especially the bounds checks. Make a setter functions.
    // We divide by 3 because of the whole, points vs pixels
    // if (false) {
    // 
    // }
    
    var handled
    if (e.touches.length == 1) {
        handled = handleTouchAreas(e, {
            "5farLeft": undo,
            "5farRight": redo,
            "4farLeft": function() {
                seeFiles()
                cleanUpFilesTimeout = setTimeout(cleanUpFiles, 300)
            },
            "4farRight": function() {
                setCurrentFile(lastFile) // alt tab, alt+tab
            },
            "3farLeft": function () {
                moveHomeEndDirection = "up"
                moveHomeEndTimeout = setTimeout(moveHomeEndAction, moveHomeEndTimeoutMillis)
        
                // if (fx.highlightText) {
                if (false && highlightMatchesSingleRegExp) {
                    prevHighlightText()
                // } else if (searchText.value !== "" && !fx.selectedRegions.length) {
                // } else if (!fx.selectedRegions.length || selectMode == "char") {
                } else if (true) {
                    findUp()
                }
            },
            "3farRight": function () {
                moveHomeEndDirection = "down"
                moveHomeEndTimeout = setTimeout(moveHomeEndAction, moveHomeEndTimeoutMillis)
                // if (fx.highlightText) {
                if (false && highlightMatchesSingleRegExp) {
                    nextHighlightText()
                // } else if (!fx.selectedRegions.length || selectMode == "char") {
                } else if (true) {
                    findDown()
                }
            },
            "2farLeft": navFileLeft,
            "2farRight": navFileRight,
            "1farLeft": function () {
                if (fx.selectedRegions.length) {
                    if (selectMode == "char") {
                        moveSelectionLeft()
                    } else {
                        dedent()
                        ghostSelection = fx.selectedRegions[0]
                        fx.selectedRegions = []
                    }
                } else if (fx.fileMode == "fileList" || fx.fileMode == "directory") {
                    goUpFileList()
                } else if (ghostSelection) {
                    dedent(ghostSelection)
                } else if (ghostSelectionComment) {
                    dedent(ghostSelectionComment)
                } else {
                    if (fx.cursorColIndex <= getExpandedIndentLength(fx.lines[fx.cursorLineIndex]) - globalTabStop) {
                        dedent()
                    } else {
                        moveCursorLeft()
                    }
                    // if (lastDirection == "horizontal") {
                    //     moveCursorLeft()
                    // } else {
                    //     moveCursorUp()
                    // }
                }
            },
            // If you don't have a sliceLeft then default
            // of character selecting will happen
            // "3sliceLeft": function () {
            //     clearSearch()
            // },
            // "3sliceRight": function () {
            //     clearSearch()
            // },
            // "2sliceLeft": function () {
            //     moveCursorUp()
            // },
            // "1sliceLeft": function () {
            //     moveCursorLeftSnap()
            //     // moveCursorDown()
            // },
            "1sliceRight": function () {
                // moveCursorRightSnap()
                backspace()
                // reusing the timeout, maybe name it
                // longTouchEdgesTimeout
                moveHomeEndTimeout = setTimeout(function () {
                    deleteToBeginningOfLine()
                    mergeLastUndos(2)
                }, moveHomeEndTimeoutMillis)
            },
            "1sliceLeft": function () {
                // moveCursorRightSnap()
                addSpace()
                moveHomeEndTimeout = setTimeout(function () {
                    backspace()
                    deleteToEndOfLine()
                    mergeLastUndos(3)
                }, moveHomeEndTimeoutMillis)
            },
            "1farRight": function () {
                if (fx.selectedRegions.length) {
                    if (selectMode == "char") {
                        moveSelectionRight()
                    } else {
                        indent()
                        ghostSelection = fx.selectedRegions[0]
                        fx.selectedRegions = []
                    }
                } else if (fx.fileMode == "fileList" || fx.fileMode == "directory") {
                    goDownFileList()
                } else if (ghostSelection) {
                    indent(ghostSelection)
                } else if (ghostSelectionComment) {
                    indent(ghostSelectionComment)
                } else {
                    if (fx.cursorColIndex <= getExpandedIndentLength(fx.lines[fx.cursorLineIndex]) - globalTabStop) {
                        indent()
                    } else {
                        moveCursorRight()
                    }
                    // if (lastDirection == "horizontal") {
                    //     moveCursorRight()
                    // } else {
                    //     moveCursorDown()
                    // }
                }
            },
        })
    }
    if (handled) {
        document.body.addEventListener("touchend", onEndForEdges)
        updateCursorXY()
        render()
        return
    }
    
    var bbox = c.getBoundingClientRect()
    // TODO: is there any difference between cursorType select and selectedRegions.length > 0
    // yay stuff
    if ((bbox.bottom - startTouchY > (5*verticalTouchSize))) {  // hotpink marker
        // touch top third to select #topthird  #selectline #touchtop
        if (e.changedTouches[0].pageX > (bbox.width * 2 / 3)) {
            // this can be moved down below and you won't have to also set event handlers again
            if (touchTopTopTopTopMiddle_Right()) {
                return
            }
        } else if (e.changedTouches[0].pageX < (bbox.width * 1 / 3)) {
            // this can be moved down below and you won't have to also set event handlers again
            if (touchTopTopTopTopMiddle_Left()) {
                return
            }
        }
    }
    if (fx.selectedRegions.length) {
        // yay something 1 // yellow marker
        // idea: if 2 touches while selected
        // do something else like comment
        // todo: change to
        let handled = handleTouchAreasXOnly(e, {
            "sliceLeft": function () {
            },
            "sliceRight": function () {
                selectBlock()
            },
        })
        if (handled) {
            return
        }
        if (e.changedTouches[0].pageX < (bbox.width * (1/3))) {
            // select, lift finger, move on ledt side
            cursorType = "move"
            document.body.addEventListener("touchmove", onMove)
            moveListenerCount += 1
            // document.body.addEventListener("touchend", onEnd)
            document.body.addEventListener("touchend", onEndWhileSelected)
            endListenerCount += 1
        } else if (e.changedTouches[0].pageX < (bbox.width * (2/3))) {
            document.body.addEventListener("touchmove", onMoveWhileSelected)
            moveListenerCount += 1
            document.body.addEventListener("touchend", onEndWhileSelected)
            endListenerCount += 1
        } else {
            // select, lift finger, move on right side
            cursorType = "select"
            document.body.addEventListener("touchmove", onMove)
            moveListenerCount += 1
            // document.body.addEventListener("touchend", onEnd)
            document.body.addEventListener("touchend", onEndWhileSelected)
            endListenerCount += 1
        }
        selectTimeout = setTimeout(longPressAction, selectTimeoutMillis)
    } else {
        if (e.touches.length > 1 && cursorType != "select") {
            // this selectAction is the one from the first touch
            // select action will not get set on the second touch
            selectAction()
            return
        }

        var bbox = c.getBoundingClientRect()

        // commenting out the page down feature
        if (false && (bbox.top + bbox.height) - startTouchY < navTouchSize) {
            if (document.activeElement == theText) {
            } else {
                var origOffsetY = fx.offsetY
                fx.offsetY += Math.round(maxLines/2)
                if (fx.offsetY >= lines.length - 10) {
                    fx.offsetY = lines.length - 10
                }
                fx.cursorLineIndex += fx.offsetY - origOffsetY
                updateCursorXY()
                render()
                return
            }
        }

        // selectTimeout = setTimeout(selectAction, selectTimeoutMillis)
        selectTimeout = setTimeout(longPressAction, selectTimeoutMillis)
        document.body.addEventListener("touchmove", onMove)
        moveListenerCount += 1
        document.body.addEventListener("touchend", onEnd)
        endListenerCount += 1

        // yay select sub edges white marker
        // yay selectRegion selectArea // yellow marker
        // if (false) {
        if (true) {
            handleTouchAreasXOnly(e, {
                "sliceLeft": function () {
                    // log("sliceLeft")
                    clearTimeout(selectTimeout)
                    var leftSideFeature = true
                    selectAction(false, leftSideFeature)
                },
                "sliceRight": function () {
                    // log("sliceRight")
                    clearTimeout(selectTimeout)
                    selectAction(true)


                    selectBlockTimeout = setTimeout(function () {
                        selectBlock()
                    }, moveHomeEndTimeoutMillis) // reusing the millis
                    var onEndForSlice = function () {
                        clearTimeout(selectBlockTimeout)
                        document.body.removeEventListener("touchend", onEndForSlice)
                        document.body.removeEventListener("touchmove", onEndForSlice)
                    }
                    document.body.addEventListener("touchend", onEndForSlice)
                    document.body.addEventListener("touchmove", onEndForSlice)
                },
            })
        }
    }
    render()
}

function seeEl(el, body) {
    if (!el) {
        return null
    }

    return {
        tagName: el.tagName,
        id: el.id,
        className: el.className,
        isBody: el == body,
        tostring: el.toString()

    }
}
function expandSelection() {
    if (fx.selectedRegions.length == 0) {
        return
    }
    if (selectedRegion.startY != selectedRegion.stopY) {
        return
    }
    selectedRegion.selectedWord = false
    selectedRegion.selectedLine = false
    var mappedClosers = {
        "(": ")",
        "{": "}",
        "[": "]",
        ")": "(",
        "}": "{",
        "]": "[",
        "'": "'",
    }
    var leftCounts = {
        "(": 0,
        "{": 0,
        "[": 0,
        "'": 0,
    }
    var rightCounts = {
        ")": 0,
        "}": 0,
        "]": 0,
        "'": 0,
    }
    var leftDone = false
    var rightDone = false
    var lefties = "([{"
    var righties = ")]}"
    var line = fx.lines[fx.cursorLineIndex] || ""
    var expandedLine = expandLine(line, fx.cursorLineIndex)
    // here is where we first check to see if we are on a string.
    // oprimization: We don't have to get all the ranges before we can see if
    // we are in a range
    // allthough in future I may look at caching the results for other uses
    var quoteRanges = getQuoteRanges(expandedLine)
    for (var i=0; i<quoteRanges.length-2; i+=3) {
        var quoteType = quoteRanges[i]
        var start = quoteRanges[i+1]
        var end = quoteRanges[i+2]

        // exclusive end
        if (fx.cursorColIndex >= start && fx.cursorColIndex < end) {
            selectedRegion.startX = start
            selectedRegion.stopX = end
            render()
            return
        }
    }
    var i = 0
    for (i=0; i<50000; i++) {
        if (leftDone && rightDone) {
            break
        }
        // TODO: instead of calling u (unExpandTabIndex) every time
        // expand it once and just use index instead of charat.
        if (!leftDone) {
            // var leftChar = line.charAt(u(selectedRegion.startX - 1))
            var leftChar = expandedLine[selectedRegion.startX - 1]
            if (righties.indexOf(leftChar) != -1) {
                leftCounts[mappedClosers[leftChar]] -= 1
                selectedRegion.startX -= 1
            } else if (lefties.indexOf(leftChar) != -1) {
                leftCounts[leftChar] += 1
                if (leftCounts[leftChar] == 1) {
                    leftDone = true
                } else {
                    selectedRegion.startX -= 1
                }
            } else {
                // technically better if you unexpand and then expand
                selectedRegion.startX -= 1
            }
            if (selectedRegion.startX <= 0) {
                selectedRegion.startX = 0
                leftDone = true
            }
        }
        if (!rightDone) {
            // stopX is exclusive
            var rightChar = expandedLine[selectedRegion.stopX - 1 + 1]
            if (lefties.indexOf(rightChar) != -1) {
                rightCounts[mappedClosers[rightChar]] -= 1
                selectedRegion.stopX += 1
            } else if (righties.indexOf(rightChar) != -1) {
                rightCounts[rightChar] += 1
                if (rightCounts[rightChar] == 1) {
                    rightDone = true
                } else {
                    selectedRegion.stopX += 1
                }
            } else {
                // technically better if you unexpand and then expand
                selectedRegion.stopX += 1
            }
            if (selectedRegion.stopX >= expandedLine.length) {
                selectedRegion.stopX = expandedLine.length
                rightDone = true
            }
        }
    }

    if (selectedRegion.startX == 0 && selectedRegion.stopX == expandedLine.length) {
        selectMode = "line"
        selectedRegion.selectedWord = false
        selectedRegion.selectedLine = false
    }


    // if (i == 0) {
    //     
    // }
    // var foo = bar(biz(abc + yo.test + 2004), something.something("else to" , do))
    // var x1 =
    // order . , ( ) =
    render()
    // expandSelectTimeout = selectTimeout(expandSelection, expandSelectTimeoutMillis)
}

function getNextScrollableElement(el, body) {
    if (!el) {
        return body
    }
    if (el == body) {
        return body
    }
    if (el.scrollHeight > el.clientHeight && el.scrollTop < el.scrollHeight - el.clientHeight) {
        return el
    }

    return getNextScrollableElement(el.parentElement, body)
}
function getNextScrollableElementUp(el, body) {
    if (!el) {
        return body
    }
    if (el == body) {
        return body
    }
    if (el.scrollHeight > el.clientHeight && el.scrollTop > 0) {
        return el
    }

    return getNextScrollableElementUp(el.parentElement, body)
}
function getSelectedFilePathInDirectory() {
    var prefix = fx.fullPath
    // To prevent leading double slash
    if (prefix == "/") {
        prefix = ""
    }
    var addPath = fx.lines[fx.cursorLineIndex]
    if (addPath == "..") {
        var parts = prefix.split("/")
        if (parts.length > 0) {
            parts = parts.slice(0, parts.length - 1)
        }
        var newFullPath = parts.join("/")
    } else {
        var newFullPath = prefix + "/" + addPath
    }
    return newFullPath
}
function clickItemInDirectory() {
    var newFullPath = getSelectedFilePathInDirectory()
    if (fx.cursorColIndex != -fx.marginLeft && !fx.pinned) {
        replaceFile(newFullPath, {
        })
    } else {
        var newFile = addFile(newFullPath, {
            preventSelect: true,
        })
    }
}
function replaceFile(newFullPath, options) {
    var closedLeftMostFile = false
    var oldFX = fx
    if (files[0] == fx) {
        closedLeftMostFile = true
    }
    closeFile()
    
    options.addBefore = closedLeftMostFile
    options.color = oldFX.color
    options.group = oldFX.group
    var newFile = addFile(newFullPath, options)
}

// copied from https://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function escapeRegex(string) {
    return string.replace(/[/\-\\^$*+?.()|[\]{}]/g, '\\$&');
}

function fuzzyLineMatchToRegexp(theLine) {
    // I think you have to put spaces around symbols even though the spaces are there in real life
    var regexpString = theLine.trim().split(" ").map(function (w) {
        var possibleWordBoundary = ""
        // todo, bug with shell because  of hope it implements isWordyChar 
        if (isWordyChar(w[0], true)) {
            // should we forget about word boundaries? 
            possibleWordBoundary = "\\b"
        }
        return possibleWordBoundary + w.split("").map(function(c) {
            return escapeRegex(c)
        }).join("\\w*")
        // }).join(".*")
    }).join(".*")
    return {
        string: regexpString,
        regexp: new RegExp(regexpString, 'i')
    }
}
var aclV2 = null
function autocompleteLineV2() {
    var theLine = fx.lines[fx.cursorLineIndex] || ""
    if (aclV2 == null) {
        var r = fuzzyLineMatchToRegexp(theLine)
        searchText.value = r.string
        saveSearchHistory()
        aclV2 = {
            seed: theLine,
            regexp: r.regexp,
            originatingFileComplete: false,
            fileIndex: 0,
            fileLineIndex: 0,
            seen: {},
            indent: getIndent(theLine)
        }
    }
    autocompleteLineV2Run()
    render()
}
function autocompleteLineV2Run() {
    var a = aclV2
    var fileToCheck
    var loopCount = 0
    for (var _s=0; _s<500;_s++) {
        // TODO: don't process duplicate files 
        if (!a.originatingFileComplete) {
            // log("sesrching original file")
            fileToCheck = fx
        } else {
            fileToCheck = files[a.fileIndex]
            if (fileToCheck == fx) {
                a.fileIndex++
                fileToCheck = files[a.fileIndex]
            }
            // log("searching file at index " + a.fileIndex)
            if (!fileToCheck) {
                aclV2 = null
                // log("nulling out aclV2")
                searchText.value = ""
                render()
                return
            }
        }
        for (var i=a.fileLineIndex; i < fileToCheck.lines.length; i++) {
            loopCount++
            // if (loopCount > 100) {
            //     log("git loop count")
            //     return
            // }
            // log("inner loop at  " + a.fileIndex + ": " + i)
            var line = fileToCheck.lines[i]
            if (fileToCheck == fx && i == fx.cursorLineIndex) {
                continue
            }
            if (a.regexp.test(line)) {
                // TODO: should I use updateLine function
                var trimmed = line.trim()
                if (a.seen[trimmed]) {
                    continue
                }
                a.seen[trimmed] = true
                fx.lines[fx.cursorLineIndex] = a.indent + trimmed
                a.fileLineIndex = i+1
                // log("match: " + "("+i+")" + line)
                render()
                return
            } else {
                // log("bust: " + line)
                // a.fileLineIndex = i+1
                // return
            }
        }
        if (!a.originatingFileComplete) {
            a.originatingFileComplete = true
            a.fileIndex = 0
        } else {
            a.fileIndex++
        }
        a.fileLineIndex = 0
    }
}

// fuzzyMatch("fzy", "if")
// false
// fuzzyMatch("fzy", "fuzzy")
// true
function fuzzyMatch(fuzzyWord, word) {

    if (!word) {
        return false
    }
    // make sure the first letter matches
    if (fuzzyWord.charAt(0).toLowerCase() != word.charAt(0).toLowerCase()) {
        return false
    }
    if (word.length > 100) {
        // prevent against long base64 values from matching
        return false
    }

    fuzzyWord = fuzzyWord.toLowerCase()
    word = word.toLowerCase()
    var lastMatch = -1
    for (var i=0; i<fuzzyWord.length; i++) {
        var chr = fuzzyWord.charAt(i)
        lastMatch = word.indexOf(chr, lastMatch+1)
        if (lastMatch == -1) {
            return false
        }
    }
    return true
}
var fuzzyAutocomplete = true


var shouldAutocompleteLine = false
// NEW FIND WORD
var acWord = null
function acWordToggle(recursive) {
    if (acWord == null) {
        var w
        if (lastAction == "move") {
            w = getWordAtCursor()
        } else {
            if (shouldAutocompleteLine) {
                w = {
                    // do we need statrt and end
                    word: (fx.lines[fx.cursorLineIndex] || "").trim()
                }
            } else {
                w = getWordBeforeCursor()
            }
        }

        acWord = {
            startY: fx.cursorLineIndex,
            stopY: fx.cursorLineIndex,
            hasPlopped: false,
            seen: {}
        }
        var theLine = fx.lines[fx.cursorLineIndex]
        if (lastAction == "type") {
            // start on autocomplete line
            //if (theLine.substring(0, w.start)
            acWord.prefix = w.word
            acWord.word = w.word

            // fuzzy
            acWord.startXNonFuzzy = fx.cursorColIndex
            acWord.stopXNonFuzzy = fx.cursorColIndex
            acWord.startX = expandTabIndex(theLine, w.start)
            acWord.stopX = expandTabIndex(theLine, w.end)

            // to prevent autocomplet in the middle
            // of a word from getting that compound word.
            var _w = getWordAtCursor()
            acWord.seen[_w.word] = true

            // if it's the start of the line
            // do autocomplete whole line
            // works for languages where lines start with words usually
            //if (theLine.trim() == w.word) {
            // if (theLine.trim() == w.word && !hasMovedSinceNewLine) {
            if (shouldAutocompleteLine) {
                acWord.autocompleteLine = true
            }
            shouldAutocompleteLine = false
        } else {
            acWord.startX = expandTabIndex(theLine, w.start)
            acWord.stopX = expandTabIndex(theLine, w.end)
            acWord.word = w.word
        }
        acWord.fileIndex = files.indexOf(fx)
        if (acWord.fileIndex == -1) {
            acWord.fileIndex = 0
        }
        acWord.findUpX = fx.lines[fx.cursorLineIndex].length
        acWord.findUpY = fx.cursorLineIndex
        if (acWord.autocompleteLine) {
            acWord.findUpY = fx.cursorLineIndex <= 0 ? 0 : fx.cursorLineIndex - 1
        }
        acWord.findDownX = 0
        acWord.findDownY = fx.cursorLineIndex + 1
        acWord.findDirection = false // true: up, false: down
        acWord.toggleCount = 0
        acWord.clearedWord = acWord == ""
        acWord.pasteLastCleared = false
        acWord.pastedLastTyped = false
        acWord.pastedCopyBufferInLine = false
        // acWord.pastedCutBufferInLine = false
        acWord.findUpDone = false
        acWord.findDownDone = false
        // so replacements don't affect search
        acWord.origLine = fx.lines[fx.cursorLineIndex]
    }
    // single for loop so we can break
    loopBlock:
    for (var s=0; s<1; s++) {
        if (acWord.prefix) {
            // just autocomplete
            var loopCount = 0
            var found = ""
            loopFind:
            while (true) {
                found = ""
                loopCount += 1
                if (loopCount > 1000) {
                    alert("eek!")
                    break loopFind
                }
                acWord.findDirection = !acWord.findDirection
                if (acWord.fileIndex >= files.length) {
                    //alert("allDone")

                    if (acWord.autocompleteLine || !fuzzyAutocomplete) {
                        acPlop([""])
                    } else {
                        acPlop([acWord.prefix])
                    }
                    // not going to cycle to turn on shouldAutocompleteLine
                    // if (!acWord.autocompleteLine) {
                    //    shouldAutocompleteLine = true
                    // }
                    if (acWord.autocompleteLine && !acWord.hasPlopped && !recursive) {
                        acWord = null
                        acWordToggle(true)
                        return
                    }
                    acWord = null
                    return
                }
                if (acWord.findUpDone && acWord.findDownDone) {
                    acWord.findUpX = 0
                    acWord.findDownX = 0
                    acWord.findUpY = -1
                    acWord.findDownY = 0
                    acWord.findDirection = true // so next loop it goes down
                    acWord.findUpDone = true
                    acWord.findDownDone = false
                    if (acWord.fileIndex == files.indexOf(fx) && acWord.fileIndex != 0) {
                        acWord.fileIndex = 0
                    } else {
                        acWord.fileIndex+=1
                        if (acWord.fileIndex == files.indexOf(fx)) {
                            acWord.fileIndex+=1
                        }
                    }
                    continue loopFind
                }
                if (!acWord.findUpDone && acWord.findDirection) {
                    found = acFindUp().word
                    if (found == "") {
                        acWord.findUpDone = true
                        continue loopFind
                    }
                    break loopFind
                }

                if (!acWord.findDownDone) {
                    found = acFindDown().word
                    if (found == "") {
                        acWord.findDownDone = true
                        continue loopFind
                    }
                }

                if (found == "") {
                    continue loopFind
                }

                break loopFind
            }

            // here we have found a word

            if (acWord.autocompleteLine || !fuzzyAutocomplete) {
                acPlop([doTrimPrefix(found, acWord.prefix)])
            } else {
                // don't trim prefix with fuzzy match
                acPlop([found])
            }
            break loopBlock
        }

        // TODO: I think these sections aren't used???
        // here we have no prefix, not autocompleting
        if (!acWord.clearedWord && acWord.word != "") {
            acWord.clearedWord = true
            lastCleared = acWord.word
            acPlop([""])
            break loopBlock
        }

        if (!acWord.pastedLastTyped && lastWord && lastWord != acWord.word) {
            acWord.pastedLastTyped = true
            acPlop([lastWord])
            break loopBlock
        }

        if (!acWord.pasteLastCleared && lastCleared && lastCleared != acWord.word) {
            acWord.pasteLastCleared = true
            acPlop([lastCleared])
            break loopBlock
        }


        if (!acWord.pastedCopyBufferInLine && copyBuffer.length) {
            acWord.pastedCopyBufferInLine = true
            acPlop(copyBuffer)
            break loopBlock
        }

        // if (!acWord.pastedCutBufferInLine && cutBuffer.length) {
        //     acWord.pastedCutBufferInLine = true
        //     acPlop(cutBuffer)
        //     break loopBlock
        // }
        acWord.clearedWord = false
        acWord.pasteLastCleared = false
        acWord.pastedLastTyped = false
        acWord.pastedCopyBufferInLine = false
        // acWord.pastedCutBufferInLine = false
        acPlop([acWord.word])
    }
    acWord.toggleCount += 1
}

var inACPlop = false
function acPlop(buff) {
    if (buff[0].length > 0){
       acWord.hasPlopped = true
    }
    inACPlop = true
    // TODO: compare with old implementation
    // replaceFindWord
    // this one calls more orher funcs like del()
    // and paste() and we might cause a little extra work
    var oldPreventRender = preventRender
    preventRender = true
    var oldCopyBuffer = copyBuffer
    var oldCutBuffer = cutBuffer
    copyBuffer = buff
    var oldSelectMode = selectMode

    var acWordStartX = acWord.startX
    var acWordStopX = acWord.stopX
    if (acWord.autocompleteLine || !fuzzyAutocomplete) {
        acWordStartX = acWord.startXNonFuzzy
        acWordStopX = acWord.stopXNonFuzzy
    }
    fx.selectedRegions = [{
        startX: acWordStartX,
        stopX: acWordStopX,
        startY: acWord.startY,
        stopY: acWord.stopY,
    }]
    selectMode = "char"
    // the first true prevents copy
    del(true, true) // note that del does a lot more than maybe we need
    // doing this because in the case where we autocomplete next to a word,
    // we delete our word, then the last word is found and we do this thinf where we auto copy it
    // see setLastWord, kind of weird, maybe we can do something better
    // it's for the cut and type feature
    // maybe you can look at hasMovedSinceCut (inside setLastWord) too?
    copyBuffer = buff 
    acWord.stopY = acWord.startY
    paste()
    copyBufferAfterPaste = copyBuffer
    copyBuffer = buff // same thing for why we do it
    acWord.stopY = acWord.startY + copyBuffer.length - 1
    if (copyBuffer.length == 1) {
        var theLine = fx.lines[fx.cursorLineIndex] || ""
        acWord.stopX = expandTabIndex(theLine, u(acWordStartX) + copyBuffer[0].length)
        acWord.stopXNonFuzzy = acWord.stopX
    } else {
        var lastCopyBufferLine = copyBuffer[copyBuffer.length - 1]
        // note. we don't cache this
        acWord.stopX = expandTabIndex(lastCopyBufferLine, lastCopyBufferLine.length, null, null, "nocache")
        acWord.stopXNonFuzzy = acWord.stopX
    }

    if (!acWord.autocompleteLine) {
        fx.cursorColIndex = acWord.stopX
    }
    fx.cursorLineIndex = acWord.stopY
    updateCursorXY()
    ensureCursorInScreen()
    
    // see setLastWord feature where we set the
    // copyBuffer to the last word
    // this happens in paste I think.
    // if the paste sets the copy buffer
    // then we want to keep that one
    // kind of weird.
    copyBuffer = copyBufferAfterPaste
    if (copyBuffer == buff) {
        copyBuffer = oldCopyBuffer
    }
    cutBuffer = oldCutBuffer // not used
    selectMode = oldSelectMode
    fx.selectedRegions = []
    cursorType = "move"
    preventRender = oldPreventRender
    render()
    inACPlop = false
}
var maxAcFindAttempts = 1000000
function acFindUp() {
    var attempts = 0
    var w = {start: -1, end: -1, word: ""}
    for (acWord.findUpY; acWord.findUpY>=0; acWord.findUpY--) {
        var line = files[acWord.fileIndex].lines[acWord.findUpY] || ""
        // so word being changed doesn't affect cursor
        if (acWord.fileIndex == files.indexOf(fx) && acWord.startY == acWord.findUpY) {
            line = acWord.origLine
        }
        if (acWord.findUpX < 0) {
            acWord.findUpX = line.length
        }

        if (acWord.autocompleteLine) {
            var trimmedLine = line.trim()
            if (trimmedLine.startsWith(acWord.prefix)) {
                // Also make sure it's not a regular word
                // because we would have seen it in the non autocompleteLine flow.
                if (isRegularWord(trimmedLine)) {
                    continue
                }
                // the start and end don't matter
                var seen = acWord.seen[trimmedLine]
                if (!seen) {
                    acWord.seen[trimmedLine] = true
                    return {word: trimmedLine}
                }
            }
            continue
        }

        for (acWord.findUpX; acWord.findUpX>=0; acWord.findUpX--) {
            attempts++
            if (attempts > maxAcFindAttempts) {
                return {start: -1, end: -1, word: ""}
            }
            w = getWordAt(line, acWord.findUpX)
            if (w.word != "") {
                acWord.findUpX = w.start - 1
            }
            var seen = acWord.seen[w.word]
            if (!seen && w.word != "" &&

                // fuzzy
                (acWord.prefix == "" || (w.word != acWord.prefix && isAutocompleteMatch(acWord.prefix, w.word))))
            {
                if (acWord.findUpX < 0) {
                    acWord.findUpY -= 1
                }
                acWord.seen[w.word] = true
                return w
            }
        }
    }
    return {start: -1, end: -1, word: ""}
}

function isAutocompleteMatch(prefix, word) {
    if (fuzzyAutocomplete) {
        return fuzzyMatch(prefix, word)
    } else {
        return word.startsWith(prefix)
    }
}

function acFindDown() {
    var attempts = 0
    var w = {start: -1, end: -1, word: ""}
    for (acWord.findDownY; acWord.findDownY<files[acWord.fileIndex].lines.length; acWord.findDownY++) {
        var line = files[acWord.fileIndex].lines[acWord.findDownY] || ""

        if (acWord.autocompleteLine) {
            var trimmedLine = line.trim()
            if (trimmedLine.startsWith(acWord.prefix)) {
                // Also make sure it's not a regular word
                // because we would have seen it in the non autocompleteLine flow.
                if (isRegularWord(trimmedLine)) {
                    continue
                }
                // the start and end don't matter
                var seen = acWord.seen[trimmedLine]
                if (!seen) {
                    acWord.seen[trimmedLine] = true
                    return {word: trimmedLine}
                }
            }
            continue
        }

        for (acWord.findDownX; acWord.findDownX < line.length; acWord.findDownX++) {
            attempts++
            if (attempts > maxAcFindAttempts) {
                return {start: -1, end: -1, word: ""}
            }
            w = getWordAt(line, acWord.findDownX)
            if (w.word != "") {
                acWord.findDownX = w.end + 1
            }
            var seen = acWord.seen[w.word]
            if (!seen && w.word != "" &&
                // fuzzy
                (acWord.prefix == "" || (w.word != acWord.prefix && isAutocompleteMatch(acWord.prefix, w.word))))
            {
                if (acWord.findDownX >= line.length) {
                    acWord.findDownY += 1
                    acWord.findDownX = 0
                }
                acWord.seen[w.word] = true
                return w
            }
        }
        acWord.findDownX = 0
    }
    return {start: -1, end: -1, word: ""}
}
// END NEW FIND WORD
function doFormat() {
    if (!confirm("format code?")) {
        return
    }
    setLines(simpleFormat(fx.lines))
    docChanged()
    render()
}
function clearTrailingWhitespace() {
        scriptLinesWithOneLineScript(`x.replace(/\\s+$/, "")`)
}
function simpleFormat(lines) {
    // this will work as long as every indent
    // has another lone that "closes" it
    /*
    split lines
    store for each line if it's more intented
    or less indented
    */
    var newLines = []
    var lastSpaceCount = 0
    var currentIndent = 0
    for (var i=0; i<lines.length; i++) {
        var line = lines[i]
        if (line.trim() == "") {
            newLines.push("")
            continue
        }
        var spaceCount = getSpaceCount(line)
        if (spaceCount > lastSpaceCount) {
            currentIndent += 1
        } else if (spaceCount < lastSpaceCount) {
            currentIndent -= 1
        }
        if (currentIndent < 0) {
            currentIndent = 0
        }
        newLines.push(
            " ".repeat(globalTabStop * currentIndent) +
            line.trim()
        )

        lastSpaceCount = spaceCount
    }
    return newLines
}

function getSpaceCount(line) {
    spaceCount = 0
    for (var i=0; i<line.length; i++) {
        var chr = line[i]
        if (chr == " ") {
            spaceCount += 1
        } else if (chr == "\t") {
            spaceCount += globalTabStop
        } else {
            break
        }
    }
    return spaceCount
}

async function selectWorkspaceToolbar(e) {
    if (!e.target.hasAttribute("data-index")) {
        return
    }
    var index = e.target.getAttribute("data-index")
    // I guess we could have all the workspaces quietly.
    if (workspacesList[index].Name == workspaceName) {
        // make a new one
        index = "new"
    }
    await saveWorkspace()
    fetchWorkspaceWithList(index)
}


// if it's at 0 (or only ondented) you could do
// if, func, for, var!!

function selectFileRow(e) {
    if (!e.target.hasAttribute("data-index")) {
        // thinking we get here if they tap in the margin
        // or now the handle
        return
    }
    var index = e.target.getAttribute("data-index")

    selectFileIndex(index)
}
function selectFileIndex(index) {
    var file = files[index]
    // put it at the beginning.

    if (reorderFiles) {
        files.splice(index, 1)
        files.unshift(file)
    }
    setCurrentFile(file)
}

function moveFileAllTheWayLeft() {
    var theIndex = files.indexOf(fx)
    if (theIndex == -1) {
        return
    }
    if (theIndex == 0) {
        return
    }
    files.splice(theIndex, 1)
    files.splice(0, 0, fx)
    render()
    renderFileDropdown()
}
function moveFileLeft() {
    var theIndex = files.indexOf(fx)
    if (theIndex == -1) {
        return
    }
    if (theIndex == 0) {
        return
    }
    files.splice(theIndex, 1)
    files.splice(theIndex - 1, 0, fx)
    render()
    renderFileDropdown()
}
function moveFileRight() {
    var theIndex = files.indexOf(fx)
    if (theIndex == -1) {
        return
    }
    if (theIndex == files.length - 1) {
        return
    }
    files.splice(theIndex, 1)
    files.splice(theIndex+1, 0, fx)
    render()
    renderFileDropdown()
}

var uniqueID = 0
function getUniqueID() {
   uniqueID++
   return uniqueID
}

var fileToken = {}

function makeFile(fullPath, cursorLineIndex, contents) {
    var theLines = contents.split("\n")
    return {
        // fullPath should have the leading slash
        fullPath: fullPath,
        name: "",
        undo: {
            index: 0,
            stack: [contents],
            xStack: [0],
            yStack: [0],
            lastSavedLines: JSON.parse(JSON.stringify(theLines)),
            lastSavedHash: md5(contents),
        },
        fileErrors: {},
        lines: theLines,
        cursorLineIndex: cursorLineIndex,
        // cursorColIndex: 0,
        // cursorColIndex: -marginLeft,
        
        // lines.length can be empty, and marginLeft will be set later
        marginLeft: calcMarginLeft(theLines.length),
        cursorColIndex: -calcMarginLeft(theLines.length),
        // offsetY: cursorLineIndex, // you could get smarter about this
        // offsetY: max(cursorLineIndex - Math.floor(maxLines/2), 0), // you can still clean this up a bit, not sure if maxLines is ready?
        // offsetY: -minSpaceForHeader,
        offsetY: 0,
        offsetX: 0,
        fileMode: "file",
        shellCWD: "",
        version: 0,
        savedVersion: 0,
        savingVersion: -1,
        uniqueID: getUniqueID(),
        fileToken: fileToken,
        selectedRegions: [],

        lastOffsetY: -1,

        // copy color from current file
        color: window.fx ? fx.color : '',
        group: window.fx ? fx.group : '',
        highlightRanges: []
    }
}
function addFileToList(file, options) {
    options = options || {}
    if (initialFileAdding) {
        files.push(file)
    } else {
        // add it after current file if it exists in list, otherwise unshift it to the start.
        var theIndex = files.indexOf(options.fileToAddAfter || fx)
        if (theIndex != -1) {
            var spliceIndex = theIndex + 1
            if (options.addBefore) {
                spliceIndex = theIndex
            }
            files.splice(spliceIndex, 0, file)
        } else {
            files.unshift(file)
        }
    }
    renderFileDropdown()
}


function selectFileInDirectory(file, selectName) {
    if (file && file.fileMode == "directory" && selectName) {
        for (var i=0; i<file.lines.length; i++) {
            if (file.lines[i] == selectName) {
                file.cursorLineIndex = i
                updateCursorXY(file)
                ensureCursorInScreen(file)
                render()
            }
        }
    }
}
function waitFileTerminalLoad(f) {
    if (f.terminalLoadPromise) {
        return f.terminalLoadPromise
    }
}

function waitFileLoad(f) {
    if (f.loadPromise) {
        return f.loadPromise
    }
}
function addFile(fullPath, options, id, name) { // hotpink marker
    var resolve
    var p = new Promise(function(res, rej) {
        resolve = res
    })
    
    
    options = options || {}
    fullPath = normalizeFullPath(fullPath)
    if (fullPath == "") {
        return
    }
    
    if (isGitBash && fullPath.startsWith("/c/")) {
        fullPath = fullPath.substr(3)
    }

    // adding file to list beforehand to preserve order

    var cursorLineIndex = 0
    var explicitCursorLineIndex = false
    var parts = fullPath.split(":")
    
    // forgetting files with colons for now
    // if (parts.length > 2) {
    //     parts = parts.slice(0, 2)
    // }
    
    // ./lib/foo.php:1310:
    if (parts[parts.length - 1] == "") {
        parts = parts.slice(0, parts.length - 1)
    }
    
    // check that the last part is a number
    if (parts.length == 2 && (parts[1] - 0) == parts[1]) {
        fullPath = parts[0]
        cursorLineIndex = (parts[1] - 1) || 0
        explicitCursorLineIndex = true
    }
    // If the file is already in the list of open files.
    // then let it have a reference to the existing lines, like vim does.
    // quick hack to duplicate file
    if (fx && fx.fullPath == fullPath && !explicitCursorLineIndex) {
        var duped = duplicateFile(fx, -1, options, id)
        duped.loadPromise = p; resolve()
        
        selectFileInDirectory(duped, options.selectName)
        return duped
    }
    for (var i=0; i<files.length; i++) {
        if (files[i].fullPath == fullPath) {
            var duped = duplicateFile(files[i], cursorLineIndex, options, id)
            selectFileInDirectory(duped, options.selectName)
            duped.loadPromise = p; resolve()
            return duped
        }
    }
    var file = makeFile(fullPath, cursorLineIndex, "")
    file.ID = id
    if (name) {
        file.name = name
    }
    // makeFile will also carry over color and group,
    // but we can also have it explicit here
    if (options.color) {
        file.color = options.color
    }
    if (options.group) {
        file.group = options.group
    }
    // This will override the group if there is a "path decorator"
    processPathDecorator(file)
    
    
    addFileToList(file, options)
    if (!options.preventSelect) {
        setCurrentFile(file)
    }
    fetchFile(fullPath, file, id).then(() => {
        for (var i=0; i<files.length; i++) {
            if (files[i] != file && files[i].fullPath == file.fullPath) {
                // TODO: is this needed, I think duplicateFile should get these?
                // see also setLines
                files[i].lines = file.lines
                files[i].undo = file.undo
                files[i].fileErrors = file.fileErrors
                files[i].marginLeft = file.marginLeft
                if (files[i].cursorColIndex < 0) {
                    files[i].cursorColIndex = -file.marginLeft
                    ensureCursorInScreen(files[i])
                }
            }
        }
        file.cursorColIndex = -file.marginLeft
        ensureCursorInScreen(file)
        selectFileInDirectory(file, options.selectName)
        updateCursorXY(file)
        ensureCursorInScreen(file)
        render()
        resolve()
    }).catch(e => {
        alert("Error loading file " + e)
    })
    file.loadPromise = p
    return file
}

function verifyLoadedMD5(f, md5String) {
    if (!md5String) {
        return
    }
    if (md5String != f.undo.lastSavedHash) {
        log(`md5s don't match ${f.fullPath} ${md5String}; ${f.undo.lastSavedHash}`)
    }

}

var selectedButton = null
function renderFileDropdown() {
    fileRow.innerHTML = ""
    selectedButton = null
    for (var fileI=0; fileI<files.length; fileI++) {
        var file = files[fileI]
        // Todo, what causes this bug
        if (!file) {
            var err = new Error()
            log("null file error")
            log(err.stack)
            log({fileI, files})
            // this bug keeps biting me every once in a while
            alert("null file issue!! on " + fileI)
            return
        }
        // this is for the "grip handles" because we are experimenting with selecting files ontouchstart.
        // if (fileI % 5 == 0 && fileI != 0) {
        //     var button = document.createElement("div")
        //     button.className = "longButton handle"
        //     button.innerText = ""
        //     fileRow.appendChild(button)
        // }
        var button = document.createElement("div")
        // button.className = "longButton"
        button.className = "fileButton"
        button.setAttribute("data-index", fileI)
        var theName = ""
        if (file.name) {
            theName = file.name
        } else {
            var parts = file.fullPath.split("/")
            theName = parts[parts.length - 1]
        }
        button.innerText = theName.substr(0, 15)
        if (fx == file) {
            button.classList.add("selected")
            selectedButton = button
        }

        button.style.position = "relative"
        if (file.color) {
            var colorDiv = document.createElement("div")
            colorDiv.style.width = "10px"
            colorDiv.style.height = "10px"
            colorDiv.style.backgroundColor = file.color
            colorDiv.style.position = "absolute"
            colorDiv.style.top = "2px"
            colorDiv.style.right = "2px"
            colorDiv.style.border = "none"
            colorDiv.style.borderRadius = "5px"
            colorDiv.setAttribute("data-index", fileI)
            button.appendChild(colorDiv)
        }
        if (file.group || file.pinned) {
            var groupDiv = document.createElement("div")
            // groupDiv.style.height = "10px"
            // groupDiv.style.width = "10px"
            groupDiv.style.position = "absolute"
            groupDiv.style.bottom = "1px"
            groupDiv.style.right = "1px"
            groupDiv.style.border = "none"
            groupDiv.innerText = (file.group || "") + (file.pinned ? "üìç" : "")
            groupDiv.style.borderRadius = "2px"
            groupDiv.setAttribute("data-index", fileI)
            button.appendChild(groupDiv)
        }
        fileRow.appendChild(button)

    }
    
    // make sure selected button is in view.
    if (selectedButton && !initialFileAdding) {
        if (selectedButton.offsetLeft + selectedButton.clientWidth > fileRow.scrollLeft + fileRow.clientWidth) {
            fileRow.scrollLeft = selectedButton.offsetLeft - fileRow.clientWidth + selectedButton.clientWidth
        }
        if (selectedButton.offsetLeft < fileRow.scrollLeft) {
            fileRow.scrollLeft = selectedButton.offsetLeft
        }
    }


    workspaceToolbar.innerHTML = ""
    for (var wI=0; wI<workspacesList.length; wI++) {
        var w = workspacesList[wI]
        var button = document.createElement("div")
        button.className = "longButton"
        button.setAttribute("data-index", wI)
        button.innerText = w.Name.substr(0, 15)
        // Maybe do workspace ids at some point.
        if (w.Name == workspaceName) {
            button.classList.add("selected")
        }

        if (w.Color) {
            var colorDiv = document.createElement("div")
            colorDiv.style.width = "10px"
            colorDiv.style.height = "10px"
            colorDiv.style.backgroundColor = file.color
            colorDiv.style.position = "absolute"
            colorDiv.style.top = "2px"
            colorDiv.style.right = "2px"
            colorDiv.style.border = "none"
            colorDiv.style.borderRadius = "5px"
            button.style.position = "relative"
            button.appendChild(colorDiv)
        }
        workspaceToolbar.appendChild(button)
    }
    
    
    renderSaves()

}
var treeFiles = []
var fileTree = {}
var treeFilesShadow = []
function treeToLines(theTree, path, indent, kPrefix) {
    var theKeys = Object.keys(theTree)
    theKeys.sort()
    // for (var k in theTree) {
    for (var ki = 0; ki < theKeys.length; ki++ ) {
        var k = theKeys[ki]

        var childKeys = Object.keys(theTree[k])
        // Do I need this?
        childKeys.sort()
        if (false && (childKeys.length == 1)) {
            kPrefix += k + "/"
            if (theTree[k][childKeys[0]].fileToken == fileToken) {
                treeFiles.push(indent + kPrefix + "/" + childKeys[0])
                treeFilesShadow.push(theTree[k][childKeys[0]])
            } else {
                newPath = path + "/" + k + "/" + childKeys[0]
                treeToLines(theTree[k][childKeys[0]], newPath, indent + "", kPrefix)
            }
            continue
        }

        kPrefix = ""
        if (theTree[k].fileToken == fileToken) {
            if (theTree[k].fileMode == "file") {
                treeFiles.push("" + indent + kPrefix + k)
            } else if (theTree[k].fileMode == "shell") {
                treeFiles.push("" + indent + kPrefix + k)
            } else if (theTree[k].fileMode == "terminal") {
                // same as others but a separate if statement so we can easily change it later
                treeFiles.push("" + indent + kPrefix + k)
            } else {
                treeFiles.push("" + indent + kPrefix + k)
            }
            // add that suffix if you want to show the line they are on
            // + "    " + (theTree[k].lines[theTree[k].cursorLineIndex]|| "").trim() )
            treeFilesShadow.push(theTree[k])
        } else {
            treeFiles.push("" + indent + kPrefix + k)
            var newPath = path + "/" + k
            treeFilesShadow.push(newPath)
            treeToLines(theTree[k], newPath, indent + "  ", "")
        }
    }
}

function getLinesForFileList() {
    fileTree = {}

    // reset the index
    for (var i=0; i<files.length; i++) {
        // tmpIndex should only be used in this function
        files[i].tmpIndex = i
    }

    // doing the slice so we don't mutate the original array
    var sortedFiles = files.slice().sort(function(f1, f2) {
        if (f1.fileMode == "shell") {
            // TODO: should we set the fullPath for shell to be the CWD?
            return (f1.shellCWD + f1.tmpIndex) > (f2.shellCWD + f2.tmpIndex)
        } else if (f1.fileMode == "terminal") {
            // #todoterminal: how get the cwd of the process (/proc/fd) ?
            return (f1.shellCWD + f1.tmpIndex) > (f2.shellCWD + f2.tmpIndex)
        } else {
            return (f1.fullPath + f1.tmpIndex) > (f2.fullPath + f2.tmpIndex)
        }
    })

    // taking advantage of sorted order here
    for (var fileI=0; fileI<sortedFiles.length; fileI++) {
        var f = sortedFiles[fileI]
        // var parts = (f.fullPath + ":" + (f.cursorLineIndex+1)).split("/")
        // var parts = (f.fullPath + "(" + (f.tmpIndex) + ")").split("/")
        
        var groupText = ""
        if (f.group) {
            groupText = " " + f.group + " "
        }
        var pinnedText = ""
        if (f.pinned) {
            pinnedText = "üìç"
        }
        
        var parts = (f.fullPath + groupText + pinnedText + "(" + (f.ID) + ")").split("/")
        // if (f.group) {
        //     parts[parts.length - 1] = f.group + ": " + parts[parts.length - 1]
        // }
        if (f.fileMode == "shell") {
            parts = ["(cmd)", (f.tmpIndex+"").padStart(2, "0") + ": " + (f.name || "") + groupText + pinnedText]
        } else if (f.fileMode == "terminal") {
            // #todoterminal: how get the cwd of the process (/proc/fd) ?
            parts = ["(terminal)", (f.tmpIndex+"").padStart(2, "0") + ": " + (f.name || "") + groupText + pinnedText]
        }
        // var parts = (f.fullPath).split("/")
        var curTree = fileTree
        for (var partI=0; partI<parts.length; partI++) {
           var part = parts[partI]
           if (part == "") {
              continue
           }

           var childTree = curTree[part]
           if (!childTree) {
              if (partI == parts.length-1) {
                  childTree = f
              } else {
                  childTree = {}
              }
              curTree[part] = childTree
           }
           curTree = childTree
        }
    }
    treeFiles = []
    treeFilesShadow = []

    if (showFilesFlatFirst) {
        treeFilesShadow.push("initialSeparator")
        treeFiles.push("-") // blank line do you can paste on top
        for (let i = 0; i < files.length; i++) {
            // treeFiles.push(files[i].fullPath.split("/").reverse().join(" < "))

            // treeFiles.push(files[i].name || files[i].fullPath.split("/").slice(-1)[0])
            var flatName = files[i].name || files[i].fullPath.split("/").slice(-1)[0]

            var prefixText = files[i].group || ""
            if (files[i].pinned) {
                prefixText += "üìç"
            }
            if (files[i].group || files[i].pinned) {
                // flatName = prefixText + ": " + flatName
                flatName = prefixText + " " + flatName
            }

            var dirPart = files[i].fullPath.split("/").slice(0, -1).reverse().join(" < ")
            var theLen = expandTabIndex(flatName, flatName.length, null, null, "nocache")
            var gap = 35 - theLen
            if (gap < 1) {
                gap = 1
            }
            flatName = flatName + " ".repeat(gap) + "< " + dirPart
            treeFiles.push(flatName)

            // I wrote this so you could get rid of the last part if you want and only show the file name
            // treeFiles.push(files[i].name || files[i].fullPath.split("/").slice(-1)[0] + "\t\t\t\t< " + files[i].fullPath.split("/").reverse().slice(1).join(" < "))
            // treeFiles.push(files[i].name || files[i].fullPath.split("/").slice(-2).join("/"))
            // treeFilesShadow.push(files[i].fullPath)
            treeFilesShadow.push(files[i])
        }
        treeFiles.push("-")
        treeFilesShadow.push("treeSeparator")
    }

    treeToLines(fileTree, "", "", "")
    return treeFiles
}

function seeFiles() {
    if (fx.fileMode == "fileList") {
        setCurrentFile(lastFile)
        return
    }
    seeFilesForReal(true)
}

function seeFilesForReal(resetCursor) {
    splicedFiles = []

    var contents = getLinesForFileList().join("\n")
    var f = makeFile("__", 0, contents)
    f.fileMode = "fileList"

    if (resetCursor) {
        f.cursorLineIndex = 0
        f.cursorColIndex = -f.marginLeft
        var fileIndex = treeFilesShadow.indexOf(fx)
        if (fileIndex != -1) {
            f.cursorLineIndex = fileIndex
        }
    } else {
        f.cursorLineIndex = fx.cursorLineIndex
        f.cursorColIndex = fx.cursorColIndex
        f.offsetX = fx.offsetX
    }
    setCurrentFile(f)
    updateCursorXY()
    ensureCursorInScreen()
}


function goUpDirectory() {
    // go up a directory
    if (fx.fileMode == "shell" || fx.fileMode == "terminal") {
        addFile(fx.shellCWD.split("/").slice(0, -1).join("/"), {
             selectName: fx.shellCWD.split("/").slice(-1)[0]
        })
    } else {
        // addFile(fx.fullPath.split("/").slice(0, -1).join("/"), {
        //      selectName: fx.fullPath.split("/").slice(-1)[0]
        // })
        replaceFile(fx.fullPath.split("/").slice(0, -1).join("/"), {
             selectName: fx.fullPath.split("/").slice(-1)[0]
        })
    }
}
    
function setCurrentFile(file) {
    if (!file) {
        return
    }

    if (fx == file) {
        // goUpDirectory()
        duplicateFile(fx, -1)
        return
    }

    // #filestuff
    // this check doesn't seem to work
    // alt-tab after viewing files is broken
    if (fx && fx.fileMode != "fileList" && fx != file) {
        lastFile = fx
    }
    fx = file
    if (initialFileAdding) {
        return
    }
    if (fx.fileMode == "shell") {
        fileToolbar1.classList.add("hidden")
        shellToolbar1.classList.remove("hidden")
        shellToolbar2.classList.remove("hidden")
        terminalToolbar1.classList.add("hidden")
        // workspaceToolbar.classList.add("hidden")
        iframeToolbar1.classList.add("hidden")
    } else if (fx.fileMode == "terminal") {
        fileToolbar1.classList.add("hidden")
        shellToolbar1.classList.add("hidden")
        shellToolbar2.classList.add("hidden")
        terminalToolbar1.classList.remove("hidden")
        // workspaceToolbar.classList.add("hidden")
        iframeToolbar1.classList.add("hidden")
    } else if (fx.fileMode == "iframe") {
        fileToolbar1.classList.add("hidden")
        shellToolbar1.classList.add("hidden")
        shellToolbar2.classList.add("hidden")
        terminalToolbar1.classList.add("hidden")
        // workspaceToolbar.classList.add("hidden")
        iframeToolbar1.classList.remove("hidden")
        // something else can be done here? like refresh?
    } else {
        fileToolbar1.classList.remove("hidden")
        shellToolbar1.classList.add("hidden")
        shellToolbar2.classList.add("hidden")
        terminalToolbar1.classList.add("hidden")
        // workspaceToolbar.classList.remove("hidden")
        iframeToolbar1.classList.add("hidden")
    }

    if (fx.fileMode == "iframe") {
        // c.style.display = "none"
        fx.iframeWrapper.style.display = "block"
        iframeCursor.style.display = "block"
        // c.style.display = "block"
    } else {
        iframeCursor.style.display = "none"
    }
    if (lastFile && lastFile.iframe) {
        lastFile.iframeWrapper.style.display = "none"
    }
    setCanvasHeightAccordingly()
    updateCursorXY()
    ensureCursorInScreen()
    searchText.setAttribute("placeholder", fx.fullPath + " (search)")
    theText.setAttribute("placeholder", fx.fullPath.split("/").reverse().join(" < "))
    render()
    renderFileDropdown()

}


function duplicateFile(f, cursorLineIndex, options, id="") {
    options = options || {}
    if (f.fileMode == "terminal") {
        return
    }
    var oldLines = f.lines
    var oldUndo = f.undo
    var oldFileErrors = f.fileErrors
    delete f.lines
    delete f.undo
    delete f.fileErrors
    
    var fc = JSON.parse(JSON.stringify(f))
    fc.fileToken = fileToken
    fc.uniqueID = getUniqueID()
    fc.ID = id
    fc.pinned = false // we don't want to duplicate pinned
    
    f.lines = oldLines
    f.undo = oldUndo
    f.fileErrors = oldFileErrors
    // copy everything but reference lines and undo
    fc.lines = f.lines
    fc.undo = f.undo
    fc.fileErrors = f.fileErrors
    

    if (id == "") {
        fetch(proxyPath + "/duplfile?idtodup="+f.ID+"&id="+id, {
            cache: "no-cache"
        }).then(r => {
            if (r.headers.get("X-ID")) {
                fc.ID = r.headers.get("X-ID") - 0
            }
        }).catch(e => {
            alert("Error duplicating file " + e)
        })
    }
    // marginLeft got copied over already with json parse stringify
    if (window.fx) {
        fc.color = fx.color
    }
    addFileToList(fc, options)
    setCurrentFile(fc)
    if (cursorLineIndex != -1) {
        fc.cursorLineIndex = cursorLineIndex
        fc.offsetY = max(cursorLineIndex - Math.floor(maxLines/2), 0)
        ensureCursorInScreen()
    }
    
    return fc
    // TODO: eventually, update cursor position
    // when text to one file is added.
}

function downloadFile() {
    var newFullPath = fx.fullPath
    if (fx.fileMode == "directory") {
        // see also clickItemInDirectory
        var prefix = fx.fullPath
        // To prevent leading double slash #duplicatelogic?
        if (prefix == "/") {
            prefix = ""
        }
        var addPath = fx.lines[fx.cursorLineIndex]
        newFullPath = prefix + "/" + addPath
    }
    // log(newFullPath)
    window.open(proxyPath + "/saveload?fullpath=" + encodeURIComponent(newFullPath) + "&raw=1&download=1")
}

// also see makeFile
function fetchFile(fullPath, file, id="") {
    var isDir = false
    var newID = 0
    var md5String = ""
    fullPath = normalizeFullPath(fullPath)
    return fetch(proxyPath + "/saveload?fullpath=" + encodeURIComponent(fullPath) + "&raw=1&id="+id, {
        cache: "no-cache"
    }).then(r => {
        if (r.headers.get("X-Is-Dir") == "1") {
            isDir = true
        }

        // only gets id if new file
        if (r.headers.get("X-ID")) {
            file.ID = r.headers.get("X-ID") - 0
        }
        md5String = r.headers.get("X-MD5")
        return r.text()
    }).then(b => {
        file.lines = b.split("\n")
        file.marginLeft = calcMarginLeft(file.lines.length)
        if (isDir) {
            // cmd and xterm in file list feature attempt
            // I don't like it that much
            // file.lines.unshift("> cmd")
            // file.lines.unshift("> xterm")
        }
        file.undo = {
            stack: [b],
            index:0,
            xStack: [0],
            yStack: [0],
            lastSavedLines: JSON.parse(JSON.stringify(file.lines)),
            lastSavedHash: md5(b),
        }
        file.fileErrors = {}
        file.loadedFirstTime = true
        if (isDir) {
            file.fileMode = "directory"
            file.cursorLineIndex = 1
            // this might get overwritten by callers
            file.cursorColIndex = 0
        } else {
            file.fileMode = "file"
        }
        verifyLoadedMD5(file, md5String)
        
        // updateCursorXY()
        // ensureCursorInScreen()
        // render() // for good measure
    }).catch(e => {
        alert("Error loading file " + e)
    })
}

function reloadAll() {
    var seen = {}
    for (var i=0; i<files.length; i++) {
        var theFile = files[i]
        if (!seen[theFile.fullPath]) {
            reloadFile(theFile)
        }
        seen[theFile.fullPath] = true
    }
}

function reloadFile(theFile) {
    var resolve; var reject; var p = new Promise(function(res, rej) { resolve = res; reject = res });
    theFile = theFile || fx
    if (theFile.fileMode != "file" && theFile.fileMode != "directory") {
        resolve()
        return
    }
    // Update all the other instances of this same file, no matter if it's the current file I guess
    fetchFile(theFile.fullPath, theFile, theFile.ID).then(() => {
        for (var i=0; i<files.length; i++) {
            if (files[i].fullPath == theFile.fullPath) {
                files[i].lines = theFile.lines
                files[i].marginLeft = theFile.marginLeft
                files[i].undo = theFile.undo
                files[i].fileErrors = theFile.fileErrors
                if (files[i].cursorColIndex < 0) {
                    files[i].cursorColIndex = -theFile.marginLeft
                    ensureCursorInScreen(files[i])
                }
            }
        }
        if (theFile.cursorColIndex < 0) {
            theFile.cursorColIndex = -theFile.marginLeft
            ensureCursorInScreen(theFile)
        }
        render()
        resolve()
    }).catch(e => {
        alert("Error loading file " + e)
        reject()
    })
    return p
}

var inDebugView = false
function toggleDebugView() {
    inDebugView = !inDebugView
    renderDebugView()
}

function renderDebugView() {
    if (inDebugView) {
       statusEl.classList.remove("hidden")
       logEl.classList.remove("hidden")
    } else {
       statusEl.classList.add("hidden")
       logEl.classList.add("hidden")
    }
    setCanvasHeightAccordingly()
}



var maxUndos = 30

var fx

var files = []
var workspacesList = []

var lines = []
// the actual lines will be put here by the server
// LINES GO HERE

var fileMode = "file"
// FILEMODE DIRECTORY GOES HERE

var rootLocation = "" // will be set server side
// ROOTLOCATION GOES HERE
// var paths = decodeURIComponent(location.pathname).split(",")
var paths = (location.pathname).split(",")

var firstFileMD5 = ""
// FIRSTFILEMD5 GOES HERE

var initialFileAdding = true

function fetchWorkspaceWithList(index) {
    // if (index != -1) {
    //     saveWorkspace()
    // }
    preventRender = true
    files = []
    // add exising files
    // TODO: you should hydrate this in the first pageload.
    // and maybe at least hydrate the first file.
    // #loadWorkspace
    
    var theUrl = proxyPath + "/myWorkspaceWithList" 
    if (index != -1) {
        theUrl += "?index=" + index
    }
    fetch(theUrl, {
        cache: "no-cache"
    }).then(r => {
        return r.json()
    }).then(workspaceWithList => {
        // alert(JSON.stringify(workspaceWithList, "", "  "))
        var workspace = workspaceWithList.workspace
        workspacesList = workspaceWithList.workspacesList
        workspaceName = workspace.Name
        for (var serverFile of workspace.Files) {
            // TODO: fix inconsistent file naming #inconsistentFileNaming
            var f
            if (serverFile.Type == "terminal") {
                f = addExistingTerminalTab(serverFile.ID, serverFile.Name, serverFile.CWD)
            } else if (serverFile.Type == "shell") {
                f = addCmdTab(serverFile.ID, serverFile.CWD, serverFile.Name)
            } else if (serverFile.Type == "iframe") {
                f = addIframe(serverFile.FullPath, serverFile.ID, serverFile.Name, serverFile.CWD)
            } else {
                f = addFile(serverFile.FullPath + ":" + (serverFile.LineNumber || 1), {preventSelect: false}, serverFile.ID, serverFile.Name)
            }
            // #serverAssignments
            fx.color = serverFile.Color
            fx.group = serverFile.Group || ""
            fx.pinned = serverFile.Pinned || ""
            fx.highlightRanges = serverFile.HighlightRanges
        }
        initialFileAdding = false
        var ust = new URLSearchParams(window.location.search)
        if (ust.has("fileIndex")) {
            // todo: rerender after all files finish loading?
            selectFileIndex(ust.get("fileIndex"))
        }
        if (workspace.FontName) {
            selectFont(workspace.FontName)
        }
        if (workspace.FontScale) {
            // TODO: Maybe make a setter for this, like we have in selectFont
            fontScale = workspace.FontScale;
            updateFontScale()
        }
        if (workspace.DarkMode != isDark) {
            toggleDarkMode()
        }
        if (!!workspace.InDebugView != !!inDebugView) {
            toggleDebugView()
        }
        if (workspace.HighlightMatches) {
            highlightMatches = workspace.HighlightMatches
            processHighlightMatches()
        }
        if (workspace.PathDecorators) {
            pathDecorators = workspace.PathDecorators
            processPathDecorators()
        }
    
        preventRender = false
        render()
        renderDarkMode()
    }).catch(e => {
        alert("error loading files: " + e)
    })
}

fetchWorkspaceWithList(-1)


function saveWorkspace(oldWorkspaceName) {
    var tmpWorkspace = {
        DarkMode: isDark,
        FontName: currentFont.fontName,
        FontScale: fontScale,
        HighlightMatches: highlightMatches,
        PathDecorators: pathDecorators,
        Files: [],
        Name: workspaceName
    }
    for (var i = 0; i < files.length; i++) {
        var f = files[i]
        // TODO: fix inconsistent file naming #inconsistentFileNaming
        tmpWorkspace.Files.push({
            "ID": f.ID,
            "Name": f.name,
            "Type": f.fileMode,
            "FullPath": f.fullPath,
            "LineNumber": f.cursorLineIndex + 1,
            "CWD": f.shellCWD,
            "Color": f.color,
            "Group": f.group,
            "Pinned": !!f.pinned,
            "HighlightRanges": f.highlightRanges,
            // "HighlightText": f.highlightText,
        })
    }
    oldWorkspaceName = oldWorkspaceName || ""
    return fetch(proxyPath + "/mysaveworkspace?oldWorkspaceName=" + encodeURIComponent(oldWorkspaceName), {
        cache: "no-cache",
        method: "POST",
        body: JSON.stringify(tmpWorkspace),
    // }).then(r => {
    //     return r.json()
    // }).then(r => {
    }).catch(e => {
        alert("error saving workspace: " + e)
    })
}
function setHighlightMatches() {
    var lines = getSelectedLines(fx, false).lines
    highlightMatches = []
    pathDecorators = []
    for (var i = 0; i < lines.length; i++) {
        // reasonable limit
        if (i > 200) {
            break
        }
        var line = lines[i]
        if (line.startsWith("#") || line.startsWith("//") || line.trim() == "") {
            continue
        }
        var parts = line.split(" ")
        if (parts.length < 2) {
            continue
        }
        if (isEmoji(parts[1])) {
            pathDecorators.push({
                Path: parts[0],
                Decorator: parts[1],
            })
        } else {
            highlightMatches.push({
                Regex: parts.slice(0, -1).join(" "),
                // TODO: Change this on the back and frontend to Color.
                BackgroundColor: parts[parts.length-1] || "hotpink",
                // TextColor: parts[2] || "",
                // UnderlineColor: parts[3] || ""
            })
        }
    }
    processHighlightMatches()
    processPathDecorators()
    saveWorkspace()
}

function processPathDecorators() {
    for (var i=0; i<files.length; i++) {
        var file = files[i]
        processPathDecorator(file)
    }
    render()
    renderFileDropdown()
}
function processPathDecorator(file) {
    for (var j=0; j<pathDecorators.length; j++) {
        var pd = pathDecorators[j]
        if (file.fullPath.indexOf(pd.Path) != -1) {
            // if (!file.group) {
                file.group = pd.Decorator
            // }
            break
        }
    }
}

function processHighlightMatches() {
    // turn into one big regexp
    // var r = /(foo)|(bar)|(baz)/g
    // var matches = "hello baz and foo".matchAll(r)
    // var ret = JSON.stringify([...matches].map(function (x) {
    //     return {
    //         arr: x,
    //         index: x.index,
    //         length: x.length,
    //         input: x.input
    //     }
    // }), "","    ")
    // ret
    // [
    //     {
    //         "arr": [
    //             "baz",
    //             null,
    //             null,
    //             "baz"
    //         ],
    //         "index": 6,
    //         "length": 4,
    //         "input": "hello baz and foo"
    //     },
    //     {
    //         "arr": [
    //             "foo",
    //             "foo",
    //             null,
    //             null
    //         ],
    //         "index": 14,
    //         "length": 4,
    //         "input": "hello baz and foo"
    //     }
    // ]
    if (highlightMatches.length == 0) {
        highlightMatchesSingleRegExp = null
        return
    }
    var regStrs = []
    for (var i = 0; i < highlightMatches.length; i++) {
        var h = highlightMatches[i]
        regStrs.push("("+h.Regex+")")
    }
    try {
        highlightMatchesSingleRegExp = new RegExp(regStrs.join("|"), "g")
    } catch (e) {
        highlightMatchesSingleRegExp = null
    }
}


function addParamToCurrentURL(key, value) {
    let urlObject = new URL(window.location.href);
    urlObject.searchParams.set(key, value);
    return urlObject.href;
}

var ust = new URLSearchParams(window.location.search)
if (ust.has("dark")) {
    isDark = ust.get("dark") == "1"
}

function gotoDefinition() {
    var word = getWordAtCursor().word
    if (!word) {
        return
    }
    duplicateFile(fx, -1)
    fx.color = "hotpink"
    var oldSearchText = searchText.value
    if (fx.fullPath.endsWith(".html")) {
        searchText.value = "function " + word + "\\b"
        fx.cursorLineIndex = 0
        fx.cursorColIndex = 0
        findDown()
        searchText.value = oldSearchText
    }
}


function gotoDefinition_experimental() {
    langServer({
        jsonrpc: "2.0",
        method: "textDocument/definition",
        params: {
            textDocument: {
                uri: "file://" + fx.fullPath
            },
            position: {
                line: fx.cursorLineIndex,
                character: fx.cursorColIndex
            }
            // workDoneToken:
            // partialResultToken:
        }
    })
}

var jsonRPCID = 0
function langServer(jsonRPC) {
    jsonRPC.id = jsonRPCID++
    var body = JSON.stringify(jsonRPC)
    fetch(proxyPath + "/mylangserver",  {
        cache: "no-cache",
        method: "POST",
        headers: {
            "Content-Type": "application/json-rpc",
            "Content-Length": body.length
        },
        body: body,
    }).then(r => {
        return r.json()
    }).then(r => {
    }).catch(e => {
        alert("error saving calling lang server: " + e)
    })
}

function googleIt() {
    var selectedLine = getSelectedLines(fx, false).lines[0]
    window.open("https://www.google.com/search?q=" + encodeURIComponent(selectedLine))
}


// let acl = new Accelerometer({frequency: 60});
// acl.addEventListener('reading', () => {
//    log
// });




// make sure when selecting in the margin
// that the selectMode is   line!
// add a threshold for move, like 5px or something.
// todo: in select mode, swipe down is paste. even paste over
// I turned off "Predictive" to get more vertical space


// idea send context of screen
// https://webkit.org/blog/11353/mediarecorder-api/
// https://community.openai.com/t/whisper-api-cannot-read-files-correctly/93420/16
var audioBlobs = []
let mediaRecorder;
var isRecording = false

function record() {

    if (isRecording) {
        endRecording()
    } else {
        startRecording()
    }
}
async function startRecording()
{
    fx.lines.splice(fx.cursorLineIndex + 1, 0, "")
    fx.cursorLineIndex++
    docChanged()
    render()
    isRecording = true
    blobs = []
    // stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: true });
    stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    mediaRecorder = new MediaRecorder(stream);

    mediaRecorder.ondataavailable = (event) => {
       // Let's append blobs for now, we could also upload them to the network.
       if (event.data) {
            blobs.push(event.data);
       }
    }
    mediaRecorder.onstop = doPreview;
    // Let's receive 1 second blobs
    mediaRecorder.start(1000);
}
function endRecording()
{
    isRecording = false
    // Let's stop capture and recording
    mediaRecorder.stop();
    stream.getTracks().forEach(track => track.stop());
    
}
function doPreview()
{
    if (!blobs.length)
        return;
    // Let's concatenate blobs to preview the recorded content
    var audioBlob = new Blob(blobs, { type: mediaRecorder.mimeType })
    // alert(mediaRecorder.mimeType )
    audio.src = URL.createObjectURL(audioBlob);
    // const data = new Blob(["Hello, world!"], { type: "text/plain" });
    const formData = new FormData();
    formData.append("file", audioBlob, "myfile.mp4");
    formData.append("prompt", fx.lines.slice(fx.offsetY, fx.offsetY + maxLines).join("\n"));
    formData.append("model", "whisper-1");

    var file = fx
    file.whisperCursorLineIndex = file.cursorLineIndex
    fetch(proxyPath + "/doWhisper", {
      method: "POST",
      body: formData
    })
      .then(response => response.json())
      .then(function (r) {
        updateLineFile(file, file.whisperCursorLineIndex, file.lines[file.whisperCursorLineIndex] + r.text)
        render()
        docChanged()
      })
      .catch(error => console.error(error));
}


function toSnakeCase(str) {
    return str.replace(/\.?([A-Z]+)/g, function (x,y){
        return "_" + y.toLowerCase();
    }).replace(/^_/, "");
}


// not sure this feature is a good idea
function checkButtonAction() {
    var w = getWordAtCursor(isHashTag)
    if (w.word in buttonActions) {
        buttonActions[w.word]()
        return true
    }
    return false
}
var buttonActions = {
    "#close": closeFile,
}

// compare this to the built in one thet uses server side.
// this is all local and writes to debugOutput (log2)
async function chatGPTCallPayload(payload) {
    var resolve, reject
    var p = new Promise(function (res, rej) {
        resolve = res
        reject = rej
    })
    const token = localStorage.getItem("chatgpt_token")
    
    function processSubResult(index, subResult) {
        var content = ""
        try {
           var response = JSON.parse(subResult)
           content = response.choices[0].delta.content || ""
        } catch (e) {
           content = subResult
           if (content == "[DONE]") {
               content = ""
               resolve()
               return
           }
        }
        if (index == 0) {
            log2(content)
        } else {
            log2Inline(content)
        }
    }
    var response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}`,
        },
        body: JSON.stringify(payload),
    })
    if (response.status !== 200) {
        alert("bad response code: " + response.status)
        // throw new Error("ERROR: Status Code: " + response.status);
        reject()
    }
    const reader = response.body.getReader();
    const textDecoder = new TextDecoder();
    let resultIndex = -1
    while (true) {
        const { value, done } = await reader.read();
        if (done) {
            break;
        }
        let lines = textDecoder.decode(value).split('\n');
    
        // {"id":"chatcmpl-8Hhm1KHFlSwxzDSFLQ483kXqjBuNE","object":"chat.completion.chunk","created":1699230533,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"delta":{"role":"assistant","content":""},"finish_reason":null}]}
        // {"id":"chatcmpl-8Hhm1KHFlSwxzDSFLQ483kXqjBuNE","object":"chat.completion.chunk","created":1699230533,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"delta":{"content":"1"},"finish_reason":null}]}
        // {"id":"chatcmpl-8Hhm1KHFlSwxzDSFLQ483kXqjBuNE","object":"chat.completion.chunk","created":1699230533,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"delta":{"content":","},"finish_reason":null}]}
        // {"id":"chatcmpl-8Hhm1KHFlSwxzDSFLQ483kXqjBuNE","object":"chat.completion.chunk","created":1699230533,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"delta":{"content":" "},"finish_reason":null}]}
        // {"id":"chatcmpl-8Hhm1KHFlSwxzDSFLQ483kXqjBuNE","object":"chat.completion.chunk","created":1699230533,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"delta":{"content":"2"},"finish_reason":null}]}
        // {"id":"chatcmpl-8Hhm1KHFlSwxzDSFLQ483kXqjBuNE","object":"chat.completion.chunk","created":1699230533,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"delta":{"content":","},"finish_reason":null}]}
        // {"id":"chatcmpl-8Hhm1KHFlSwxzDSFLQ483kXqjBuNE","object":"chat.completion.chunk","created":1699230533,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"delta":{"content":" "},"finish_reason":null}]}
        // {"id":"chatcmpl-8Hhm1KHFlSwxzDSFLQ483kXqjBuNE","object":"chat.completion.chunk","created":1699230533,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"delta":{"content":"3"},"finish_reason":null}]}
        // {"id":"chatcmpl-8Hhm1KHFlSwxzDSFLQ483kXqjBuNE","object":"chat.completion.chunk","created":1699230533,"model":"gpt-3.5-turbo-0613","choices":[{"index":0,"delta":{},"finish_reason":"stop"}]}
        // [DONE]
        for (let line of lines) {
            if (line.length === 0 || line[0] === ':') {
                continue; // Ignore comments and empty lines
            }
        
            if (line.startsWith('data: ')) {
                // log2(line.slice(6));
                resultIndex++
                processSubResult(resultIndex, line.slice(6))
            } else {
                // log2(line);
                resultIndex++
                processSubResult(resultIndex, line)
            }
        }
    }
    return p
}

async function chatGPTCall(model, content) {
    let payload = {
        model: model || "gpt-3.5-turbo",
        stream: true,
        messages: [
              {
                "role": "system",
                "content": "You are a helpful assistant."
              },
              {
                "role": "user",
                "content": content
              }
        ]
    }
    return chatGPTCallPayload(payload)
}

function addDumbNewline() {
    // newline
    fx.lines.splice(fx.cursorLineIndex + 1, 0, "")
    fx.cursorLineIndex++
    docChanged()
    render()
    return
}
function addSpace() {
    // space
    var theLine = fx.lines[fx.cursorLineIndex]
    theLine = theLine.slice(0, u(fx.cursorColIndex)) + " " + theLine.slice(u(fx.cursorColIndex))
    fx.lines[fx.cursorLineIndex] = theLine
    fx.cursorColIndex++
    updateCursorXY()
    docChanged()
    render()
}
function duplicateLine() {
    // # duplicateline #duplicatelinefromtop
    // but don't change copyBuffer
    var prevCopyBuffer = copyBuffer
    copyBuffer = [fx.lines[fx.cursorLineIndex]]
    selectMode = "line"
    paste(true) // true here means unselect, but it always unselects now
    copyBuffer = prevCopyBuffer
}
function duplicateSelection() {
    // #duplicateselection
    // copy(true)
    ghostSelectionComment = fx.selectedRegions[0]
    // so the duplicate, comment flow also works
    var oldCopyBuffer = copyBuffer
    copy()
    paste()
    copyBuffer = oldCopyBuffer
}
function moveSelectionUp() {
    fx.cursorLineIndex -= 1
    if (fx.cursorLineIndex < 0) {
        fx.cursorLineIndex = 0
    }
    ensureCursorInScreen()
    fx.selectedRegions[0].stopY -= 1
    if (fx.selectedRegions[0].stopY < fx.selectedRegions[0].startY) {
        fx.selectedRegions[0].stopY = fx.selectedRegions[0].startY
    }
    var theLine = fx.lines[fx.selectedRegions[0].stopY] || ""
    fx.selectedRegions[0].stopX = expandTabIndex(theLine, theLine.length, fx.selectedRegions[0].stopY)
}
function moveSelectionDown() {
    fx.cursorLineIndex += 1
    if (fx.cursorLineIndex >= fx.lines.length) {
        fx.cursorLineIndex = fx.lines.length - 1
    }
    ensureCursorInScreen()
    fx.selectedRegions[0].stopY += 1
    if (fx.selectedRegions[0].stopY > fx.lines.length - 1) { // stopY is inclusive I think, stopX isn't
        fx.selectedRegions[0].stopY = fx.lines.length - 1
    }
    var theLine = fx.lines[fx.selectedRegions[0].stopY] || ""
    fx.selectedRegions[0].stopX = expandTabIndex(theLine, theLine.length, fx.selectedRegions[0].stopY)
}
// TODO: I think these functions can be moved to the global scope
var navFileRight = function() {
    var fileIndex = files.indexOf(fx)
    if (fileIndex != -1) {
        fileIndex = fileIndex+1
        if (fileIndex < 0) {
            fileIndex = -1
        } else if (fileIndex >= files.length) {
            fileIndex = files.length - 1
        }
    } else {
        fileIndex = 0
    }
    if (fileIndex == -1) {
        seeFiles()
    } else {
        setCurrentFile(files[fileIndex])
    }
}
var navFileLeft = function() {
    var fileIndex = files.indexOf(fx)
    if (fileIndex != -1) {
        fileIndex = fileIndex-1
        if (fileIndex < 0) {
            fileIndex = -1
        } else if (fileIndex >= files.length) {
            fileIndex = files.length - 1
        }
    } else {
        fileIndex = 0
    }
    if (fileIndex >= 0) {
        // reusing moveHomeEndTimeout
        moveHomeEndTimeout = setTimeout(function() {
            fileIndex = fileIndex + 1
            setCurrentFile(files[fileIndex])
            moveFileAllTheWayLeft()
            saveWorkspace()
            // overflowX = 0
        }, moveHomeEndTimeoutMillis)
    }
    
    if (fileIndex == -1) {
        seeFiles()
    } else {
        setCurrentFile(files[fileIndex])
    }
}
var moveCursorUp = function() {
    hasMovedSinceCut = true
    ghostSelection = null
    // TODO:  Are there other  hasMovedSince* variables that we need to clear out?
    var theLine = fx.lines[fx.cursorLineIndex] || ""
    // if it's at the start of the line (not including leading space)
    var theIndent = getIndent(theLine)
    if (theIndent == theLine.substr(0, u(fx.cursorColIndex))) {
        // find another line with that same indent.
        for (var moveI=fx.cursorLineIndex-1; moveI>0; moveI--) {
            if (fx.lines[moveI].trim() == "") {
                continue
            }
            var otherIndent = getIndent(fx.lines[moveI])
            if (otherIndent == theIndent) {
                fx.cursorLineIndex = moveI
                ensureCursorInScreen()
                return
            } else if (fx.lines[moveI].trim() != "" && otherIndent.length < theIndent.length) {
                break // don't go past close of block
            }
        }
        return
    }
    if (fx.cursorLineIndex > 0) {
        fx.cursorLineIndex--
    }
    ensureCursorInScreen()
}
var moveCursorDown = function() {
    hasMovedSinceCut = true
    ghostSelection = null
    // TODO:  Are there other  hasMovedSince* variables that we need to clear out?
    var theLine = fx.lines[fx.cursorLineIndex] || ""
    // if it's at the start of the line (not including leading space)
    var theIndent = getIndent(theLine)
    if (theIndent == theLine.substr(0, u(fx.cursorColIndex))) {
        // find another line with that same indent.
        for (var moveI=fx.cursorLineIndex+1; moveI<fx.lines.length-1; moveI++) {
            if (fx.lines[moveI].trim() == "") {
                continue
            }
            var otherIndent = getIndent(fx.lines[moveI])
            if (otherIndent == theIndent) {
                fx.cursorLineIndex = moveI
                ensureCursorInScreen()
                return
            } else if (fx.lines[moveI].trim() != "" && otherIndent.length < theIndent.length) {
                break // don't go past close of block
            }
        }
        return
    }
    if (fx.cursorLineIndex < fx.lines.length - 1) {
        fx.cursorLineIndex++
    }
    ensureCursorInScreen()
}
var moveCursorRight = function() {
    moveHomeEndDirection = "right"
    moveHomeEndTimeout = setTimeout(moveHomeEndAction, moveHomeEndTimeoutMillis)
    // the "true ||" essentially comments out the shift screen to the left feature
    // in practice it wasn't that helpful because I did one char at a time
    if (true || document.activeElement == theText) {
        fx.cursorColIndex += 1
        if (document.activeElement == theText) {
            //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
            setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
        }
        ensureCursorInScreen()
    } else {
        var origOffsetX = fx.offsetX
        // scroll by tabstop?
        if (false && fx.offsetX < 0) {
            fx.offsetX = 0
        }  else {
            // var tabStop = 4
            var tabStop = 1 // we changed this to only move one cursor at a time
            fx.offsetX = Math.ceil((fx.offsetX + 1) / tabStop) * tabStop
        }
        ////fx.offsetX += Math.floor(maxCols/2)
        // fx.cursorColIndex += fx.offsetX - origOffsetX
        fx.cursorColIndex += 1
    }
}
var moveCursorLeft = function() {
    moveHomeEndDirection = "left"
    moveHomeEndTimeout = setTimeout(moveHomeEndAction, moveHomeEndTimeoutMillis)
    // the "true ||" essentially comments out the shift screen to the left feature
    // in practice it wasn't that helpful because I did one char at a time
    if (true || document.activeElement == theText) {
        fx.cursorColIndex -= 1
        if (document.activeElement == theText) {
            //theText.setSelectionRange(fx.cursorColIndex, fx.cursorColIndex)
            setSelectionRangeForText(fx.cursorColIndex, fx.cursorColIndex)
        }
        ensureCursorInScreen()
    } else {
        var origOffsetX = fx.offsetX
        if (false && fx.offsetX <= 0) {
            fx.offsetX = -fx.marginLeft
        }  else {
            // var tabStop = 4
            var tabStop = 1 // we changed this to only move one cursor at a time
            fx.offsetX = Math.floor((fx.offsetX-1) / tabStop) * tabStop
        }
        // fx.cursorColIndex += fx.offsetX - origOffsetX
        fx.cursorColIndex -= 1
        if (fx.cursorColIndex < -fx.marginLeft) {
             fx.cursorColIndex = -fx.marginLeft
        }
    }
}

var moveCursorLeftSnap = function() {
    var theLine = fx.lines[fx.cursorLineIndex] || ""
    var curChar = theLine[u(fx.cursorColIndex-1)]
    if (!curChar) {
        return
    }
    var wordiness = isWordyChar(curChar)
    for (var x=fx.cursorColIndex-1; x>0;x--) {
        // not looping by grapheme?
        var otherWordiness = isWordyChar(theLine[x])
        if (otherWordiness != wordiness) {
            fx.cursorColIndex = expandTabIndex(theLine, x+1)
            ensureCursorInScreen()
            return
        }
    }
    fx.cursorColIndex = 0
    ensureCursorInScreen()
}
var moveCursorRightSnap = function() {
    var theLine = fx.lines[fx.cursorLineIndex] || ""
    var curChar = theLine[u(fx.cursorColIndex)]
    if (!curChar) {
        return
    }
    var wordiness = isWordyChar(curChar)
    for (var x=fx.cursorColIndex; x<theLine.length;x++) {
        // not looping by grapheme?
        var otherWordiness = isWordyChar(theLine[x])
        if (otherWordiness != wordiness) {
            fx.cursorColIndex = expandTabIndex(theLine, x)
            ensureCursorInScreen()
            return
        }
    }
    fx.cursorColIndex = expandTabIndex(theLine, -1)
    ensureCursorInScreen()
}
var moveSelectionRight = function() {
    fx.selectedRegions[0].stopX += 1
    var theLine = fx.lines[fx.selectedRegions[0].stopY] || ""
    var expandedIndex = expandTabIndex(theLine, theLine.length, fx.selectedRegions[0].stopY)
    if (fx.selectedRegions[0].stopX > expandedIndex) {
        fx.selectedRegions[0].stopX = expandedIndex
    }
}
var moveSelectionLeft = function() {
    fx.selectedRegions[0].stopX -= 1
    if (fx.selectedRegions[0].stopX < 0) {
        fx.selectedRegions[0].stopY = 0
    }
}
var goDownFileList = function() {
    fx.cursorLineIndex += 1
    if (fx.cursorLineIndex >= fx.lines.length) {
        fx.cursorLineIndex = fx.lines.length - 1
    }
    ensureCursorInScreen()
}
var goUpFileList = function() {
    fx.cursorLineIndex -= 1
    if (fx.cursorLineIndex < 0) {
        fx.cursorLineIndex = 0
    }
    ensureCursorInScreen()
}

var mappingPositions = [
    "farLeft",
    "sliceLeft",
    "left",
    "midLeft",
    "middle",
    "midRight",
    "right",
    "sliceRight",
    "farRight",
]

// yay
function handleTouchAreas(e, mapping) {
    // aa bbb cc ddd ee fff gg
    var bbox = c.getBoundingClientRect() // deeppink marker
    outer:
    for (var y=4; y>=0; y--) {
        if (bbox.bottom - e.changedTouches[0].pageY > (y*verticalTouchSize)) {
            for (var x=0; x>=0; x++) {
                if (e.changedTouches[0].pageX < (bbox.width * touchRatios[x])) {
                    var mappingKey = (y+1) + mappingPositions[x]
                    if (mapping[mappingKey]) {
                        // log("yay: " + mappingKey)
                        mapping[mappingKey]()
                        return true
                    }
                    break outer
                }
            }
        }
    }
    return false
}
function handleTouchAreasXOnly(e, mapping) {
    // aa bbb cc ddd ee fff gg
    var bbox = c.getBoundingClientRect() // deeppink marker
    outer:
    for (var x=0; x>=0; x++) {
        if (e.changedTouches[0].pageX < (bbox.width * touchRatios[x])) {
            var mappingKey = mappingPositions[x]
            if (mapping[mappingKey]) {
                // log("yay: " + mappingKey)
                mapping[mappingKey]()
                return true
            }
            break outer
        }
    }
    return false
}
// if (fx.cursorColIndex < 0 || fx.cursorColIndex > expandTabIndex(fx.lines[fx.cursorLineIndex])) {
// yay
function touchAreasPressWhileSelected(e, state) {
    handleTouchAreas(e, {
        "5middle": function () {
            doTogglePin()
        },
        "4right": function () {
            scriptLines()
        },
        "3middle": function() {
            editSearch()
            // openEditorCommandText()
        },
        "3midLeft": function () {
            clearSearch()
            return
        },
        "3midRight": function () {
            clearSearch()
        },
        "2left": function() {
            if (selectMode == "line") {
                // only if you select the whole line can you comment.
                // hopefully to  prevent against accidental commenting.
                comment()
            }
        },
        "2midLeft": function () {
        },
        "2midRight": function () {
            moveSelectionUp()
        },
        "2right": function() {
            duplicateSelection()
        },
        "3left": function() {
            // dedent()
            clearSearch()
            findUp()
        },
        "3right": function() {
            // indent()
            clearSearch()
            findDown()
        },
        "1left": function () {
            del()
        },
        "1midLeft": function () {
            preventRender = true
            del()
            paste(true, false, true) // unselect, pastebefore, smartPaste
            // paste(true, true, true) // unselect, pastebefore, smartPaste
            fx.cursorLineIndex++
            updateCursorXY()
            preventRender = false
            render()
        },
        "1middle": function () {
            fx.selectedRegions = []
            cursorType = "move"
        },
        "1midRight": function () {
            moveSelectionDown()
        },
    })
}

function fileSpot() {
    return fx.fullPath + ":" + (fx.cursorLineIndex + 1) + ":" + (u(fx.cursorColIndex) + 1)
}
function touchAreasLongPress(e, state) {
    handleTouchAreas(e, {
        "5middle": function () {
            // doRefresh()
        },
        "3middle": function() {
            var doFocus = function () {
                openEditorCommandText()
                // focus has to be on touchend or click event it seems
                // another workaround for something like this is the shouldOpenEditorCommand variable
                document.body.removeEventListener("touchend", doFocus)
            }
            document.body.removeEventListener("touchmove", state.onMove)
            moveListenerCount -= 1
            document.body.addEventListener("touchend", doFocus)
        },
        "3right": async function() {
            var r = await fetch(proxyPath + "/gotodef?fileSpot=" + encodeURIComponent(fileSpot()), {cache: "no-cache"})
            var j = await r.json()
            if (j.output[0] == "/") {
                let parts = j.output.split(":")
                addFile()
            }
        },
        "2left": function () {
            // deleteToBeginningOfLine()
            selectBlock()
            comment()
            
        },
        "2middle": function () {
            // Second row from bottom // lime marker
            // see selectAction()
            state.selectAction()

        },
        "2right": function () {
            // deleteToEndOfLine()
            selectBlock()
            duplicateSelection()
        },
        "1left": function () {
            // this moved to 1midLeft
            // join lines, also happens elsewhere #joinlines
            // var nextLine = fx.lines.splice(fx.cursorLineIndex+1, 1)[0]
            // fx.lines[fx.cursorLineIndex] = fx.lines[fx.cursorLineIndex].trimRight() + " " + nextLine.trimLeft()
            // docChanged()
            // render()

            selectBlock()
            del()
            fx.cursorLineIndex++
            updateCursorXY()
            render()
        },
        "1midLeft": function () {
            // var lefSideFeature = true
            // state.selectAction(false, true, leftSideFeature)

            // join lines, also happens elsewhere #joinlines
            var nextLine = fx.lines.splice(fx.cursorLineIndex+1, 1)[0]
            fx.lines[fx.cursorLineIndex] = fx.lines[fx.cursorLineIndex].trimRight() + " " + nextLine.trimLeft()
            docChanged()
            render()
        },
        "1middle": function () {
            // state.selectAction()

            fx.selectedRegions = []
            cursorType = "select"
            var line = fx.lines[fx.cursorLineIndex] || ""
            selectedRegion = {}
            selectedRegion.startX = 0
            selectedRegion.origStartX = fx.cursorColIndex < 0 ? 0 : fx.cursorColIndex
            selectedRegion.startY = bind(fx.cursorLineIndex, 0, fx.lines.length-1)
            selectedRegion.stopX = expandTabIndex(line, line.length)
            selectedRegion.stopY = bind(fx.cursorLineIndex, 0, fx.lines.length - 1)
            selectedRegion.stopped = true
            // setting this makes it unselect on mouse up
            selectedRegion.selectedLine = true
            selectMode = "line"
            fx.selectedRegions.push(selectedRegion)
            render()

            expandSelectTimeout = setTimeout(function () {
                selectMode = "char"
                selectedRegion.startX = fx.cursorColIndex
                selectedRegion.stopX = fx.cursorColIndex
                expandSelection()
            }, expandSelectTimeoutMillis)
            return
        },
        "1midRight": function () {
            state.selectAction(true, true)
        },
        "1right": function () {
            // should we do this newline?
            // make it run, enter.
            if (fx.fileMode == "shell" || fx.fileMode == "terminal") {
                saveWrapper() // hits enter
            } else if (fx.fileMode == "file") {
                if (fx.selectedRegions.length) {
                    runScript()
                    return
                }
                var theLine = fx.lines[fx.cursorLineIndex] || ""
                var theIndent = getIndent(theLine)
                // fx.lines.splice(fx.cursorLineIndex + 1, 0, theIndent)
                if (theLine.endsWith("{")) {
                    theIndent += " ".repeat(4)
                }
                fx.lines.splice(fx.cursorLineIndex + 1, 0, theIndent)
                fx.cursorLineIndex++
                fx.cursorColIndex = expandTabIndex(theIndent)
                updateCursorXY()
                docChanged()
                render()
                var doFocus = function () {
                    theText.focus()
                    // focus has to be on touchend or click event it seems
                    // another workaroudn for something like this is the shouldOpenEditorCommand variable
                    document.body.removeEventListener("touchend", doFocus)
                }
                document.body.removeEventListener("touchmove", state.onMove)
                moveListenerCount -= 1
                // document.body.removeEventListener("touchend", onEnd)
                // endListenerCount -= 1

                document.body.addEventListener("touchend", doFocus)
            }
        },
    })
}

function touchAreasPress(e, state) {
    handleTouchAreas(e, {
        "5middle": function () {
            // clearSearch()
            doTogglePin()
        },
        "4left": function () {
            // openVoiceCommandText()
            backspace()
        },
        "4middle": function () {
            // openVoiceCommandText()
            // addSpace()

            // add date
            var oldCopyBuffer = copyBuffer
            var d = new Date()
            copyBuffer = [
                d.getFullYear() +
                '-' +
                String(d.getMonth() + 1).padStart(2, '0') +
                '-' +
                String(d.getDate()).padStart(2, '0') +
                ' ' +
                String(d.getHours()).padStart(2, '0') +
                ':' +
                String(d.getMinutes()).padStart(2, '0') +
                ':' +
                String(d.getSeconds()).padStart(2, '0')
            ]
            paste(true, false, true)
            copyBuffer = oldCopyBuffer
        },
        "4midRight": function () {
        },
        "4right": function () {
            addDumbNewline()
        },
        "3left": function () {
            if (searchText.value != getWordAtCursor().word) {
                clearSearch()
            }
            findUp()
            
            // dedent()
        },
        "3midLeft": function () {
            clearSearch()
            return
            // if (fx.cursorColIndex < 0 || fx.cursorColIndex > expandTabIndex(fx.lines[fx.cursorLineIndex])) {
            if (fx.cursorColIndex < 0) {
                addDumbNewline()
                return
            }
            addSpace()
            return
        },
        "3middle": function () {
            editSearch()
        },
        "3midRight": function () {
            clearSearch()
            return
            if (fx.cursorColIndex < 0) {
            } else {
                backspace()
            }
        },
        "3right": function () {
            if (searchText.value != getWordAtCursor().word) {
                clearSearch()
            }
            findDown()
            
            // indent()
            // TODO: need to figure out easy indent
        },
        "2left": function () {
            comment()
        },
        "2midLeft": function () {
            // addDumbNewline()
            comment()
            duplicateLine()
            moveCursorDown()
            comment()
        },
        "2middle": function () {
            // experiment autocompleteLineV2
            if (document.activeElement == theText) {
                // special case for autocomolete entire line #autocompletelinev2
                // need the space for autocomplete to work.
                autocompleteLineV2()
                return
            } else {
                if (fx.cursorColIndex == -fx.marginLeft) {
                    comment()
                    return
                }
                pasteAndToggleStuff()
                // fallthrough
            }
        },
        "2midRight": function () {
            // make this some sort of action button?
            // like complete patterns or curly oor
            // addDumbNewline()
            
            moveCursorUp()
        },
        "2right": function () {
            duplicateLine()
            // experimenting with moving cursor down after
            moveCursorDown()
            return
        },
        
        "1left": function () {
            // moveCursorLeftSnap()
            del()
            // if (fx.cursorLineIndex > 0) {
            //     // cursor goes up so you can delete then paste as part of smartPaste flow
            //     fx.cursorLineIndex--
            //     updateCursorXY()
            //     ensureCursorInScreen()
            // }
            return
        },
        "1midLeft": function () {
            // moveCursorUp()
            
            // replace
            preventRender = true
            del()
            // paste(true, false, true) // unselect, pastebefore, smartPaste
            paste(true, true, true) // unselect, pastebefore, smartPaste
            preventRender = false
            render()
        },
        "1middle": function () {
            // fallthrough
            middleTouchHandling()
        },
        "1midRight": function () {
            moveCursorDown()
        },
        "1right": function () {
            // moveCursorRightSnap()
            if (fx.fileMode == "terminal") {
                // Paste to terminal
                sendTerminal(copyBuffer.join("\r"))
                return
            }
            if (fx.cursorColIndex < 0) {
                selectMode = "line"
            }
            if (hasMovedSinceCut || lastDeleteWasFromSelection) {
                var linesPasted = paste(true, false, true) // unselect, pastebefore, smartPaste
            } else {
                var linesPasted = paste(true, true, true) // unselect, pastebefore, smartPaste
            }
            // see ghostSelection for indenting after paste even though not selected
            // // cursor goes down to flow nicely with cursor going up from delete
            // fx.cursorLineIndex+=linesPasted
            // updateCursorXY()
            // ensureCursorInScreen()
            return
        },
        
    })
}

function middleTouchHandling() {
    // now only bottom middle
    if (fx.fileMode == "directory") {
        // #filestuff
        // openFile
        // select file in directoey
        // choose file
        // click file
        // touch file
        // click in directory touch in directory 
        // clickindirectory touchindirectory tapindirectory
        clickItemInDirectory()
        return
    }
    // Clicking a file #clickfile #touchfile #tapfile
    if (fx.fileMode == "fileList") {
        if (splicedFiles.length) {
            files.splice(fx.cursorLineIndex, 0, ...splicedFiles)
            var prevCursorLineIndex = fx.cursorLineIndex
            setLines(getLinesForFileList())
            saveWorkspace()
            fx.cursorLineIndex = prevCursorLineIndex
            updateCursorXY()
            ensureCursorInScreen()
            splicedFiles = []
            return
        }
        var file = treeFilesShadow[fx.cursorLineIndex]
        // file can be either a file object or a path
        // if it has this special file token then we know it's a file
        if (file.fileToken == fileToken) {
            // #filestuff
            // see if the < signs are there
            var stopI = u(fx.cursorColIndex)
            var line = fx.lines[fx.cursorLineIndex] || ""
            var matchI = 0
            var countAngles = 0
            for (var i = 0; i < stopI; i++) {
                if (line[i] == "<") {
                    countAngles++
                }
            }
            if (countAngles > 0) {
                var newFilePath = file.fullPath.split("/").slice(0, -countAngles).join("/")
                var newFile = addFile(newFilePath, {
                    color: file.color,
                    group: file.group,
                    fileToAddAfter: file,
                })
                return
            }
            setCurrentFile(file)
            return
        }
        // here load file that hasn't been loaded
        // in this case "file" var is just a string
        // #filestuff
        // TODO: you could see if there is already one "directory" file here!
        // also TODO: you could not overwrite the lastFile when showing the files view.
        fx = lastFile || files[0]
        addFile(file)
        return
    }


    
    if (fx.cursorColIndex == -fx.marginLeft) {
        // since we are in the margin, let's force it
        // to paste line-style.
        if (fx.fileMode == "terminal") {
            sendTerminal(copyBuffer.join("\r"))
            return
        }
        
        selectMode = "line"
        // #tapinmargintopaste
        paste(false, false, true)
        return
    }
    if (fx.fileMode == "terminal") {
        // #todoterminal send a tab?
        if (document.activeElement == theText) {
            sendTerminal("\t")
        } else {
            theText.focus()
        }
        return
    }

    // the !hasMovedSinceCut is so we can paste inline without going in to insert mode
    // if (document.activeElement == theText || !hasMovedSinceCut) {
    // when to focus the text // red marker
    // Now you have to tap in middle secrion to edit
    // if (document.activeElement == theText || e.changedTouches[0].pageY > c.clientHeight/3*2) {

    // todo: you could include the getBoundingClientRect().top offset like in other places
    // if (document.activeElement == theText || e.changedTouches[0].pageY < c.clientHeight/3*2) { // high section handled on touch start with selecting
    var bbox = c.getBoundingClientRect()
    
    
    if (document.activeElement == theText) { // high section handled on touch start with selecting
        pasteAndToggleStuff()
    } else {
        if (fx.iframe) {
            var mouseEventInfo = {
                view: window,
                bubbles: true,
                cancelable: true,
                screenX: fx.iframeCursorX + fx.iframeWrapper.scrollLeft,
                screenY: fx.iframeCursorY + fx.iframeWrapper.scrollTop,
            }
            var el = fx.iframe.contentWindow.document.elementFromPoint(fx.iframeCursorX + fx.iframeWrapper.scrollLeft, fx.iframeCursorY + fx.iframeWrapper.scrollTop);
            el.dispatchEvent(new MouseEvent('mouseenter', mouseEventInfo));
            el.dispatchEvent(new MouseEvent('mouseover', mouseEventInfo));
            el.dispatchEvent(new MouseEvent('mousedown', mouseEventInfo));
            el.dispatchEvent(new MouseEvent('mouseup', mouseEventInfo));
            el.dispatchEvent(new MouseEvent('click', mouseEventInfo));

            if (el.tagName == "INPUT") {
                el.focus()
            } else {
                sel = fx.iframe.contentWindow.getSelection();
                setTimeout(function(){
                    range = fx.iframe.contentWindow.document.createRange()
                    range.selectNodeContents(el)
                    sel.removeAllRanges()
                    sel.addRange(range)
                    // fx.iframe.contentWindow.navigator.clipboard.writeText(sel.toString())
                    copyBuffer = sel.toString().split("\n")
                }, 1);
            }
        } else {
            if (fx.cursorLineIndex >= fx.lines.length) {
                fx.cursorLineIndex = fx.lines.length - 1
                updateCursorXY()
                render()
            }

            // This part for moving the cursor where you tapped (if you want that feature)
            if (false) {
                var bbox = c.getBoundingClientRect()
                var pointX = startTouchX - bbox.left
                var pointY = startTouchY - bbox.top
                fx.cursorColIndex = Math.round(
                    ((pointX * 3)/fontWidth) + fx.offsetX
                )
                fx.cursorLineIndex = Math.round(
                    ((pointY * 3)/fontHeight) + fx.offsetY
                )
                updateCursorXY()
            }

            if (true) {
                // the handleFocusIn function will do some
                // processing

                // lol buttons
                if (!checkButtonAction()) {
                    theText.focus() // aquamarine marker
                }
            }
        }
    }
    // end balooga coral marker
}
function pasteAndToggleStuff() {
    // #alternateTap
    // lol buttons
    var w = getWordBeforeCursor()
    if (alternateTap && lastAction == "move" || w.word == "") { // red marker
        if (!checkButtonAction()) {
            var w = getWordAtCursor()
            //if (w.word == "" || w.start == fx.cursorColIndex) {
            if (w.word == "") {
                selectMode = "char"
                // paste(false, false, true)
                // #taptopaste
                paste(false, false, true, true)
            } else if (w.word != "") {
                // # taptodelete #taptocut
                var sr = {}
                selectMode = "char"
                var theLine = fx.lines[fx.cursorLineIndex] || ""
                sr.startY = fx.cursorLineIndex
                sr.startX = expandTabIndex(theLine, w.start)
                sr.stopY = fx.cursorLineIndex
                sr.stopX = expandTabIndex(theLine, w.end)
                fx.selectedRegions = [sr]
                del(false, true) // new
                render()
            }
        }
    } else {
        acWordToggle() // lime marker
    }
}

function convertToNumber(x) {
}
var voiceCommandTimeout

// async flow... concatenative
// saying a nunber goes to that line number
// 243 
// select will select current line
// up
// minus 10
// 10 go
// clear
//

// 7842 and 12419 and 98346 and 76412
// Is working again 
// 12408 go select unselect


var voiceCommandLastProcessedWordIndex = 0
var voiceStack = []
var voiceCommandArgs = {
    "previous": true,
    "next": true,
    "up": true,
    "down": true,
    "left": true,
    "right": true,
    // up scroll down scroll left scroll, right scroll
    // Scroll down scroll left scroll, right scroll
    // up and scroll down and scroll left and scroll right and scroll
    // Move up move down scroll up up scroll scroll up
    
}
var voiceCommandBuffer = []
var availableVoiceCommands = {
    "line": function (n) {
        fx.cursorLineIndex = lineNumber.replaceAll(",", "") - 1
        ensureCursorInScreen()
    },
    "select": function () {
        fx.selectedRegions = []
        cursorType = "select"
        var line = fx.lines[fx.cursorLineIndex] || ""
        selectedRegion = {}
        selectedRegion.startX = 0
        // selectedRegion.origStartX = fx.cursorColIndex < 0 ? 0 : fx.cursorColIndex
        selectedRegion.startY = bind(fx.cursorLineIndex, 0, fx.lines.length-1)
        selectedRegion.stopX = expandTabIndex(line, line.length)
        selectedRegion.stopY = bind(fx.cursorLineIndex, 0, fx.lines.length - 1)
        selectedRegion.stopped = true
        // selectedRegion.selectedLine = true
        selectMode = "line"
        fx.selectedRegions.push(selectedRegion)
        render()
    },
}

var waitingVoiceCommandFunctions = []
function inputVoiceCommandText(e) {
    clearTimeout(voiceCommandTimeout)
    voiceCommandTimeout = setTimeout(function () {
        var lowerCased = voiceCommandText.value.toLowerCase()
        var words = lowerCased.split(" ")
        // var wordsToProcess = words.slice(voiceCommandLastProcessedWordIndex)
        for (var voiceCommandLastProcessedWordIndex; voiceCommandLastProcessedWordIndex<words.length; voiceCommandLastProcessedWordIndex++) {
            var word = words[voiceCommandLastProcessedWordIndex]
            voiceCommandBuffer.push(word)
            if (word in availableVoiceCommands) {
                waiti
            }
            if (waitingVoiceCommandFunction) {
                
            }
        }
    }, 1000)
}
var voiceCommandProcessedIndex = 0
function inputVoiceCommandText_old(e) {
    clearTimeout(voiceCommandTimeout)
    voiceCommandTimeout = setTimeout(function () {
        outer:
        while (voiceCommandProcessedIndex < voiceCommandText.value.length) {
            var lowerCased = voiceCommandText.value.toLowerCase()
            for (var i=0; i<voiceCommands.length; i+=2) {
                var text = lowerCased.substr(voiceCommandProcessedIndex)
                text = text.replaceAll(".", " ")
                
                var r = voiceCommands[i]
                var c = voiceCommands[i+1]
                var matches = text.match(r)
                if (matches) {
                    log("match: " + matches[0])
                    c(...matches)
                    // voiceCommandText.value = ""
                    // voiceCommandText.select()
                    // as of now it seems like programmatically changing the input will stop dictation from working
                    
                    // plan b
                    voiceCommandProcessedIndex += matches[0].length

                    // break
                    continue outer
                }
            }
            voiceCommandProcessedIndex = voiceCommandText.value.length
            log("processed: " + text)
        }
    }, 1000)
}


var speechRecognition

function startVoiceCommandsV2() {
    showLog()
    speechRecognition = new webkitSpeechRecognition()
    speechRecognition.continuous = true
    speechRecognition.interimResults = true
    let lastInterimTranscript = ""
    
    speechRecognition.onresult = function (e) {
        var index = e.resultIndex
        var newResults = [...e.results].slice(index)
        
        newResults.forEach(result => {
            if (result.isFinal) {
                if (result[0].transcript !== lastInterimTranscript) {
                    log2("++> " + result[0].transcript)
                    doSpeechAction(result[0].transcript)
                    lastInterimTranscript = ""
                    theText.setAttribute("placeholder", result[0].transcript)
                }
            } else {
                // and this back if you want quicker results
                // log2("--> " + result[0].transcript)
                // doSpeechAction(result[0].transcript)
                // lastInterimTranscript = result[0].transcript
                theText.setAttribute("placeholder", result[0].transcript)
            }
        })
    }
    speechRecognition.start()
}


var speechActionTimeout;
function doSpeechAction(command) {
    // clearTimeout(speechActionTimeout);
    // timeout = 300
    // if (command.indexOf("code") != -1) {
    //     timeout = 1000
    // }
    // speechActionTimeout = setTimeout(function() {
        // command = command.toLowerCase();
        command = replaceWordsWithNumbers(command)
        if (!command.toLowerCase().startsWith("assistant")) {
            return
        }

        theText.setAttribute("placeholder", command)
        runChatGPT('gpt-4o-mini', {extra: command + "\n" + onlyCode})
        // for (var i = 0; i < voiceCommands.length; i += 2) {
        //     var regex = voiceCommands[i];
        //     var action = voiceCommands[i + 1];
        //     var match = command.match(regex);
        //     if (match) {
        //         action(command, ...match.slice(1));
        //         break;
        //     }
        // }
    // }, timeout);
}


var speechActionTimeout
function toSpeechAction(command) {
    command = command.toLowerCase()
    alert("yay")
}


var voiceCommands = [
    /^go to line (\d+)/, function (c, lineNumber) {
        fx.cursorLineIndex = lineNumber.replaceAll(",", "") - 1
        ensureCursorInScreen()
    },
    /^previous tab/, function (c) {
        navFileLeft()
    },
    /^\s*close tab/, function (c) {
        closeFile()
    },
    /^next tab/, function (c) {
        navFileRight()
    },
    /^go down (\d+) lines/, function (c, d) {
        fx.cursorLineIndex += ((d-0) || 0)
        ensureCursorInScreen()
    },
    /^go up (\d+) lines/, function (c, d) {
        fx.cursorLineIndex -= ((d-0) || 0)
        ensureCursorInScreen()
    },
    /^down/, function (c) {
        fx.cursorLineIndex += 1
        ensureCursorInScreen()
    },
    /^go down (\d+) lines/, function (c, d) {
        fx.cursorLineIndex += ((d-0) || 0)
        ensureCursorInScreen()
    },
    /^last tab/, function (c) {
        setCurrentFile(lastFile) // alt tab, alt+tab
    },
    /^start selection/, function (c) {
        selectLines(1)
    },
    /^stop selection/, function (c) {
        if (fx.selectedRegions.length) {
            fx.selectedRegions[0].stopY = fx.cursorLineIndex
        }
        render()
    },
    /^select the next (\d+) lines/, function (c, d) {
        selectLines(d)
    },
    /^select block/, function (c) {
        selectLines(1)
        selectBlock()
    },
    /^select line/, function (c) {
        selectLines(1)
    },
    /^select line/, function (c) {
        selectLines(1)
    },
    /^write code/, function (c) {
        
    },
    /^generate code (.*)/, function (c, rest) {
        runChatGPT('gpt-4o-mini', {extra: c + "\n" + onlyCode})
    },
    /^update this code (.*)/, function (c, rest) {
        runChatGPT('gpt-4o-mini', {extra: c + "\n" + onlyCode})
    },
    /^add code (.*)/, function (c, rest) {
        runChatGPT('gpt-4o-mini', {extra: c + "\n" + onlyCode})
    },
    /^add some code (.*)/, function (c, rest) {
        runChatGPT('gpt-4o-mini', {extra: c + "\n" + onlyCode})
    },
    /^up/, function (c) {
        fx.cursorLineIndex -= 1
        ensureCursorInScreen()
    },
    


]

// used for voice commands
function selectLines(howMany) {
    fx.selectedRegions = []
    var line = fx.lines[fx.cursorLineIndex] || ""
    selectedRegion = {}
    selectedRegion.startX = 0
    selectedRegion.startY = bind(fx.cursorLineIndex, 0, fx.lines.length-1)
    selectedRegion.stopX = expandTabIndex(line, line.length)
    selectedRegion.stopY = bind(fx.cursorLineIndex + howMany - 1, 0, fx.lines.length - 1)
    selectedRegion.stopped = true
    selectMode = "line"
    fx.selectedRegions.push(selectedRegion)
    render()
}


// in this command replace the spelled out words with their numerical counterparts
// for example one becomes 1, two becomes 2
// go all the way to 100
// write a function that processes that (javascript)
function replaceWordsWithNumbers(command) {
    const numberWords = {
        'zero': '0', 'one': '1', 'two': '2', 'three': '3', 'four': '4',
        'five': '5', 'six': '6', 'seven': '7', 'eight': '8', 'nine': '9',
        'ten': '10', 'eleven': '11', 'twelve': '12', 'thirteen': '13',
        'fourteen': '14', 'fifteen': '15', 'sixteen': '16', 'seventeen': '17',
        'eighteen': '18', 'nineteen': '19', 'twenty': '20', 'thirty': '30',
        'forty': '40', 'fifty': '50', 'sixty': '60', 'seventy': '70',
        'eighty': '80', 'ninety': '90', 'hundred': '100'
    };
    return command.toLowerCase().replace(/\b(?:zero|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred)\b/g, match => numberWords[match]);
}



function selectBlock() {
    let sr = fx.selectedRegions[0]
    if (!sr) {
        selectLines(1)
        sr = fx.selectedRegions[0]
    }
    let curIndent = getIndent(fx.lines[fx.cursorLineIndex])

    var commentPrefix = getCommentPrefix()

    // selecting block also selects comments
    // yo
    // world
    "hi"
    // bye

    var theLine = fx.lines[fx.cursorLineIndex]
    if (theLine.trim().startsWith(commentPrefix)) {
        for (let i=fx.cursorLineIndex+1; i < fx.lines.length; i++) {
            let theLine = fx.lines[i]
            if (!theLine.trim().startsWith(commentPrefix)) {
                break
            }
            sr.stopY = i
            sr.stopX = expandTabIndex(fx.lines[i], fx.lines[i].length, i)
            fx.cursorLineIndex = sr.stopY
            updateCursorXY()
            ensureCursorInScreen()
        }
    } else {
        let nextIndent = getIndent(fx.lines[fx.cursorLineIndex + 1])
        if (nextIndent.length > curIndent.length) {
            for (let i=fx.cursorLineIndex+1; i < fx.lines.length; i++) {
                if (fx.lines[i].trim() == "") {
                    continue
                }
                let thisIndent = getIndent(fx.lines[i])
                sr.stopY = i
                sr.stopX = expandTabIndex(fx.lines[i], fx.lines[i].length, i)
                fx.cursorLineIndex = sr.stopY
                updateCursorXY()
                ensureCursorInScreen()
                if (thisIndent.length <= curIndent.length) {
                    break
                }
            }
            // for (let i=fx.cursorLineIndex-1; i >= 0; i--) {
            //     let thisIndent = getIndent(fx.lines[i])
            //     if (thisIndent < curIndent) {
            //         break
            //     }
            //     sr.startY--
            // }
        } else {
            var startI = fx.cursorLineIndex+1
            var hasGottenNonBlankLine = false
            for (let i=startI; i < fx.lines.length; i++) {
                if (fx.lines[i].trim() == "") {
                    // continue
    
                    if (hasGottenNonBlankLine) {
                        break
                    } else {
                        continue
                    }
                }
                hasGottenNonBlankLine = true
                let thisIndent = getIndent(fx.lines[i])
                if (thisIndent.length < curIndent.length) {
                    break
                }
                sr.stopY = i
                sr.stopX = expandTabIndex(fx.lines[i], fx.lines[i].length, i)
                fx.cursorLineIndex = sr.stopY
                updateCursorXY()
                ensureCursorInScreen()
            }
        }
    }

    render()
}

function xdownloadFile(bytes, type, filename) {
    var file = new Blob([new Uint8Array(bytes)], { type: type });
    var url = URL.createObjectURL(file);
    var a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    setTimeout(function() {
        document.body.removeChild(a);
        window.URL.revokeObjectURL(url);
    }, 0);
}
// df([65, 66], "text/plain", "test.txt")


// write some javascript code that will record
// video and display it in a video tag
// have it work on mobile safari and use the fromt camera



const recordVideo = async () => {
    const constraints = {
        video: {
            facingMode: 'user',
            // it's actually reversed
            height: { ideal: 720 },
            width: { ideal: 1165 }
        }
    };

    try {
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        const video = document.querySelector('#videoEl');

        // Check if the video element exists
        if (!video) {
            throw new Error('Video element not found');
        }
        video.style.display = "block"
        video.srcObject = stream; // Display live video
        // Make sure the video starts playing
        video.onloadedmetadata = () => {
            video.play();
        };
    } catch (error) {
        console.error('Error accessing media devices.', error);
    }
};

// const recordVideo = async () => {
//     const constraints = {
//         video: {
//             facingMode: 'user',
//             width: { ideal: 1280 },
//             height: { ideal: 720 }
//         }
//     };
//     try {
//         const stream = await navigator.mediaDevices.getUserMedia(constraints);
//         const video = document.querySelector('#videoEl');
//         // Check if the video element exists
//         if (!video) {
//             throw new Error('Video element not found');
//         }
//         video.srcObject = stream; // Display live video
//         // Make sure the video starts playing
//         video.onloadedmetadata = () => {
//             video.play();
//             video.style.transform = 'scaleX(-1)'; // Flip the video horizontally
//         };
//     } catch (error) {
//         console.error('Error accessing media devices.', error);
//     }
// };
// 
// what video formats does safari support?
// 
// As of October 2023, Safari supports several video formats. The primary formats include:
// 1. **MP4 (H.264/AAC)**: This is the most widely supported format and works well across various devices and browsers.
// 2. **MOV**: QuickTime format, commonly used on Apple devices.
// 3. **WebM**: Mostly supported in the latest versions of Safari but compatibility can vary based on the version.
// 4. **AVI**: Generally not natively supported in Safari, but can be played if the content is encoded in a compatible codec.
// Safari also supports additional formats through HTML5 video tags, but H.264 is the most reliable for ensuring playback across all devices. Always check for the latest updates, as browser support can change over time.

function deleteToBeginningOfLine() {
    // Delete to beginning, not sure if I want to keep this
    copyShenanigans(function () {
        var theLine = fx.lines[fx.cursorLineIndex]
        var theIndent = getIndent(theLine)
        if (theLine.trim() == "") {
            theIndent = ""
        }
        theLine = theIndent + theLine.slice(u(fx.cursorColIndex))
        fx.lines[fx.cursorLineIndex] = theLine
        fx.cursorColIndex = expandTabIndex(theLine, theIndent.length)
        updateCursorXY()
        // yo
        selectMode = "char"
        copyBuffer = [theLine.slice(theIndent.length, u(fx.cursorColIndex))]
        docChanged()
        render()
    })
}

function deleteToEndOfLine() {
    copyShenanigans(function () {
        // Delete to end
        var theLine = fx.lines[fx.cursorLineIndex]
        copyBuffer = [theLine.slice(u(fx.cursorColIndex))]
        theLine = theLine.slice(0, u(fx.cursorColIndex))
        fx.lines[fx.cursorLineIndex] = theLine
        selectMode = "char"
        docChanged()
        render()
    })
}


function moveSelectionToCursor() {
    
    var cli = fx.cursorLineIndex
    if (cli >= fx.lines.length) {
        cli = fx.lines.length - 1
    }
    var line = fx.lines[cli] || ""
    if (selectedRegion.selectedWord) {
        selectedRegion.selectedWord = false
        // selectedRegion.stopX = selectedRegion.origStopX
    }
    if ("origStartX" in selectedRegion) {
        selectedRegion.startX = selectedRegion.origStartX
        selectMode = "char"
    }
    if (selectedRegion.selectedLine) {
        selectedRegion.selectedLine = false
    }
    selectedRegion.stopX = bind(fx.cursorColIndex, 0, expandTabIndex(line, line.length))
    selectedRegion.stopY = bind(cli, 0, fx.lines.length-1)
    selectedRegion.stopped = true // TODO: I think stop can be removed
    if (fx.cursorColIndex < 0 || selectMode == "line") {
        selectedRegion.stopX = expandTabIndex(line, line.length, cli)
    }
}




</script>
<video playsinline id=videoEl style="position: absolute; top: 0; right: 0; display: none; width: 80px; height: 130px; background-color: pink; transform: scaleX(-1); border-radius: 10px;"><video>
<audio id="audio" controls></audio>
</body>
</html>
